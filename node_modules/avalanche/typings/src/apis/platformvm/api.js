"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../utils/types");
const bintools_1 = __importDefault(require("../../utils/bintools"));
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Class for interacting with a node's PlatformVMAPI
 *
 * @category RPCAPIs
 *
 * @remarks This extends the [[JRPCAPI]] class. This class should not be directly called. Instead, use the [[Avalanche.addAPI]] function to register this interface with Avalanche.
 */
class PlatformVMAPI extends types_1.JRPCAPI {
    /**
     * This class should not be instantiated directly.
     * Instead use the [[Avalanche.addAPI]] method.
     *
     * @param core A reference to the Avalanche class
     * @param baseurl Defaults to the string "/ext/P" as the path to blockchain's baseurl
     */
    constructor(core, baseurl = '/ext/P') {
        super(core, baseurl);
        /**
         * Creates a new blockchain.
         *
         * @param vmID The ID of the Virtual Machine the blockchain runs. Can also be an alias of the Virtual Machine.
         * @param name A human-readable name for the new blockchain
         * @param payerNonce The next unused nonce of the account paying the transaction fee
         * @param genesis The base 58 (with checksum) representation of the genesis state of the new blockchain. Virtual Machines should have a static API method named buildGenesis that can be used to generate genesisData.
         * @param subnetID Optional. Either a {@link https://github.com/feross/buffer|Buffer} or an cb58 serialized string for the SubnetID or its alias.
         *
         * @returns Promise for the unsigned transaction to create this blockchain. Must be signed by a sufficient number of the Subnetâ€™s control keys and by the account paying the transaction fee.
         */
        this.createBlockchain = (vmID, name, payerNonce, genesis, subnetID = undefined) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                vmID,
                name,
                payerNonce,
                genesisData: genesis,
            };
            if (typeof subnetID === 'string') {
                params.subnetID = subnetID;
            }
            else if (typeof subnetID !== 'undefined') {
                params.subnetID = bintools.cb58Encode(subnetID);
            }
            return this.callMethod('platform.createBlockchain', params)
                .then((response) => response.data.result.blockchainID);
        });
        /**
         * Creates a new blockchain.
         *
         * @param blockchainID The blockchainID requesting a status update
         *
         * @returns Promise for a string of one of: "Validating", "Created", "Preferred", "Unknown".
         */
        this.getBlockchainStatus = (blockchainID) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                blockchainID,
            };
            return this.callMethod('platform.getBlockchainStatus', params)
                .then((response) => response.data.result.status);
        });
        /**
         * The P-Chain uses an account model. This method creates a P-Chain account on an existing user in the Keystore.
         *
         * @param username The username of the Keystore user that controls the new account
         * @param password The password of the Keystore user that controls the new account
         * @param privateKey The private key that controls the account. If omitted, a new private key is generated
         *
         * @returns Promise for a string of the newly created account address.
         */
        this.createAccount = (username, password, privateKey = undefined) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
            };
            if (typeof privateKey === 'string') {
                params.privateKey = privateKey;
            }
            else if (typeof privateKey !== 'undefined') {
                params.privateKey = bintools.cb58Encode(privateKey);
            }
            return this.callMethod('platform.createAccount', params)
                .then((response) => response.data.result.address);
        });
        /**
         * The P-Chain uses an account model. An account is identified by an address. This method returns the account with the given address.
         *
         * @param address The address of the account
         *
         * @returns Promise for an object containing the address, the nonce, and the balance.
         */
        this.getAccount = (address) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                address,
            };
            return this.callMethod('platform.getAccount', params)
                .then((response) => response.data.result);
        });
        /**
         * List the accounts controlled by the user in the Keystore.
         *
         * @param username The username of the Keystore user
         * @param password The password of the Keystore user
         *
         * @returns Promise for an array of accounts.
         */
        this.listAccounts = (username, password) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
            };
            return this.callMethod('platform.listAccounts', params)
                .then((response) => response.data.result.accounts);
        });
        /**
         * Lists the set of current validators.
         *
         * @param subnetID Optional. Either a {@link https://github.com/feross/buffer|Buffer} or an
         * cb58 serialized string for the SubnetID or its alias.
         *
         * @returns Promise for an array of validators that are currently staking, see: {@link https://docs.avax.network/v1.0/en/api/platform/#platformgetcurrentvalidators|platform.getCurrentValidators documentation}.
         *
         */
        this.getCurrentValidators = (subnetID = undefined) => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            if (typeof subnetID === 'string') {
                params.subnetID = subnetID;
            }
            else if (typeof subnetID !== 'undefined') {
                params.subnetID = bintools.cb58Encode(subnetID);
            }
            return this.callMethod('platform.getCurrentValidators', params)
                .then((response) => response.data.result.validators);
        });
        /**
         * Lists the set of pending validators.
         *
         * @param subnetID Optional. Either a {@link https://github.com/feross/buffer|Buffer}
         * or a cb58 serialized string for the SubnetID or its alias.
         *
         * @returns Promise for an array of validators that are pending staking, see: {@link https://docs.avax.network/v1.0/en/api/platform/#platformgetpendingvalidators|platform.getPendingValidators documentation}.
         *
         */
        this.getPendingValidators = (subnetID = undefined) => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            if (typeof subnetID === 'string') {
                params.subnetID = subnetID;
            }
            else if (typeof subnetID !== 'undefined') {
                params.subnetID = bintools.cb58Encode(subnetID);
            }
            return this.callMethod('platform.getPendingValidators', params)
                .then((response) => response.data.result.validators);
        });
        /**
         * Samples `Size` validators from the current validator set.
         *
         * @param sampleSize Of the total universe of validators, select this many at random
         * @param subnetID Optional. Either a {@link https://github.com/feross/buffer|Buffer} or an
         * cb58 serialized string for the SubnetID or its alias.
         *
         * @returns Promise for an array of validator's stakingIDs.
         */
        this.sampleValidators = (sampleSize, subnetID = undefined) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                size: sampleSize.toString(),
            };
            if (typeof subnetID === 'string') {
                params.subnetID = subnetID;
            }
            else if (typeof subnetID !== 'undefined') {
                params.subnetID = bintools.cb58Encode(subnetID);
            }
            return this.callMethod('platform.sampleValidators', params)
                .then((response) => response.data.result.validators);
        });
        /**
         * Add a validator to the Default Subnet.
         *
         * @param id The node ID of the validator
         * @param startTime Javascript Date object for the start time to validate
         * @param endTime Javascript Date object for the end time to validate
         * @param stakeAmount The amount of nAVAX the validator is staking as
         * a {@link https://github.com/indutny/bn.js/|BN}
         * @param payerNonce The next unused nonce of the account that is providing the staked
         * AVAX and paying the transaction fee
         * @param destination The P-Chain address of the account that the staked AVAX will be returned
         * to, as well as a validation reward if the validator is sufficiently responsive and correct
         * while it validated
         * @param delegationFeeRate Optional. The percent fee this validator charges when others
         * delegate stake to them, multiplied by 10,000 as
         * a {@link https://github.com/indutny/bn.js/|BN}. For example, suppose a validator has
         * delegationFeeRate 300,000 and someone delegates to that validator. When the delegation
         * period is over, if the delegator is entitled to a reward, 30% of the reward
         * (300,000 / 10,000) goes to the validator and 70% goes to the delegator
         * @param subnetID Optional. Either a {@link https://github.com/feross/buffer|Buffer} or
         * an cb58 serialized string for the SubnetID or its alias.
         *
         * @returns Promise for a base58 string of the unsigned transaction.
         */
        this.addDefaultSubnetValidator = (id, startTime, endTime, stakeAmount, payerNonce, destination, delegationFeeRate = undefined) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                id,
                startTime: startTime.getTime() / 1000,
                endTime: endTime.getTime() / 1000,
                stakeAmount: stakeAmount.toString(10),
                payerNonce: Math.floor(payerNonce),
                destination,
            };
            if (typeof delegationFeeRate !== 'undefined') {
                params.delegationFeeRate = delegationFeeRate.toString(10);
            }
            return this.callMethod('platform.addDefaultSubnetValidator', params)
                .then((response) => response.data.result.unsignedTx);
        });
        /**
         * Add a validator to a Subnet other than the Default Subnet. The validator must validate the Default Subnet for the entire duration they validate this Subnet.
         *
         * @param id The node ID of the validator
         * @param subnetID Either a {@link https://github.com/feross/buffer|Buffer} or a cb58 serialized string for the SubnetID or its alias.
         * @param startTime Javascript Date object for the start time to validate
         * @param endTime Javascript Date object for the end time to validate
         * @param weight The validatorâ€™s weight used for sampling
         * @param payerNonce The next unused nonce of the account that is providing the staked AVAX and paying the transaction fee
         *
         * @returns Promise for the unsigned transaction. It must be signed (using sign) by the proper number of the Subnetâ€™s control keys and by the key of the account paying the transaction fee before it can be issued.
         */
        this.addNonDefaultSubnetValidator = (id, subnetID, startTime, endTime, weight, payerNonce) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                id,
                startTime: startTime.getTime() / 1000,
                endTime: endTime.getTime() / 1000,
                weight,
                payerNonce: Math.floor(payerNonce),
            };
            if (typeof subnetID === 'string') {
                params.subnetID = subnetID;
            }
            else if (typeof subnetID !== 'undefined') {
                params.subnetID = bintools.cb58Encode(subnetID);
            }
            return this.callMethod('platform.addNonDefaultSubnetValidator', params)
                .then((response) => response.data.result.unsignedTx);
        });
        /**
         * Add a delegator to the Default Subnet.
         *
         * @param id The node ID of the delegatee
         * @param startTime Javascript Date object for when the delegator starts delegating
         * @param endTime Javascript Date object for when the delegator starts delegating
         * @param stakeAmount The amount of nAVAX the delegator is staking as
         * a {@link https://github.com/indutny/bn.js/|BN}
         * @param payerNonce The next unused nonce of the account that will provide the staked
         * AVAX and pay the transaction fee
         * @param destination The address of the account the staked AVAX and validation reward
         * (if applicable) are sent to at endTime
         *
         * @returns Promise for an array of validator's stakingIDs.
         */
        this.addDefaultSubnetDelegator = (id, startTime, endTime, stakeAmount, payerNonce, destination) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                id,
                startTime: startTime.getTime() / 1000,
                endTime: endTime.getTime() / 1000,
                stakeAmount: stakeAmount.toString(10),
                payerNonce: Math.floor(payerNonce),
                destination,
            };
            return this.callMethod('platform.addDefaultSubnetDelegator', params)
                .then((response) => response.data.result.unsignedTx);
        });
        /**
         * Create an unsigned transaction to create a new Subnet. The unsigned transaction must be
         * signed with the key of the account paying the transaction fee. The Subnetâ€™s ID is the ID of the transaction that creates it (ie the response from issueTx when issuing the signed transaction).
         *
         * @param controlKeys Array of platform addresses as strings
         * @param threshold To add a validator to this Subnet, a transaction must have threshold
         * signatures, where each signature is from a key whose address is an element of `controlKeys`
         * @param payerNonce The next unused nonce of the account providing the transaction fee
         *
         * @returns Promise for a string with the unsigned transaction encoded as base58.
         */
        this.createSubnet = (controlKeys, threshold, payerNonce) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                controlKeys,
                threshold,
                payerNonce,
            };
            return this.callMethod('platform.createSubnet', params)
                .then((response) => response.data.result.unsignedTx);
        });
        /**
         * Get the Subnet that validates a given blockchain.
         *
         * @param blockchainID Either a {@link https://github.com/feross/buffer|Buffer} or a cb58
         * encoded string for the blockchainID or its alias.
         *
         * @returns Promise for a string of the subnetID that validates the blockchain.
         */
        this.validatedBy = (blockchainID) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                blockchainID,
            };
            return this.callMethod('platform.validatedBy', params)
                .then((response) => response.data.result.subnetID);
        });
        /**
         * Get the IDs of the blockchains a Subnet validates.
         *
         * @param subnetID Either a {@link https://github.com/feross/buffer|Buffer} or an AVAX
         * serialized string for the SubnetID or its alias.
         *
         * @returns Promise for an array of blockchainIDs the subnet validates.
         */
        this.validates = (subnetID) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                subnetID,
            };
            if (typeof subnetID === 'string') {
                params.subnetID = subnetID;
            }
            else if (typeof subnetID !== 'undefined') {
                params.subnetID = bintools.cb58Encode(subnetID);
            }
            return this.callMethod('platform.validates', params)
                .then((response) => response.data.result.blockchainIDs);
        });
        /**
         * Get all the blockchains that exist (excluding the P-Chain).
         *
         * @returns Promise for an array of objects containing fields "id", "subnetID", and "vmID".
         */
        this.getBlockchains = () => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            return this.callMethod('platform.getBlockchains', params)
                .then((response) => response.data.result.blockchains);
        });
        /**
         * Send AVAX from an account on the P-Chain to an address on the X-Chain. This transaction
         * must be signed with the key of the account that the AVAX is sent from and which pays the
         * transaction fee. After issuing this transaction, you must call the X-Chainâ€™s importAVAX
         * method to complete the transfer.
         *
         * @param to The address on the X-Chain to send the AVAX to. Do not include X- in the address
         * @param amount Amount of AVAX to export as a {@link https://github.com/indutny/bn.js/|BN}
         * @param payerNonce The next unused nonce of the account paying the tx fee and providing
         * the sent AVAX
         *
         * @returns Promise for an unsigned transaction to be signed by the account the the AVAX is
         * sent from and pays the transaction fee.
         */
        this.exportAVAX = (amount, to, payerNonce) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                to,
                amount: amount.toString(10),
                payerNonce,
            };
            return this.callMethod('platform.exportAVAX', params)
                .then((response) => response.data.result.unsignedTx);
        });
        /**
         * Send AVAX from an account on the P-Chain to an address on the X-Chain. This transaction
         * must be signed with the key of the account that the AVAX is sent from and which pays
         * the transaction fee. After issuing this transaction, you must call the X-Chainâ€™s
         * importAVAX method to complete the transfer.
         *
         * @param username The Keystore user that controls the account specified in `to`
         * @param password The password of the Keystore user
         * @param to The ID of the account the AVAX is sent to. This must be the same as the to
         * argument in the corresponding call to the X-Chainâ€™s exportAVAX
         * @param payerNonce The next unused nonce of the account specified in `to`
         *
         * @returns Promise for a string for the transaction, which should be sent to the network
         * by calling issueTx.
         */
        this.importAVAX = (username, password, to, payerNonce) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                to,
                payerNonce,
                username,
                password,
            };
            return this.callMethod('platform.importAVAX', params)
                .then((response) => response.data.result.tx);
        });
        /**
         * Sign an unsigned or partially signed transaction.
         *
         * Transactions to add non-default Subnets require signatures from control keys and
         * from the account paying the transaction fee. If `signer` is a control key and the
         * transaction needs more signatures from control keys, `sign` will provide a control
         * signature. Otherwise, `signer` will sign to pay the transaction fee.
         *
         * @param username The Keystore user that controls the key signing `tx`
         * @param password The password of the Keystore user
         * @param tx The unsigned/partially signed transaction
         * @param signer The address of the key signing `tx`
         *
         * @returns Promise for an string of the transaction after being signed.
         */
        this.sign = (username, password, tx, signer) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                tx,
                signer,
                username,
                password,
            };
            return this.callMethod('platform.sign', params)
                .then((response) => response.data.result.tx);
        });
        /**
         * Issue a transaction to the Platform Chain.
         *
         * @param tx The base 58 (with checksum) representation of a transaction
         *
         * @returns Promise for an string of the transaction after being signed.
         */
        this.issueTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                tx,
            };
            return this.callMethod('platform.issueTx', params)
                .then((response) => response.data.result.txID);
        });
        /**
         * Get all the subnets that exist.
         *
         * @returns Promise for an array of objects containing fields "id",
         * "controlKeys", and "threshold".
         */
        this.getSubnets = () => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            return this.callMethod('platform.getSubnets', params)
                .then((response) => response.data.result.subnets);
        });
        /**
         * Exports the private key for an address.
         *
         * @param username The name of the user with the private key
         * @param password The password used to decrypt the private key
         * @param address The address whose private key should be exported
         *
         * @returns Promise with the decrypted private key as store in the database
         */
        this.exportKey = (username, password, address) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
                address,
            };
            return this.callMethod('platform.exportKey', params)
                .then((response) => response.data.result.privateKey);
        });
        /**
         * Give a user control over an address by providing the private key that controls the address.
         *
         * @param username The name of the user to store the private key
         * @param password The password that unlocks the user
         * @param privateKey A string representing the private key in the vm's format
         *
         * @returns The address for the imported private key.
         */
        this.importKey = (username, password, privateKey) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
                privateKey,
            };
            return this.callMethod('platform.importKey', params)
                .then((response) => response.data.result.address);
        });
    }
}
exports.default = PlatformVMAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvcGxhdGZvcm12bS9hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFPQSw2Q0FBaUU7QUFDakUsb0VBQTRDO0FBRTVDOztHQUVHO0FBQ0gsTUFBTSxRQUFRLEdBQVksa0JBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUVqRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLGFBQWMsU0FBUSxlQUFPO0lBbWZqQzs7Ozs7O09BTUc7SUFDSCxZQUFZLElBQWtCLEVBQUUsVUFBaUIsUUFBUTtRQUFJLEtBQUssQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUF6ZmxGOzs7Ozs7Ozs7O1dBVUc7UUFDSCxxQkFBZ0IsR0FBRyxDQUFPLElBQVcsRUFDbkMsSUFBVyxFQUNYLFVBQWtCLEVBQ2xCLE9BQWMsRUFDZCxXQUEyQixTQUFTLEVBQ3JCLEVBQUU7WUFDakIsTUFBTSxNQUFNLEdBQU87Z0JBQ2pCLElBQUk7Z0JBQ0osSUFBSTtnQkFDSixVQUFVO2dCQUNWLFdBQVcsRUFBRSxPQUFPO2FBQ3JCLENBQUM7WUFDRixJQUFJLE9BQU8sUUFBUSxLQUFLLFFBQVEsRUFBRTtnQkFDaEMsTUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7YUFDNUI7aUJBQU0sSUFBSSxPQUFPLFFBQVEsS0FBSyxXQUFXLEVBQUU7Z0JBQzFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNqRDtZQUNELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQywyQkFBMkIsRUFBRSxNQUFNLENBQUM7aUJBQ3hELElBQUksQ0FBQyxDQUFDLFFBQTRCLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQy9FLENBQUMsQ0FBQSxDQUFDO1FBRUY7Ozs7OztXQU1H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QWMsRUFBa0IsRUFBRTtZQUNyRixNQUFNLE1BQU0sR0FBTztnQkFDakIsUUFBUTtnQkFDUixRQUFRO2dCQUNSLE9BQU87YUFDUixDQUFDO1lBQ0YsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLG9CQUFvQixFQUFFLE1BQU0sQ0FBQztpQkFDakQsSUFBSSxDQUFDLENBQUMsUUFBNEIsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0UsQ0FBQyxDQUFBLENBQUM7UUFFRjs7Ozs7Ozs7V0FRRztRQUNILGNBQVMsR0FBRyxDQUFPLFFBQWUsRUFBRSxRQUFlLEVBQUUsVUFBaUIsRUFBa0IsRUFBRTtZQUN4RixNQUFNLE1BQU0sR0FBTztnQkFDakIsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFVBQVU7YUFDWCxDQUFDO1lBQ0YsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLG9CQUFvQixFQUFFLE1BQU0sQ0FBQztpQkFDakQsSUFBSSxDQUFDLENBQUMsUUFBNEIsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUUsQ0FBQyxDQUFBLENBQUM7SUFTaUYsQ0FBQztDQUNyRjtBQUVELGtCQUFlLGFBQWEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFBsYXRmb3JtVk1BUElcbiAqL1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyLyc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IEF2YWxhbmNoZUNvcmUgZnJvbSAnLi4vLi4vYXZhbGFuY2hlJztcbmltcG9ydCB7IEpSUENBUEksIFJlcXVlc3RSZXNwb25zZURhdGEgfSBmcm9tICcuLi8uLi91dGlscy90eXBlcyc7XG5pbXBvcnQgQmluVG9vbHMgZnJvbSAnLi4vLi4vdXRpbHMvYmludG9vbHMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHM6QmluVG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuXG4vKipcbiAqIENsYXNzIGZvciBpbnRlcmFjdGluZyB3aXRoIGEgbm9kZSdzIFBsYXRmb3JtVk1BUElcbiAqXG4gKiBAY2F0ZWdvcnkgUlBDQVBJc1xuICpcbiAqIEByZW1hcmtzIFRoaXMgZXh0ZW5kcyB0aGUgW1tKUlBDQVBJXV0gY2xhc3MuIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBkaXJlY3RseSBjYWxsZWQuIEluc3RlYWQsIHVzZSB0aGUgW1tBdmFsYW5jaGUuYWRkQVBJXV0gZnVuY3Rpb24gdG8gcmVnaXN0ZXIgdGhpcyBpbnRlcmZhY2Ugd2l0aCBBdmFsYW5jaGUuXG4gKi9cbmNsYXNzIFBsYXRmb3JtVk1BUEkgZXh0ZW5kcyBKUlBDQVBJIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYmxvY2tjaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHZtSUQgVGhlIElEIG9mIHRoZSBWaXJ0dWFsIE1hY2hpbmUgdGhlIGJsb2NrY2hhaW4gcnVucy4gQ2FuIGFsc28gYmUgYW4gYWxpYXMgb2YgdGhlIFZpcnR1YWwgTWFjaGluZS5cbiAgICogQHBhcmFtIG5hbWUgQSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgbmV3IGJsb2NrY2hhaW5cbiAgICogQHBhcmFtIHBheWVyTm9uY2UgVGhlIG5leHQgdW51c2VkIG5vbmNlIG9mIHRoZSBhY2NvdW50IHBheWluZyB0aGUgdHJhbnNhY3Rpb24gZmVlXG4gICAqIEBwYXJhbSBnZW5lc2lzIFRoZSBiYXNlIDU4ICh3aXRoIGNoZWNrc3VtKSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2VuZXNpcyBzdGF0ZSBvZiB0aGUgbmV3IGJsb2NrY2hhaW4uIFZpcnR1YWwgTWFjaGluZXMgc2hvdWxkIGhhdmUgYSBzdGF0aWMgQVBJIG1ldGhvZCBuYW1lZCBidWlsZEdlbmVzaXMgdGhhdCBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBnZW5lc2lzRGF0YS5cbiAgICogQHBhcmFtIHN1Ym5ldElEIE9wdGlvbmFsLiBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhbiBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIGZvciB0aGUgU3VibmV0SUQgb3IgaXRzIGFsaWFzLlxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gdG8gY3JlYXRlIHRoaXMgYmxvY2tjaGFpbi4gTXVzdCBiZSBzaWduZWQgYnkgYSBzdWZmaWNpZW50IG51bWJlciBvZiB0aGUgU3VibmV04oCZcyBjb250cm9sIGtleXMgYW5kIGJ5IHRoZSBhY2NvdW50IHBheWluZyB0aGUgdHJhbnNhY3Rpb24gZmVlLlxuICAgKi9cbiAgY3JlYXRlQmxvY2tjaGFpbiA9IGFzeW5jICh2bUlEOnN0cmluZyxcbiAgICBuYW1lOnN0cmluZyxcbiAgICBwYXllck5vbmNlOiBudW1iZXIsXG4gICAgZ2VuZXNpczpzdHJpbmcsXG4gICAgc3VibmV0SUQ6QnVmZmVyIHwgc3RyaW5nID0gdW5kZWZpbmVkKVxuICA6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdm1JRCxcbiAgICAgIG5hbWUsXG4gICAgICBwYXllck5vbmNlLFxuICAgICAgZ2VuZXNpc0RhdGE6IGdlbmVzaXMsXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHN1Ym5ldElEID09PSAnc3RyaW5nJykge1xuICAgICAgcGFyYW1zLnN1Ym5ldElEID0gc3VibmV0SUQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3VibmV0SUQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJhbXMuc3VibmV0SUQgPSBiaW50b29scy5jYjU4RW5jb2RlKHN1Ym5ldElEKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uY3JlYXRlQmxvY2tjaGFpbicsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5ibG9ja2NoYWluSUQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGJsb2NrY2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSBibG9ja2NoYWluSUQgVGhlIGJsb2NrY2hhaW5JRCByZXF1ZXN0aW5nIGEgc3RhdHVzIHVwZGF0ZVxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhIHN0cmluZyBvZiBvbmUgb2Y6IFwiVmFsaWRhdGluZ1wiLCBcIkNyZWF0ZWRcIiwgXCJQcmVmZXJyZWRcIiwgXCJVbmtub3duXCIuXG4gICAqL1xuICBnZXRCbG9ja2NoYWluU3RhdHVzID0gYXN5bmMgKGJsb2NrY2hhaW5JRDogc3RyaW5nKTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdwbGF0Zm9ybS5nZXRCbG9ja2NoYWluU3RhdHVzJywgcGFyYW1zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LnN0YXR1cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBQLUNoYWluIHVzZXMgYW4gYWNjb3VudCBtb2RlbC4gVGhpcyBtZXRob2QgY3JlYXRlcyBhIFAtQ2hhaW4gYWNjb3VudCBvbiBhbiBleGlzdGluZyB1c2VyIGluIHRoZSBLZXlzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIFRoZSB1c2VybmFtZSBvZiB0aGUgS2V5c3RvcmUgdXNlciB0aGF0IGNvbnRyb2xzIHRoZSBuZXcgYWNjb3VudFxuICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIG9mIHRoZSBLZXlzdG9yZSB1c2VyIHRoYXQgY29udHJvbHMgdGhlIG5ldyBhY2NvdW50XG4gICAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBwcml2YXRlIGtleSB0aGF0IGNvbnRyb2xzIHRoZSBhY2NvdW50LiBJZiBvbWl0dGVkLCBhIG5ldyBwcml2YXRlIGtleSBpcyBnZW5lcmF0ZWRcbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSBmb3IgYSBzdHJpbmcgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudCBhZGRyZXNzLlxuICAgKi9cbiAgY3JlYXRlQWNjb3VudCA9IGFzeW5jICh1c2VybmFtZTogc3RyaW5nLFxuICAgIHBhc3N3b3JkOnN0cmluZyxcbiAgICBwcml2YXRlS2V5OkJ1ZmZlciB8IHN0cmluZyA9IHVuZGVmaW5lZClcbiAgOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJhbXMucHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJpdmF0ZUtleSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhcmFtcy5wcml2YXRlS2V5ID0gYmludG9vbHMuY2I1OEVuY29kZShwcml2YXRlS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uY3JlYXRlQWNjb3VudCcsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5hZGRyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIFAtQ2hhaW4gdXNlcyBhbiBhY2NvdW50IG1vZGVsLiBBbiBhY2NvdW50IGlzIGlkZW50aWZpZWQgYnkgYW4gYWRkcmVzcy4gVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYWRkcmVzcywgdGhlIG5vbmNlLCBhbmQgdGhlIGJhbGFuY2UuXG4gICAqL1xuICBnZXRBY2NvdW50ID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6UHJvbWlzZTxvYmplY3Q+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgYWRkcmVzcyxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLmdldEFjY291bnQnLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSBhY2NvdW50cyBjb250cm9sbGVkIGJ5IHRoZSB1c2VyIGluIHRoZSBLZXlzdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIFRoZSB1c2VybmFtZSBvZiB0aGUgS2V5c3RvcmUgdXNlclxuICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIG9mIHRoZSBLZXlzdG9yZSB1c2VyXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgZm9yIGFuIGFycmF5IG9mIGFjY291bnRzLlxuICAgKi9cbiAgbGlzdEFjY291bnRzID0gYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOnN0cmluZyk6UHJvbWlzZTxBcnJheTxvYmplY3Q+PiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdwbGF0Zm9ybS5saXN0QWNjb3VudHMnLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQuYWNjb3VudHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgc2V0IG9mIGN1cnJlbnQgdmFsaWRhdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHN1Ym5ldElEIE9wdGlvbmFsLiBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhblxuICAgKiBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIGZvciB0aGUgU3VibmV0SUQgb3IgaXRzIGFsaWFzLlxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBhcnJheSBvZiB2YWxpZGF0b3JzIHRoYXQgYXJlIGN1cnJlbnRseSBzdGFraW5nLCBzZWU6IHtAbGluayBodHRwczovL2RvY3MuYXZheC5uZXR3b3JrL3YxLjAvZW4vYXBpL3BsYXRmb3JtLyNwbGF0Zm9ybWdldGN1cnJlbnR2YWxpZGF0b3JzfHBsYXRmb3JtLmdldEN1cnJlbnRWYWxpZGF0b3JzIGRvY3VtZW50YXRpb259LlxuICAgKlxuICAgKi9cbiAgZ2V0Q3VycmVudFZhbGlkYXRvcnMgPSBhc3luYyAoc3VibmV0SUQ6QnVmZmVyIHwgc3RyaW5nID0gdW5kZWZpbmVkKTpQcm9taXNlPEFycmF5PG9iamVjdD4+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge307XG4gICAgaWYgKHR5cGVvZiBzdWJuZXRJRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcy5zdWJuZXRJRCA9IHN1Ym5ldElEO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Ym5ldElEICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyYW1zLnN1Ym5ldElEID0gYmludG9vbHMuY2I1OEVuY29kZShzdWJuZXRJRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLmdldEN1cnJlbnRWYWxpZGF0b3JzJywgcGFyYW1zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LnZhbGlkYXRvcnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0cyB0aGUgc2V0IG9mIHBlbmRpbmcgdmFsaWRhdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHN1Ym5ldElEIE9wdGlvbmFsLiBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgKiBvciBhIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgZm9yIHRoZSBTdWJuZXRJRCBvciBpdHMgYWxpYXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgZm9yIGFuIGFycmF5IG9mIHZhbGlkYXRvcnMgdGhhdCBhcmUgcGVuZGluZyBzdGFraW5nLCBzZWU6IHtAbGluayBodHRwczovL2RvY3MuYXZheC5uZXR3b3JrL3YxLjAvZW4vYXBpL3BsYXRmb3JtLyNwbGF0Zm9ybWdldHBlbmRpbmd2YWxpZGF0b3JzfHBsYXRmb3JtLmdldFBlbmRpbmdWYWxpZGF0b3JzIGRvY3VtZW50YXRpb259LlxuICAgKlxuICAgKi9cbiAgZ2V0UGVuZGluZ1ZhbGlkYXRvcnMgPSBhc3luYyAoc3VibmV0SUQ6QnVmZmVyIHwgc3RyaW5nID0gdW5kZWZpbmVkKTpQcm9taXNlPEFycmF5PG9iamVjdD4+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge307XG4gICAgaWYgKHR5cGVvZiBzdWJuZXRJRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcy5zdWJuZXRJRCA9IHN1Ym5ldElEO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Ym5ldElEICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyYW1zLnN1Ym5ldElEID0gYmludG9vbHMuY2I1OEVuY29kZShzdWJuZXRJRCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uZ2V0UGVuZGluZ1ZhbGlkYXRvcnMnLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudmFsaWRhdG9ycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNhbXBsZXMgYFNpemVgIHZhbGlkYXRvcnMgZnJvbSB0aGUgY3VycmVudCB2YWxpZGF0b3Igc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gc2FtcGxlU2l6ZSBPZiB0aGUgdG90YWwgdW5pdmVyc2Ugb2YgdmFsaWRhdG9ycywgc2VsZWN0IHRoaXMgbWFueSBhdCByYW5kb21cbiAgICogQHBhcmFtIHN1Ym5ldElEIE9wdGlvbmFsLiBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhblxuICAgKiBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIGZvciB0aGUgU3VibmV0SUQgb3IgaXRzIGFsaWFzLlxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBhcnJheSBvZiB2YWxpZGF0b3IncyBzdGFraW5nSURzLlxuICAgKi9cbiAgc2FtcGxlVmFsaWRhdG9ycyA9IGFzeW5jIChzYW1wbGVTaXplOm51bWJlcixcbiAgICBzdWJuZXRJRDpCdWZmZXIgfCBzdHJpbmcgPSB1bmRlZmluZWQpXG4gIDpQcm9taXNlPEFycmF5PHN0cmluZz4+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgc2l6ZTogc2FtcGxlU2l6ZS50b1N0cmluZygpLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBzdWJuZXRJRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcy5zdWJuZXRJRCA9IHN1Ym5ldElEO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Ym5ldElEICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyYW1zLnN1Ym5ldElEID0gYmludG9vbHMuY2I1OEVuY29kZShzdWJuZXRJRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLnNhbXBsZVZhbGlkYXRvcnMnLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudmFsaWRhdG9ycyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHZhbGlkYXRvciB0byB0aGUgRGVmYXVsdCBTdWJuZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgbm9kZSBJRCBvZiB0aGUgdmFsaWRhdG9yXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgSmF2YXNjcmlwdCBEYXRlIG9iamVjdCBmb3IgdGhlIHN0YXJ0IHRpbWUgdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIGVuZFRpbWUgSmF2YXNjcmlwdCBEYXRlIG9iamVjdCBmb3IgdGhlIGVuZCB0aW1lIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBzdGFrZUFtb3VudCBUaGUgYW1vdW50IG9mIG5BVkFYIHRoZSB2YWxpZGF0b3IgaXMgc3Rha2luZyBhc1xuICAgKiBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAqIEBwYXJhbSBwYXllck5vbmNlIFRoZSBuZXh0IHVudXNlZCBub25jZSBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIHByb3ZpZGluZyB0aGUgc3Rha2VkXG4gICAqIEFWQVggYW5kIHBheWluZyB0aGUgdHJhbnNhY3Rpb24gZmVlXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBUaGUgUC1DaGFpbiBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgdGhlIHN0YWtlZCBBVkFYIHdpbGwgYmUgcmV0dXJuZWRcbiAgICogdG8sIGFzIHdlbGwgYXMgYSB2YWxpZGF0aW9uIHJld2FyZCBpZiB0aGUgdmFsaWRhdG9yIGlzIHN1ZmZpY2llbnRseSByZXNwb25zaXZlIGFuZCBjb3JyZWN0XG4gICAqIHdoaWxlIGl0IHZhbGlkYXRlZFxuICAgKiBAcGFyYW0gZGVsZWdhdGlvbkZlZVJhdGUgT3B0aW9uYWwuIFRoZSBwZXJjZW50IGZlZSB0aGlzIHZhbGlkYXRvciBjaGFyZ2VzIHdoZW4gb3RoZXJzXG4gICAqIGRlbGVnYXRlIHN0YWtlIHRvIHRoZW0sIG11bHRpcGxpZWQgYnkgMTAsMDAwIGFzXG4gICAqIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0uIEZvciBleGFtcGxlLCBzdXBwb3NlIGEgdmFsaWRhdG9yIGhhc1xuICAgKiBkZWxlZ2F0aW9uRmVlUmF0ZSAzMDAsMDAwIGFuZCBzb21lb25lIGRlbGVnYXRlcyB0byB0aGF0IHZhbGlkYXRvci4gV2hlbiB0aGUgZGVsZWdhdGlvblxuICAgKiBwZXJpb2QgaXMgb3ZlciwgaWYgdGhlIGRlbGVnYXRvciBpcyBlbnRpdGxlZCB0byBhIHJld2FyZCwgMzAlIG9mIHRoZSByZXdhcmRcbiAgICogKDMwMCwwMDAgLyAxMCwwMDApIGdvZXMgdG8gdGhlIHZhbGlkYXRvciBhbmQgNzAlIGdvZXMgdG8gdGhlIGRlbGVnYXRvclxuICAgKiBAcGFyYW0gc3VibmV0SUQgT3B0aW9uYWwuIEVpdGhlciBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9yXG4gICAqIGFuIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgZm9yIHRoZSBTdWJuZXRJRCBvciBpdHMgYWxpYXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgZm9yIGEgYmFzZTU4IHN0cmluZyBvZiB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBhZGREZWZhdWx0U3VibmV0VmFsaWRhdG9yID0gYXN5bmMgKGlkOnN0cmluZyxcbiAgICBzdGFydFRpbWU6RGF0ZSxcbiAgICBlbmRUaW1lOkRhdGUsXG4gICAgc3Rha2VBbW91bnQ6Qk4sXG4gICAgcGF5ZXJOb25jZTpudW1iZXIsXG4gICAgZGVzdGluYXRpb246c3RyaW5nLFxuICAgIGRlbGVnYXRpb25GZWVSYXRlOkJOID0gdW5kZWZpbmVkKVxuICA6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgaWQsXG4gICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZS5nZXRUaW1lKCkgLyAxMDAwLFxuICAgICAgZW5kVGltZTogZW5kVGltZS5nZXRUaW1lKCkgLyAxMDAwLFxuICAgICAgc3Rha2VBbW91bnQ6IHN0YWtlQW1vdW50LnRvU3RyaW5nKDEwKSxcbiAgICAgIHBheWVyTm9uY2U6IE1hdGguZmxvb3IocGF5ZXJOb25jZSksXG4gICAgICBkZXN0aW5hdGlvbixcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgZGVsZWdhdGlvbkZlZVJhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJhbXMuZGVsZWdhdGlvbkZlZVJhdGUgPSBkZWxlZ2F0aW9uRmVlUmF0ZS50b1N0cmluZygxMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLmFkZERlZmF1bHRTdWJuZXRWYWxpZGF0b3InLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudW5zaWduZWRUeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHZhbGlkYXRvciB0byBhIFN1Ym5ldCBvdGhlciB0aGFuIHRoZSBEZWZhdWx0IFN1Ym5ldC4gVGhlIHZhbGlkYXRvciBtdXN0IHZhbGlkYXRlIHRoZSBEZWZhdWx0IFN1Ym5ldCBmb3IgdGhlIGVudGlyZSBkdXJhdGlvbiB0aGV5IHZhbGlkYXRlIHRoaXMgU3VibmV0LlxuICAgKlxuICAgKiBAcGFyYW0gaWQgVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvclxuICAgKiBAcGFyYW0gc3VibmV0SUQgRWl0aGVyIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb3IgYSBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIGZvciB0aGUgU3VibmV0SUQgb3IgaXRzIGFsaWFzLlxuICAgKiBAcGFyYW0gc3RhcnRUaW1lIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QgZm9yIHRoZSBzdGFydCB0aW1lIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBlbmRUaW1lIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QgZm9yIHRoZSBlbmQgdGltZSB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gd2VpZ2h0IFRoZSB2YWxpZGF0b3LigJlzIHdlaWdodCB1c2VkIGZvciBzYW1wbGluZ1xuICAgKiBAcGFyYW0gcGF5ZXJOb25jZSBUaGUgbmV4dCB1bnVzZWQgbm9uY2Ugb2YgdGhlIGFjY291bnQgdGhhdCBpcyBwcm92aWRpbmcgdGhlIHN0YWtlZCBBVkFYIGFuZCBwYXlpbmcgdGhlIHRyYW5zYWN0aW9uIGZlZVxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24uIEl0IG11c3QgYmUgc2lnbmVkICh1c2luZyBzaWduKSBieSB0aGUgcHJvcGVyIG51bWJlciBvZiB0aGUgU3VibmV04oCZcyBjb250cm9sIGtleXMgYW5kIGJ5IHRoZSBrZXkgb2YgdGhlIGFjY291bnQgcGF5aW5nIHRoZSB0cmFuc2FjdGlvbiBmZWUgYmVmb3JlIGl0IGNhbiBiZSBpc3N1ZWQuXG4gICAqL1xuICBhZGROb25EZWZhdWx0U3VibmV0VmFsaWRhdG9yID0gYXN5bmMgKGlkOnN0cmluZyxcbiAgICBzdWJuZXRJRDpCdWZmZXIgfCBzdHJpbmcsXG4gICAgc3RhcnRUaW1lOkRhdGUsXG4gICAgZW5kVGltZTpEYXRlLFxuICAgIHdlaWdodDpudW1iZXIsXG4gICAgcGF5ZXJOb25jZTpudW1iZXIpXG4gIDpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBpZCxcbiAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLmdldFRpbWUoKSAvIDEwMDAsXG4gICAgICBlbmRUaW1lOiBlbmRUaW1lLmdldFRpbWUoKSAvIDEwMDAsXG4gICAgICB3ZWlnaHQsXG4gICAgICBwYXllck5vbmNlOiBNYXRoLmZsb29yKHBheWVyTm9uY2UpLFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBzdWJuZXRJRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcy5zdWJuZXRJRCA9IHN1Ym5ldElEO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Ym5ldElEICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyYW1zLnN1Ym5ldElEID0gYmludG9vbHMuY2I1OEVuY29kZShzdWJuZXRJRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLmFkZE5vbkRlZmF1bHRTdWJuZXRWYWxpZGF0b3InLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudW5zaWduZWRUeCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGRlbGVnYXRvciB0byB0aGUgRGVmYXVsdCBTdWJuZXQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCBUaGUgbm9kZSBJRCBvZiB0aGUgZGVsZWdhdGVlXG4gICAqIEBwYXJhbSBzdGFydFRpbWUgSmF2YXNjcmlwdCBEYXRlIG9iamVjdCBmb3Igd2hlbiB0aGUgZGVsZWdhdG9yIHN0YXJ0cyBkZWxlZ2F0aW5nXG4gICAqIEBwYXJhbSBlbmRUaW1lIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QgZm9yIHdoZW4gdGhlIGRlbGVnYXRvciBzdGFydHMgZGVsZWdhdGluZ1xuICAgKiBAcGFyYW0gc3Rha2VBbW91bnQgVGhlIGFtb3VudCBvZiBuQVZBWCB0aGUgZGVsZWdhdG9yIGlzIHN0YWtpbmcgYXNcbiAgICogYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gcGF5ZXJOb25jZSBUaGUgbmV4dCB1bnVzZWQgbm9uY2Ugb2YgdGhlIGFjY291bnQgdGhhdCB3aWxsIHByb3ZpZGUgdGhlIHN0YWtlZFxuICAgKiBBVkFYIGFuZCBwYXkgdGhlIHRyYW5zYWN0aW9uIGZlZVxuICAgKiBAcGFyYW0gZGVzdGluYXRpb24gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhlIHN0YWtlZCBBVkFYIGFuZCB2YWxpZGF0aW9uIHJld2FyZFxuICAgKiAoaWYgYXBwbGljYWJsZSkgYXJlIHNlbnQgdG8gYXQgZW5kVGltZVxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBhcnJheSBvZiB2YWxpZGF0b3IncyBzdGFraW5nSURzLlxuICAgKi9cbiAgYWRkRGVmYXVsdFN1Ym5ldERlbGVnYXRvciA9IGFzeW5jIChpZDpzdHJpbmcsXG4gICAgc3RhcnRUaW1lOkRhdGUsXG4gICAgZW5kVGltZTpEYXRlLFxuICAgIHN0YWtlQW1vdW50OkJOLFxuICAgIHBheWVyTm9uY2U6bnVtYmVyLFxuICAgIGRlc3RpbmF0aW9uOnN0cmluZylcbiAgOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIGlkLFxuICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUuZ2V0VGltZSgpIC8gMTAwMCxcbiAgICAgIGVuZFRpbWU6IGVuZFRpbWUuZ2V0VGltZSgpIC8gMTAwMCxcbiAgICAgIHN0YWtlQW1vdW50OiBzdGFrZUFtb3VudC50b1N0cmluZygxMCksXG4gICAgICBwYXllck5vbmNlOiBNYXRoLmZsb29yKHBheWVyTm9uY2UpLFxuICAgICAgZGVzdGluYXRpb24sXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdwbGF0Zm9ybS5hZGREZWZhdWx0U3VibmV0RGVsZWdhdG9yJywgcGFyYW1zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LnVuc2lnbmVkVHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gdG8gY3JlYXRlIGEgbmV3IFN1Ym5ldC4gVGhlIHVuc2lnbmVkIHRyYW5zYWN0aW9uIG11c3QgYmVcbiAgICogc2lnbmVkIHdpdGggdGhlIGtleSBvZiB0aGUgYWNjb3VudCBwYXlpbmcgdGhlIHRyYW5zYWN0aW9uIGZlZS4gVGhlIFN1Ym5ldOKAmXMgSUQgaXMgdGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgaXQgKGllIHRoZSByZXNwb25zZSBmcm9tIGlzc3VlVHggd2hlbiBpc3N1aW5nIHRoZSBzaWduZWQgdHJhbnNhY3Rpb24pLlxuICAgKlxuICAgKiBAcGFyYW0gY29udHJvbEtleXMgQXJyYXkgb2YgcGxhdGZvcm0gYWRkcmVzc2VzIGFzIHN0cmluZ3NcbiAgICogQHBhcmFtIHRocmVzaG9sZCBUbyBhZGQgYSB2YWxpZGF0b3IgdG8gdGhpcyBTdWJuZXQsIGEgdHJhbnNhY3Rpb24gbXVzdCBoYXZlIHRocmVzaG9sZFxuICAgKiBzaWduYXR1cmVzLCB3aGVyZSBlYWNoIHNpZ25hdHVyZSBpcyBmcm9tIGEga2V5IHdob3NlIGFkZHJlc3MgaXMgYW4gZWxlbWVudCBvZiBgY29udHJvbEtleXNgXG4gICAqIEBwYXJhbSBwYXllck5vbmNlIFRoZSBuZXh0IHVudXNlZCBub25jZSBvZiB0aGUgYWNjb3VudCBwcm92aWRpbmcgdGhlIHRyYW5zYWN0aW9uIGZlZVxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhIHN0cmluZyB3aXRoIHRoZSB1bnNpZ25lZCB0cmFuc2FjdGlvbiBlbmNvZGVkIGFzIGJhc2U1OC5cbiAgICovXG4gIGNyZWF0ZVN1Ym5ldCA9IGFzeW5jIChjb250cm9sS2V5czpBcnJheTxzdHJpbmc+LCB0aHJlc2hvbGQ6bnVtYmVyLCBwYXllck5vbmNlOm51bWJlcilcbiAgOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIGNvbnRyb2xLZXlzLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgcGF5ZXJOb25jZSxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLmNyZWF0ZVN1Ym5ldCcsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC51bnNpZ25lZFR4KTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSBTdWJuZXQgdGhhdCB2YWxpZGF0ZXMgYSBnaXZlbiBibG9ja2NoYWluLlxuICAgKlxuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEVpdGhlciBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9yIGEgY2I1OCBcbiAgICogZW5jb2RlZCBzdHJpbmcgZm9yIHRoZSBibG9ja2NoYWluSUQgb3IgaXRzIGFsaWFzLlxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhIHN0cmluZyBvZiB0aGUgc3VibmV0SUQgdGhhdCB2YWxpZGF0ZXMgdGhlIGJsb2NrY2hhaW4uXG4gICAqL1xuICB2YWxpZGF0ZWRCeSA9IGFzeW5jIChibG9ja2NoYWluSUQ6c3RyaW5nKTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBibG9ja2NoYWluSUQsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdwbGF0Zm9ybS52YWxpZGF0ZWRCeScsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5zdWJuZXRJRCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSURzIG9mIHRoZSBibG9ja2NoYWlucyBhIFN1Ym5ldCB2YWxpZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBzdWJuZXRJRCBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhbiBBVkFYXG4gICAqIHNlcmlhbGl6ZWQgc3RyaW5nIGZvciB0aGUgU3VibmV0SUQgb3IgaXRzIGFsaWFzLlxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBhcnJheSBvZiBibG9ja2NoYWluSURzIHRoZSBzdWJuZXQgdmFsaWRhdGVzLlxuICAgKi9cbiAgdmFsaWRhdGVzID0gYXN5bmMgKHN1Ym5ldElEOkJ1ZmZlciB8IHN0cmluZyk6UHJvbWlzZTxBcnJheTxzdHJpbmc+PiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHN1Ym5ldElELFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBzdWJuZXRJRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcy5zdWJuZXRJRCA9IHN1Ym5ldElEO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1Ym5ldElEICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcGFyYW1zLnN1Ym5ldElEID0gYmludG9vbHMuY2I1OEVuY29kZShzdWJuZXRJRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLnZhbGlkYXRlcycsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5ibG9ja2NoYWluSURzKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYmxvY2tjaGFpbnMgdGhhdCBleGlzdCAoZXhjbHVkaW5nIHRoZSBQLUNoYWluKS5cbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSBmb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGZpZWxkcyBcImlkXCIsIFwic3VibmV0SURcIiwgYW5kIFwidm1JRFwiLlxuICAgKi9cbiAgZ2V0QmxvY2tjaGFpbnMgPSBhc3luYyAoKTpQcm9taXNlPEFycmF5PG9iamVjdD4+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge307XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uZ2V0QmxvY2tjaGFpbnMnLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQuYmxvY2tjaGFpbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kIEFWQVggZnJvbSBhbiBhY2NvdW50IG9uIHRoZSBQLUNoYWluIHRvIGFuIGFkZHJlc3Mgb24gdGhlIFgtQ2hhaW4uIFRoaXMgdHJhbnNhY3Rpb25cbiAgICogbXVzdCBiZSBzaWduZWQgd2l0aCB0aGUga2V5IG9mIHRoZSBhY2NvdW50IHRoYXQgdGhlIEFWQVggaXMgc2VudCBmcm9tIGFuZCB3aGljaCBwYXlzIHRoZVxuICAgKiB0cmFuc2FjdGlvbiBmZWUuIEFmdGVyIGlzc3VpbmcgdGhpcyB0cmFuc2FjdGlvbiwgeW91IG11c3QgY2FsbCB0aGUgWC1DaGFpbuKAmXMgaW1wb3J0QVZBWFxuICAgKiBtZXRob2QgdG8gY29tcGxldGUgdGhlIHRyYW5zZmVyLlxuICAgKlxuICAgKiBAcGFyYW0gdG8gVGhlIGFkZHJlc3Mgb24gdGhlIFgtQ2hhaW4gdG8gc2VuZCB0aGUgQVZBWCB0by4gRG8gbm90IGluY2x1ZGUgWC0gaW4gdGhlIGFkZHJlc3NcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgb2YgQVZBWCB0byBleHBvcnQgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgKiBAcGFyYW0gcGF5ZXJOb25jZSBUaGUgbmV4dCB1bnVzZWQgbm9uY2Ugb2YgdGhlIGFjY291bnQgcGF5aW5nIHRoZSB0eCBmZWUgYW5kIHByb3ZpZGluZ1xuICAgKiB0aGUgc2VudCBBVkFYXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgZm9yIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIHRvIGJlIHNpZ25lZCBieSB0aGUgYWNjb3VudCB0aGUgdGhlIEFWQVggaXNcbiAgICogc2VudCBmcm9tIGFuZCBwYXlzIHRoZSB0cmFuc2FjdGlvbiBmZWUuXG4gICAqL1xuICBleHBvcnRBVkFYID0gYXN5bmMgKGFtb3VudDpCTiwgdG86c3RyaW5nLCBwYXllck5vbmNlOm51bWJlcik6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdG8sXG4gICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygxMCksXG4gICAgICBwYXllck5vbmNlLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uZXhwb3J0QVZBWCcsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC51bnNpZ25lZFR4KTtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZCBBVkFYIGZyb20gYW4gYWNjb3VudCBvbiB0aGUgUC1DaGFpbiB0byBhbiBhZGRyZXNzIG9uIHRoZSBYLUNoYWluLiBUaGlzIHRyYW5zYWN0aW9uXG4gICAqIG11c3QgYmUgc2lnbmVkIHdpdGggdGhlIGtleSBvZiB0aGUgYWNjb3VudCB0aGF0IHRoZSBBVkFYIGlzIHNlbnQgZnJvbSBhbmQgd2hpY2ggcGF5c1xuICAgKiB0aGUgdHJhbnNhY3Rpb24gZmVlLiBBZnRlciBpc3N1aW5nIHRoaXMgdHJhbnNhY3Rpb24sIHlvdSBtdXN0IGNhbGwgdGhlIFgtQ2hhaW7igJlzXG4gICAqIGltcG9ydEFWQVggbWV0aG9kIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2Zlci5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIFRoZSBLZXlzdG9yZSB1c2VyIHRoYXQgY29udHJvbHMgdGhlIGFjY291bnQgc3BlY2lmaWVkIGluIGB0b2BcbiAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCBvZiB0aGUgS2V5c3RvcmUgdXNlclxuICAgKiBAcGFyYW0gdG8gVGhlIElEIG9mIHRoZSBhY2NvdW50IHRoZSBBVkFYIGlzIHNlbnQgdG8uIFRoaXMgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgdG9cbiAgICogYXJndW1lbnQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FsbCB0byB0aGUgWC1DaGFpbuKAmXMgZXhwb3J0QVZBWFxuICAgKiBAcGFyYW0gcGF5ZXJOb25jZSBUaGUgbmV4dCB1bnVzZWQgbm9uY2Ugb2YgdGhlIGFjY291bnQgc3BlY2lmaWVkIGluIGB0b2BcbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSBmb3IgYSBzdHJpbmcgZm9yIHRoZSB0cmFuc2FjdGlvbiwgd2hpY2ggc2hvdWxkIGJlIHNlbnQgdG8gdGhlIG5ldHdvcmtcbiAgICogYnkgY2FsbGluZyBpc3N1ZVR4LlxuICAgKi9cbiAgaW1wb3J0QVZBWCA9IGFzeW5jICh1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDpzdHJpbmcsIHRvOnN0cmluZywgcGF5ZXJOb25jZTpudW1iZXIpXG4gIDpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICB0byxcbiAgICAgIHBheWVyTm9uY2UsXG4gICAgICB1c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uaW1wb3J0QVZBWCcsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC50eCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNpZ24gYW4gdW5zaWduZWQgb3IgcGFydGlhbGx5IHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogVHJhbnNhY3Rpb25zIHRvIGFkZCBub24tZGVmYXVsdCBTdWJuZXRzIHJlcXVpcmUgc2lnbmF0dXJlcyBmcm9tIGNvbnRyb2wga2V5cyBhbmRcbiAgICogZnJvbSB0aGUgYWNjb3VudCBwYXlpbmcgdGhlIHRyYW5zYWN0aW9uIGZlZS4gSWYgYHNpZ25lcmAgaXMgYSBjb250cm9sIGtleSBhbmQgdGhlXG4gICAqIHRyYW5zYWN0aW9uIG5lZWRzIG1vcmUgc2lnbmF0dXJlcyBmcm9tIGNvbnRyb2wga2V5cywgYHNpZ25gIHdpbGwgcHJvdmlkZSBhIGNvbnRyb2xcbiAgICogc2lnbmF0dXJlLiBPdGhlcndpc2UsIGBzaWduZXJgIHdpbGwgc2lnbiB0byBwYXkgdGhlIHRyYW5zYWN0aW9uIGZlZS5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIFRoZSBLZXlzdG9yZSB1c2VyIHRoYXQgY29udHJvbHMgdGhlIGtleSBzaWduaW5nIGB0eGBcbiAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCBvZiB0aGUgS2V5c3RvcmUgdXNlclxuICAgKiBAcGFyYW0gdHggVGhlIHVuc2lnbmVkL3BhcnRpYWxseSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHNpZ25lciBUaGUgYWRkcmVzcyBvZiB0aGUga2V5IHNpZ25pbmcgYHR4YFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBzdHJpbmcgb2YgdGhlIHRyYW5zYWN0aW9uIGFmdGVyIGJlaW5nIHNpZ25lZC5cbiAgICovXG4gIHNpZ24gPSBhc3luYyAodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCB0eDpzdHJpbmcsIHNpZ25lcjpzdHJpbmcpOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHR4LFxuICAgICAgc2lnbmVyLFxuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ3BsYXRmb3JtLnNpZ24nLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudHgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJc3N1ZSBhIHRyYW5zYWN0aW9uIHRvIHRoZSBQbGF0Zm9ybSBDaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHR4IFRoZSBiYXNlIDU4ICh3aXRoIGNoZWNrc3VtKSByZXByZXNlbnRhdGlvbiBvZiBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgZm9yIGFuIHN0cmluZyBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXIgYmVpbmcgc2lnbmVkLlxuICAgKi9cbiAgaXNzdWVUeCA9IGFzeW5jICh0eDpzdHJpbmcpOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHR4LFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uaXNzdWVUeCcsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC50eElEKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgc3VibmV0cyB0aGF0IGV4aXN0LlxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlIGZvciBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgZmllbGRzIFwiaWRcIixcbiAgICogXCJjb250cm9sS2V5c1wiLCBhbmQgXCJ0aHJlc2hvbGRcIi5cbiAgICovXG4gIGdldFN1Ym5ldHMgPSBhc3luYyAoKTpQcm9taXNlPEFycmF5PG9iamVjdD4+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge307XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgncGxhdGZvcm0uZ2V0U3VibmV0cycsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5zdWJuZXRzKTtcbiAgfTtcblxuICAvKipcbiAgICogRXhwb3J0cyB0aGUgcHJpdmF0ZSBrZXkgZm9yIGFuIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB1c2VybmFtZSBUaGUgbmFtZSBvZiB0aGUgdXNlciB3aXRoIHRoZSBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHVzZWQgdG8gZGVjcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkgc2hvdWxkIGJlIGV4cG9ydGVkXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgZGVjcnlwdGVkIHByaXZhdGUga2V5IGFzIHN0b3JlIGluIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgZXhwb3J0S2V5ID0gYXN5bmMgKHVzZXJuYW1lOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCBhZGRyZXNzOnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGFkZHJlc3MsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdwbGF0Zm9ybS5leHBvcnRLZXknLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQucHJpdmF0ZUtleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdpdmUgYSB1c2VyIGNvbnRyb2wgb3ZlciBhbiBhZGRyZXNzIGJ5IHByb3ZpZGluZyB0aGUgcHJpdmF0ZSBrZXkgdGhhdCBjb250cm9scyB0aGUgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJuYW1lIFRoZSBuYW1lIG9mIHRoZSB1c2VyIHRvIHN0b3JlIHRoZSBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRoYXQgdW5sb2NrcyB0aGUgdXNlclxuICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHByaXZhdGUga2V5IGluIHRoZSB2bSdzIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgYWRkcmVzcyBmb3IgdGhlIGltcG9ydGVkIHByaXZhdGUga2V5LlxuICAgKi9cbiAgaW1wb3J0S2V5ID0gYXN5bmMgKHVzZXJuYW1lOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCBwcml2YXRlS2V5OnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHByaXZhdGVLZXksXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdwbGF0Zm9ybS5pbXBvcnRLZXknLCBwYXJhbXMpXG4gICAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQuYWRkcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgY2xhc3Mgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAqIEluc3RlYWQgdXNlIHRoZSBbW0F2YWxhbmNoZS5hZGRBUEldXSBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSBjb3JlIEEgcmVmZXJlbmNlIHRvIHRoZSBBdmFsYW5jaGUgY2xhc3NcbiAgICogQHBhcmFtIGJhc2V1cmwgRGVmYXVsdHMgdG8gdGhlIHN0cmluZyBcIi9leHQvUFwiIGFzIHRoZSBwYXRoIHRvIGJsb2NrY2hhaW4ncyBiYXNldXJsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb3JlOkF2YWxhbmNoZUNvcmUsIGJhc2V1cmw6c3RyaW5nID0gJy9leHQvUCcpIHsgc3VwZXIoY29yZSwgYmFzZXVybCk7IH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGxhdGZvcm1WTUFQSTtcbiJdfQ==