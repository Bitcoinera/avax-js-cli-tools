"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformVMKeyChain = exports.PlatformVMKeyPair = void 0;
/**
 * @packageDocumentation
 * @module PlatformVMAPI-KeyChain
 */
const buffer_1 = require("buffer/");
const elliptic = __importStar(require("elliptic"));
const create_hash_1 = __importDefault(require("create-hash"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("../../utils/types");
/**
 * @ignore
 */
const EC = elliptic.ec;
/**
 * @ignore
 */
const ec = new EC('secp256k1');
/**
 * @ignore
 */
const ecparams = ec.curve;
/**
 * @ignore
 */
const BN = ecparams.n.constructor;
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Class for representing a private and public keypair on the Platform Chain.
 */
class PlatformVMKeyPair extends types_1.KeyPair {
    /**
     * Class for representing a private and public keypair in Avalanche PlatformVM.
     */
    constructor(hrp, chainid, entropy = undefined) {
        super(hrp, chainid);
        /**
         * @ignore
         */
        this._sigFromSigBuffer = (sig) => {
            const r = new BN(bintools.copyFrom(sig, 0, 32));
            const s = new BN(bintools.copyFrom(sig, 32, 64));
            const recoveryParam = bintools.copyFrom(sig, 64, 65).readUIntBE(0, 1);
            const sigOpt = {
                r: r,
                s: s,
                recoveryParam: recoveryParam
            };
            return sigOpt;
        };
        /**
         * Generates a new keypair.
         *
         * @param entropy Optional parameter that may be necessary to produce secure keys
         */
        this.generateKey = (entropy) => {
            this.entropy = entropy;
            this.keypair = ec.genKeyPair();
            // doing hex translation to get Buffer class
            this.privk = buffer_1.Buffer.from(this.keypair.getPrivate("hex"), "hex");
            this.pubk = buffer_1.Buffer.from(this.keypair.getPublic(true, "hex"), "hex");
        };
        /**
         * Imports a private key and generates the appropriate public key.
         *
         * @param privk A {@link https://github.com/feross/buffer|Buffer} representing the private key
         *
         * @returns true on success, false on failure
         */
        this.importKey = (privk) => {
            this.keypair = ec.keyFromPrivate(privk.toString("hex"), "hex");
            // doing hex translation to get Buffer class
            this.privk = buffer_1.Buffer.from(this.keypair.getPrivate("hex"), "hex");
            this.pubk = buffer_1.Buffer.from(this.keypair.getPublic(true, "hex"), "hex");
            return true;
        };
        /**
         * Returns the address as a {@link https://github.com/feross/buffer|Buffer}.
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} representation of the address
         */
        this.getAddress = () => {
            return this.addressFromPublicKey(this.pubk);
        };
        /**
         * Returns the address's string representation.
         *
         * @returns A string representation of the address
         */
        this.getAddressString = () => {
            const addr = this.addressFromPublicKey(this.pubk);
            return bintools.addressToString(this.hrp, this.chainid, addr);
        };
        /**
         * Returns an address given a public key.
         *
         * @param pubk A {@link https://github.com/feross/buffer|Buffer} representing the public key
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} for the address of the public key.
         */
        this.addressFromPublicKey = (pubk) => {
            if (pubk.length == 65) {
                /* istanbul ignore next */
                pubk = buffer_1.Buffer.from(ec.keyFromPublic(pubk).getPublic(true, "hex"), "hex"); //make compact, stick back into buffer
            }
            if (pubk.length == 33) {
                const sha256 = buffer_1.Buffer.from(create_hash_1.default('sha256').update(pubk).digest());
                const ripesha = buffer_1.Buffer.from(create_hash_1.default('rmd160').update(sha256).digest());
                return ripesha;
            }
            /* istanbul ignore next */
            throw new Error("Unable to make address.");
        };
        /**
         * Returns a string representation of the private key.
         *
         * @returns A cb58 serialized string representation of the public key
         */
        this.getPrivateKeyString = () => {
            return "PrivateKey-" + bintools.cb58Encode(this.privk);
        };
        /**
         * Returns the public key.
         *
         * @returns A cb58 serialized string representation of the public key
         */
        this.getPublicKeyString = () => {
            return bintools.cb58Encode(this.pubk);
        };
        /**
         * Takes a message, signs it, and returns the signature.
         *
         * @param msg The message to sign, be sure to hash first if expected
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} containing the signature
         */
        this.sign = (msg) => {
            const sigObj = this.keypair.sign(msg, undefined, { canonical: true });
            const recovery = buffer_1.Buffer.alloc(1);
            recovery.writeUInt8(sigObj.recoveryParam, 0);
            const r = buffer_1.Buffer.from(sigObj.r.toArray("be", 32)); //we have to skip native Buffer class, so this is the way
            const s = buffer_1.Buffer.from(sigObj.s.toArray("be", 32)); //we have to skip native Buffer class, so this is the way
            const result = buffer_1.Buffer.concat([r, s, recovery], 65);
            return result;
        };
        /**
         * Verifies that the private key associated with the provided public key produces the signature associated with the given message.
         *
         * @param msg The message associated with the signature
         * @param sig The signature of the signed message
         *
         * @returns True on success, false on failure
         */
        this.verify = (msg, sig) => {
            const sigObj = this._sigFromSigBuffer(sig);
            return ec.verify(msg, sigObj, this.keypair);
        };
        /**
         * Recovers the public key of a message signer from a message and its associated signature.
         *
         * @param msg The message that's signed
         * @param sig The signature that's signed on the message
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public key of the signer
         */
        this.recover = (msg, sig) => {
            const sigObj = this._sigFromSigBuffer(sig);
            const pubk = ec.recoverPubKey(msg, sigObj, sigObj.recoveryParam);
            return buffer_1.Buffer.from(pubk.encodeCompressed());
        };
        this.generateKey();
    }
}
exports.PlatformVMKeyPair = PlatformVMKeyPair;
/**
 * Class for representing a key chain in Avalanche.
 *
 * @typeparam PlatformVMKeyPair Class extending [[KeyPair]] which is used as the key in [[PlatformVMKeyChain]]
 */
class PlatformVMKeyChain extends types_1.KeyChain {
    /**
     * Returns instance of PlatformVMKeyChain.
     */
    constructor(hrp, chainid) {
        super(hrp, chainid);
        /**
         * Makes a new key pair, returns the address.
         *
         * @param entropy Optional parameter that may be necessary to produce secure keys
         *
         * @returns Address of the new key pair
         */
        this.makeKey = (entropy = undefined) => {
            let keypair = new PlatformVMKeyPair(this.hrp, this.chainid, entropy);
            this.addKey(keypair);
            return keypair.getAddress();
        };
        /**
         * Given a private key, makes a new key pair, returns the address.
         *
         * @param privk A {@link https://github.com/feross/buffer|Buffer} or cb58 serialized string representing the private key
         *
         * @returns Address of the new key pair
         */
        this.importKey = (privk) => {
            let keypair = new PlatformVMKeyPair(this.hrp, this.chainid);
            let pk;
            if (typeof privk === 'string') {
                pk = bintools.cb58Decode(privk.split('-')[1]);
            }
            else {
                pk = bintools.copyFrom(privk);
            }
            keypair.importKey(pk);
            if (!(keypair.getAddress().toString("hex") in this.keys)) {
                this.addKey(keypair);
            }
            return keypair.getAddress();
        };
    }
}
exports.PlatformVMKeyChain = PlatformVMKeyChain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpcy9wbGF0Zm9ybXZtL2tleWNoYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0dBR0c7QUFDSCxvQ0FBaUM7QUFDakMsbURBQXFDO0FBQ3JDLDhEQUFxQztBQUNyQyxvRUFBNEM7QUFDNUMsNkNBQXNEO0FBR3REOztHQUVHO0FBQ0gsTUFBTSxFQUFFLEdBQXVCLFFBQVEsQ0FBQyxFQUFFLENBQUM7QUFFM0M7O0dBRUc7QUFDSCxNQUFNLEVBQUUsR0FBZ0IsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFNUM7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDO0FBRTFCOztHQUVHO0FBQ0gsTUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFFbEM7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBYSxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBR2xEOztHQUVHO0FBQ0gsTUFBYSxpQkFBa0IsU0FBUSxlQUFPO0lBdUoxQzs7T0FFRztJQUNILFlBQVksR0FBVSxFQUFFLE9BQWMsRUFBRSxVQUFpQixTQUFTO1FBQzlELEtBQUssQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUF2SnhCOztXQUVHO1FBQ08sc0JBQWlCLEdBQUcsQ0FBQyxHQUFVLEVBQStCLEVBQUU7WUFDdEUsTUFBTSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEQsTUFBTSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFD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LElBQUksaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3ZGLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDckIsT0FBTyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDaEMsQ0FBQyxDQUFBO1FBRUQ7Ozs7OztXQU1HO1FBQ0gsY0FBUyxHQUFHLENBQUMsS0FBcUIsRUFBUyxFQUFFO1lBQ3pDLElBQUksT0FBTyxHQUFxQixJQUFJLGlCQUFpQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzlFLElBQUksRUFBUyxDQUFDO1lBQ2QsSUFBRyxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUM7Z0JBQ3pCLEVBQUUsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNqRDtpQkFBTTtnQkFDSCxFQUFFLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNqQztZQUNELE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDdEIsSUFBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUM7Z0JBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDeEI7WUFDRCxPQUFPLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUNoQyxDQUFDLENBQUE7SUFPRCxDQUFDO0NBQ0o7QUEzQ0QsZ0RBMkNDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgUGxhdGZvcm1WTUFQSS1LZXlDaGFpblxuICovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tIFwiYnVmZmVyL1wiO1xuaW1wb3J0ICogYXMgZWxsaXB0aWMgZnJvbSBcImVsbGlwdGljXCI7XG5pbXBvcnQgY3JlYXRlSGFzaCBmcm9tIFwiY3JlYXRlLWhhc2hcIjtcbmltcG9ydCBCaW5Ub29scyBmcm9tICcuLi8uLi91dGlscy9iaW50b29scyc7XG5pbXBvcnQgeyBLZXlQYWlyLCBLZXlDaGFpbiB9IGZyb20gJy4uLy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IFBsYXRmb3JtVk1Db25zdGFudHMgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IEVDOiB0eXBlb2YgZWxsaXB0aWMuZWMgPSBlbGxpcHRpYy5lYztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGVjOiBlbGxpcHRpYy5lYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBlY3BhcmFtcyA9IGVjLmN1cnZlO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgQk4gPSBlY3BhcmFtcy5uLmNvbnN0cnVjdG9yO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHM6IEJpblRvb2xzID0gQmluVG9vbHMuZ2V0SW5zdGFuY2UoKTtcblxuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBwcml2YXRlIGFuZCBwdWJsaWMga2V5cGFpciBvbiB0aGUgUGxhdGZvcm0gQ2hhaW4uIFxuICovXG5leHBvcnQgY2xhc3MgUGxhdGZvcm1WTUtleVBhaXIgZXh0ZW5kcyBLZXlQYWlyIHtcbiAgICBwcm90ZWN0ZWQga2V5cGFpcjplbGxpcHRpYy5lYy5LZXlQYWlyXG4gICAgcHJvdGVjdGVkIGVudHJvcHk6QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfc2lnRnJvbVNpZ0J1ZmZlciA9IChzaWc6QnVmZmVyKTplbGxpcHRpYy5lYy5TaWduYXR1cmVPcHRpb25zID0+IHtcbiAgICAgICAgY29uc3QgciA9IG5ldyBCTihiaW50b29scy5jb3B5RnJvbShzaWcsIDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgQk4oYmludG9vbHMuY29weUZyb20oc2lnLCAzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlQYXJhbTpudW1iZXIgPSBiaW50b29scy5jb3B5RnJvbShzaWcsIDY0LCA2NSkucmVhZFVJbnRCRSgwLCAxKTtcbiAgICAgICAgY29uc3Qgc2lnT3B0ID0ge1xuICAgICAgICAgICAgcjpyLFxuICAgICAgICAgICAgczpzLFxuICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbTpyZWNvdmVyeVBhcmFtXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzaWdPcHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IGtleXBhaXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIGVudHJvcHkgT3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBwcm9kdWNlIHNlY3VyZSBrZXlzXG4gICAgICovXG4gICAgZ2VuZXJhdGVLZXkgPSAoZW50cm9weT86QnVmZmVyKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cm9weSA9IGVudHJvcHk7XG4gICAgICAgIHRoaXMua2V5cGFpciA9IGVjLmdlbktleVBhaXIoKTtcblxuICAgICAgICAvLyBkb2luZyBoZXggdHJhbnNsYXRpb24gdG8gZ2V0IEJ1ZmZlciBjbGFzc1xuICAgICAgICB0aGlzLnByaXZrID0gQnVmZmVyLmZyb20odGhpcy5rZXlwYWlyLmdldFByaXZhdGUoXCJoZXhcIiksIFwiaGV4XCIpO1xuICAgICAgICB0aGlzLnB1YmsgPSBCdWZmZXIuZnJvbSh0aGlzLmtleXBhaXIuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpLCBcImhleFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBvcnRzIGEgcHJpdmF0ZSBrZXkgYW5kIGdlbmVyYXRlcyB0aGUgYXBwcm9wcmlhdGUgcHVibGljIGtleS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gcHJpdmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIHByaXZhdGUga2V5IFxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIHRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZVxuICAgICAqL1xuICAgIGltcG9ydEtleSA9IChwcml2azpCdWZmZXIpOmJvb2xlYW4gPT4ge1xuICAgICAgICB0aGlzLmtleXBhaXIgPSBlYy5rZXlGcm9tUHJpdmF0ZShwcml2ay50b1N0cmluZyhcImhleFwiKSxcImhleFwiKTtcbiAgICAgICAgLy8gZG9pbmcgaGV4IHRyYW5zbGF0aW9uIHRvIGdldCBCdWZmZXIgY2xhc3NcbiAgICAgICAgdGhpcy5wcml2ayA9IEJ1ZmZlci5mcm9tKHRoaXMua2V5cGFpci5nZXRQcml2YXRlKFwiaGV4XCIpLCBcImhleFwiKTtcbiAgICAgICAgdGhpcy5wdWJrID0gQnVmZmVyLmZyb20odGhpcy5rZXlwYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSwgXCJoZXhcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfS5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAgICovXG4gICAgZ2V0QWRkcmVzcyA9ICgpOkJ1ZmZlciA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3NGcm9tUHVibGljS2V5KHRoaXMucHViayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcydzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqL1xuICAgIGdldEFkZHJlc3NTdHJpbmcgPSAoKTpzdHJpbmcgPT4ge1xuICAgICAgICBjb25zdCBhZGRyOkJ1ZmZlciA9IHRoaXMuYWRkcmVzc0Zyb21QdWJsaWNLZXkodGhpcy5wdWJrKTtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmFkZHJlc3NUb1N0cmluZyh0aGlzLmhycCwgdGhpcy5jaGFpbmlkLCBhZGRyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZ2l2ZW4gYSBwdWJsaWMga2V5LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBwdWJrIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBwdWJsaWMga2V5XG4gICAgICogXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIGFkZHJlc3Mgb2YgdGhlIHB1YmxpYyBrZXkuXG4gICAgICovXG4gICAgYWRkcmVzc0Zyb21QdWJsaWNLZXkgPSAocHViazpCdWZmZXIpOiBCdWZmZXIgPT4ge1xuICAgICAgICBpZihwdWJrLmxlbmd0aCA9PSA2NSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHB1YmsgPSBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHVibGljKHB1YmspLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSwgXCJoZXhcIik7IC8vbWFrZSBjb21wYWN0LCBzdGljayBiYWNrIGludG8gYnVmZmVyXG4gICAgICAgIH0gXG4gICAgICAgIGlmKHB1YmsubGVuZ3RoID09IDMzKXtcbiAgICAgICAgICAgIGNvbnN0IHNoYTI1NjpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUocHViaykuZGlnZXN0KCkpO1xuICAgICAgICAgICAgY29uc3QgcmlwZXNoYTpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoc2hhMjU2KS5kaWdlc3QoKSk7XG4gICAgICAgICAgICByZXR1cm4gcmlwZXNoYTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbWFrZSBhZGRyZXNzLlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBnZXRQcml2YXRlS2V5U3RyaW5nID0gKCk6c3RyaW5nID0+IHtcbiAgICAgICAgcmV0dXJuIFwiUHJpdmF0ZUtleS1cIiArIGJpbnRvb2xzLmNiNThFbmNvZGUodGhpcy5wcml2ayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHVibGljIGtleS5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBnZXRQdWJsaWNLZXlTdHJpbmcgPSAoKTpzdHJpbmcgPT4ge1xuICAgICAgICByZXR1cm4gYmludG9vbHMuY2I1OEVuY29kZSh0aGlzLnB1YmspO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBtZXNzYWdlLCBzaWducyBpdCwgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIHNpZ24sIGJlIHN1cmUgdG8gaGFzaCBmaXJzdCBpZiBleHBlY3RlZFxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyB0aGUgc2lnbmF0dXJlXG4gICAgICovXG4gICAgc2lnbiA9IChtc2c6QnVmZmVyKTpCdWZmZXIgPT4ge1xuICAgICAgICBjb25zdCBzaWdPYmogPSB0aGlzLmtleXBhaXIuc2lnbihtc2csIHVuZGVmaW5lZCwgeyBjYW5vbmljYWw6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5OkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgcmVjb3Zlcnkud3JpdGVVSW50OChzaWdPYmoucmVjb3ZlcnlQYXJhbSwgMCk7XG4gICAgICAgIGNvbnN0IHI6QnVmZmVyID0gQnVmZmVyLmZyb20oc2lnT2JqLnIudG9BcnJheShcImJlXCIsIDMyKSk7IC8vd2UgaGF2ZSB0byBza2lwIG5hdGl2ZSBCdWZmZXIgY2xhc3MsIHNvIHRoaXMgaXMgdGhlIHdheVxuICAgICAgICBjb25zdCBzOkJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNpZ09iai5zLnRvQXJyYXkoXCJiZVwiLCAzMikpOyAvL3dlIGhhdmUgdG8gc2tpcCBuYXRpdmUgQnVmZmVyIGNsYXNzLCBzbyB0aGlzIGlzIHRoZSB3YXlcbiAgICAgICAgY29uc3QgcmVzdWx0OkJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3IscywgcmVjb3ZlcnldLCA2NSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcHVibGljIGtleSBwcm9kdWNlcyB0aGUgc2lnbmF0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHNpZyBUaGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgbWVzc2FnZVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIFRydWUgb24gc3VjY2VzcywgZmFsc2Ugb24gZmFpbHVyZVxuICAgICAqL1xuICAgIHZlcmlmeSA9IChtc2c6QnVmZmVyLCBzaWc6QnVmZmVyKTpib29sZWFuID0+IHsgXG4gICAgICAgIGNvbnN0IHNpZ09iajplbGxpcHRpYy5lYy5TaWduYXR1cmVPcHRpb25zID0gdGhpcy5fc2lnRnJvbVNpZ0J1ZmZlcihzaWcpO1xuICAgICAgICByZXR1cm4gZWMudmVyaWZ5KG1zZywgc2lnT2JqLCB0aGlzLmtleXBhaXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY292ZXJzIHRoZSBwdWJsaWMga2V5IG9mIGEgbWVzc2FnZSBzaWduZXIgZnJvbSBhIG1lc3NhZ2UgYW5kIGl0cyBhc3NvY2lhdGVkIHNpZ25hdHVyZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRoYXQncyBzaWduZWRcbiAgICAgKiBAcGFyYW0gc2lnIFRoZSBzaWduYXR1cmUgdGhhdCdzIHNpZ25lZCBvbiB0aGUgbWVzc2FnZVxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyB0aGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyXG4gICAgICovXG4gICAgcmVjb3ZlciA9IChtc2c6QnVmZmVyLCBzaWc6QnVmZmVyKTpCdWZmZXIgPT4ge1xuICAgICAgICBjb25zdCBzaWdPYmo6ZWxsaXB0aWMuZWMuU2lnbmF0dXJlT3B0aW9ucyA9IHRoaXMuX3NpZ0Zyb21TaWdCdWZmZXIoc2lnKTtcbiAgICAgICAgY29uc3QgcHViayA9IGVjLnJlY292ZXJQdWJLZXkobXNnLCBzaWdPYmosIHNpZ09iai5yZWNvdmVyeVBhcmFtKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHB1YmsuZW5jb2RlQ29tcHJlc3NlZCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgcHJpdmF0ZSBhbmQgcHVibGljIGtleXBhaXIgaW4gQXZhbGFuY2hlIFBsYXRmb3JtVk0uIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhycDpzdHJpbmcsIGNoYWluaWQ6c3RyaW5nLCBlbnRyb3B5OkJ1ZmZlciA9IHVuZGVmaW5lZCkge1xuICAgICAgICBzdXBlcihocnAsIGNoYWluaWQpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlS2V5KCk7XG4gICAgfVxuICAgIFxufVxuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBrZXkgY2hhaW4gaW4gQXZhbGFuY2hlLiBcbiAqIFxuICogQHR5cGVwYXJhbSBQbGF0Zm9ybVZNS2V5UGFpciBDbGFzcyBleHRlbmRpbmcgW1tLZXlQYWlyXV0gd2hpY2ggaXMgdXNlZCBhcyB0aGUga2V5IGluIFtbUGxhdGZvcm1WTUtleUNoYWluXV1cbiAqL1xuZXhwb3J0IGNsYXNzIFBsYXRmb3JtVk1LZXlDaGFpbiBleHRlbmRzIEtleUNoYWluPFBsYXRmb3JtVk1LZXlQYWlyPiB7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIG5ldyBrZXkgcGFpciwgcmV0dXJucyB0aGUgYWRkcmVzcy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZW50cm9weSBPcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHByb2R1Y2Ugc2VjdXJlIGtleXNcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIHRoZSBuZXcga2V5IHBhaXJcbiAgICAgKi9cbiAgICBtYWtlS2V5ID0gKGVudHJvcHk6QnVmZmVyID0gdW5kZWZpbmVkKTpCdWZmZXIgPT4ge1xuICAgICAgICBsZXQga2V5cGFpcjpQbGF0Zm9ybVZNS2V5UGFpciA9IG5ldyBQbGF0Zm9ybVZNS2V5UGFpcih0aGlzLmhycCwgdGhpcy5jaGFpbmlkLCBlbnRyb3B5KTtcbiAgICAgICAgdGhpcy5hZGRLZXkoa2V5cGFpcik7XG4gICAgICAgIHJldHVybiBrZXlwYWlyLmdldEFkZHJlc3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHByaXZhdGUga2V5LCBtYWtlcyBhIG5ldyBrZXkgcGFpciwgcmV0dXJucyB0aGUgYWRkcmVzcy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gcHJpdmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcHJpdmF0ZSBrZXkgXG4gICAgICogXG4gICAgICogQHJldHVybnMgQWRkcmVzcyBvZiB0aGUgbmV3IGtleSBwYWlyXG4gICAgICovXG4gICAgaW1wb3J0S2V5ID0gKHByaXZrOkJ1ZmZlciB8IHN0cmluZyk6QnVmZmVyID0+IHtcbiAgICAgICAgbGV0IGtleXBhaXI6UGxhdGZvcm1WTUtleVBhaXIgPSBuZXcgUGxhdGZvcm1WTUtleVBhaXIodGhpcy5ocnAsIHRoaXMuY2hhaW5pZCk7XG4gICAgICAgIGxldCBwazpCdWZmZXI7XG4gICAgICAgIGlmKHR5cGVvZiBwcml2ayA9PT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgcGsgPSBiaW50b29scy5jYjU4RGVjb2RlKHByaXZrLnNwbGl0KCctJylbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGsgPSBiaW50b29scy5jb3B5RnJvbShwcml2ayk7XG4gICAgICAgIH1cbiAgICAgICAga2V5cGFpci5pbXBvcnRLZXkocGspO1xuICAgICAgICBpZighKGtleXBhaXIuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKFwiaGV4XCIpIGluIHRoaXMua2V5cykpe1xuICAgICAgICAgICAgdGhpcy5hZGRLZXkoa2V5cGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXBhaXIuZ2V0QWRkcmVzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgUGxhdGZvcm1WTUtleUNoYWluLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhycDpzdHJpbmcsIGNoYWluaWQ6c3RyaW5nKXtcbiAgICAgICAgc3VwZXIoaHJwLCBjaGFpbmlkKTtcbiAgICB9XG59Il19