"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UTXOSet = exports.UTXO = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI-UTXOs
 */
const buffer_1 = require("buffer/");
const bintools_1 = __importDefault(require("../../utils/bintools"));
const bn_js_1 = __importDefault(require("bn.js"));
const outputs_1 = require("./outputs");
const types_1 = require("./types");
const tx_1 = require("./tx");
const inputs_1 = require("./inputs");
const ops_1 = require("./ops");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Class for representing a single UTXO.
 */
class UTXO {
    /**
       * Class for representing a single UTXO.
       *
       * @param txid Optional {@link https://github.com/feross/buffer|Buffer} of transaction ID for the UTXO
       * @param txidx Optional {@link https://github.com/feross/buffer|Buffer} or number for the index of the transaction's [[Output]]
       * @param assetid Optional {@link https://github.com/feross/buffer|Buffer} of the asset ID for the UTXO
       * @param outputid Optional {@link https://github.com/feross/buffer|Buffer} or number of the output ID for the UTXO
       */
    constructor(codecID = types_1.AVMConstants.LATESTCODEC, txid = undefined, outputidx = undefined, assetid = undefined, output = undefined) {
        this.codecid = buffer_1.Buffer.alloc(2);
        this.txid = buffer_1.Buffer.alloc(32);
        this.outputidx = buffer_1.Buffer.alloc(4);
        this.assetid = buffer_1.Buffer.alloc(32);
        this.output = undefined;
        /**
           * Returns the numeric representation of the CodecID.
           */
        this.getCodecID = () => this.codecid.readUInt8(0);
        /**
         * Returns the {@link https://github.com/feross/buffer|Buffer} representation of the CodecID
          */
        this.getCodecIDBuffer = () => this.codecid;
        /**
           * Returns a {@link https://github.com/feross/buffer|Buffer} of the TxID.
           */
        this.getTxID = () => this.txid;
        /**
           * Returns a {@link https://github.com/feross/buffer|Buffer}  of the OutputIdx.
           */
        this.getOutputIdx = () => this.outputidx;
        /**
           * Returns the assetID as a {@link https://github.com/feross/buffer|Buffer}.
           */
        this.getAssetID = () => this.assetid;
        /**
           * Returns the UTXOID as a base-58 string (UTXOID is a string )
           */
        this.getUTXOID = () => bintools.bufferToB58(buffer_1.Buffer.concat([this.getTxID(), this.getOutputIdx()]));
        /**
           * Returns a reference to the output;
          */
        this.getOutput = () => this.output;
        if (typeof codecID !== 'undefined' && typeof txid !== 'undefined'
            && typeof outputidx !== 'undefined'
            && typeof assetid !== 'undefined'
            && typeof output !== 'undefined') {
            this.codecid.writeUInt8(codecID, 0);
            this.txid = txid;
            if (typeof outputidx === 'number') {
                this.outputidx.writeUInt32BE(outputidx, 0);
            }
            else if (outputidx instanceof buffer_1.Buffer) {
                this.outputidx = outputidx;
            }
            else {
                /* istanbul ignore next */
                throw new Error('Error - UTXO.constructor: outputidx parameter is not a '
                    + `number or a Buffer: ${outputidx}`);
            }
            this.assetid = assetid;
            this.output = output;
        }
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[UTXO]], parses it, populates the class, and returns the length of the UTXO in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[UTXO]]
       */
    fromBuffer(bytes, offset = 0) {
        this.codecid = bintools.copyFrom(bytes, offset, offset + 2);
        offset += 2;
        this.txid = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        this.outputidx = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.assetid = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        const outputid = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
        offset += 4;
        this.output = outputs_1.SelectOutputClass(outputid);
        return this.output.fromBuffer(bytes, offset);
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[UTXO]].
       */
    toBuffer() {
        const outbuff = this.output.toBuffer();
        const outputidbuffer = buffer_1.Buffer.alloc(4);
        outputidbuffer.writeUInt32BE(this.output.getOutputID(), 0);
        const barr = [this.codecid, this.txid, this.outputidx, this.assetid, outputidbuffer, outbuff];
        return buffer_1.Buffer.concat(barr, this.codecid.length + this.txid.length
            + this.outputidx.length + this.assetid.length
            + outputidbuffer.length + outbuff.length);
    }
    /**
       * Takes a base-58 string containing an [[UTXO]], parses it, populates the class, and returns the length of the UTXO in bytes.
       *
       * @param serialized A base-58 string containing a raw [[UTXO]]
       *
       * @returns The length of the raw [[UTXO]]
       *
       * @remarks
       * unlike most fromStrings, it expects the string to be serialized in cb58 format
       */
    fromString(serialized) {
        /* istanbul ignore next */
        return this.fromBuffer(bintools.cb58Decode(serialized));
    }
    /**
       * Returns a base-58 representation of the [[UTXO]].
       *
       * @remarks
       * unlike most toStrings, this returns in cb58 serialization format
       */
    toString() {
        /* istanbul ignore next */
        return bintools.cb58Encode(this.toBuffer());
    }
}
exports.UTXO = UTXO;
/**
 * Class representing a set of [[UTXO]]s.
 */
class UTXOSet {
    constructor() {
        this.utxos = {};
        this.addressUTXOs = {}; // maps address to utxoids:locktime
        /**
           * Returns true if the [[UTXO]] is in the UTXOSet.
           *
           * @param utxo Either a [[UTXO]] a cb58 serialized string representing a UTXO
           */
        this.includes = (utxo) => {
            const utxoX = new UTXO();
            // force a copy
            if (typeof utxo === 'string') {
                utxoX.fromBuffer(bintools.cb58Decode(utxo));
            }
            else {
                utxoX.fromBuffer(utxo.toBuffer()); // forces a copy
            }
            const utxoid = utxoX.getUTXOID();
            return (utxoid in this.utxos);
        };
        /**
           * Adds a UTXO to the UTXOSet.
           *
           * @param utxo Either a [[UTXO]] an cb58 serialized string representing a UTXO
           * @param overwrite If true, if the UTXOID already exists, overwrite it... default false
           *
           * @returns A [[UTXO]] if one was added and undefined if nothing was added.
           */
        this.add = (utxo, overwrite = false) => {
            const utxovar = new UTXO();
            // force a copy
            if (typeof utxo === 'string') {
                utxovar.fromBuffer(bintools.cb58Decode(utxo));
            }
            else if (utxo instanceof UTXO) {
                utxovar.fromBuffer(utxo.toBuffer()); // forces a copy
            }
            else {
                /* istanbul ignore next */
                throw new Error(`Error - UTXOSet.add: utxo parameter is not a UTXO or string: ${utxo}`);
            }
            const utxoid = utxovar.getUTXOID();
            if (!(utxoid in this.utxos) || overwrite === true) {
                this.utxos[utxoid] = utxovar;
                const addresses = utxovar.getOutput().getAddresses();
                const locktime = utxovar.getOutput().getLocktime();
                for (let i = 0; i < addresses.length; i++) {
                    const address = addresses[i].toString('hex');
                    if (!(address in this.addressUTXOs)) {
                        this.addressUTXOs[address] = {};
                    }
                    this.addressUTXOs[address][utxoid] = locktime;
                }
                return utxovar;
            }
            return undefined;
        };
        /**
           * Adds an array of [[UTXO]]s to the [[UTXOSet]].
           *
           * @param utxo Either a [[UTXO]] an cb58 serialized string representing a UTXO
           * @param overwrite If true, if the UTXOID already exists, overwrite it... default false
           *
           * @returns An array of UTXOs which were added.
           */
        this.addArray = (utxos, overwrite = false) => {
            const added = [];
            for (let i = 0; i < utxos.length; i++) {
                const result = this.add(utxos[i], overwrite);
                if (typeof result !== 'undefined') {
                    added.push(result);
                }
            }
            return added;
        };
        /**
           * Removes a [[UTXO]] from the [[UTXOSet]] if it exists.
           *
           * @param utxo Either a [[UTXO]] an cb58 serialized string representing a UTXO
           *
           * @returns A [[UTXO]] if it was removed and undefined if nothing was removed.
           */
        this.remove = (utxo) => {
            const utxovar = new UTXO();
            // force a copy
            if (typeof utxo === 'string') {
                utxovar.fromBuffer(bintools.cb58Decode(utxo));
            }
            else {
                utxovar.fromBuffer(utxo.toBuffer()); // forces a copy
            }
            const utxoid = utxovar.getUTXOID();
            if (!(utxoid in this.utxos)) {
                return undefined;
            }
            delete this.utxos[utxoid];
            const addresses = Object.keys(this.addressUTXOs);
            for (let i = 0; i < addresses.length; i++) {
                if (utxoid in this.addressUTXOs[addresses[i]]) {
                    delete this.addressUTXOs[addresses[i]][utxoid];
                }
            }
            return utxovar;
        };
        /**
           * Removes an array of [[UTXO]]s to the [[UTXOSet]].
           *
           * @param utxo Either a [[UTXO]] an cb58 serialized string representing a UTXO
           * @param overwrite If true, if the UTXOID already exists, overwrite it... default false
           *
           * @returns An array of UTXOs which were removed.
           */
        this.removeArray = (utxos) => {
            const removed = [];
            for (let i = 0; i < utxos.length; i++) {
                const result = this.remove(utxos[i]);
                if (typeof result !== 'undefined') {
                    removed.push(result);
                }
            }
            return removed;
        };
        /**
           * Gets a [[UTXO]] from the [[UTXOSet]] by its UTXOID.
           *
           * @param utxoid String representing the UTXOID
           *
           * @returns A [[UTXO]] if it exists in the set.
           */
        this.getUTXO = (utxoid) => this.utxos[utxoid];
        /**
           * Gets all the [[UTXO]]s, optionally that match with UTXOIDs in an array
           *
           * @param utxoids An optional array of UTXOIDs, returns all [[UTXO]]s if not provided
           *
           * @returns An array of [[UTXO]]s.
           */
        this.getAllUTXOs = (utxoids = undefined) => {
            let results = [];
            if (typeof utxoids !== 'undefined' && Array.isArray(utxoids)) {
                for (let i = 0; i < utxoids.length; i++) {
                    if (utxoids[i] in this.utxos && !(utxoids[i] in results)) {
                        results.push(this.utxos[utxoids[i]]);
                    }
                }
            }
            else {
                results = Object.values(this.utxos);
            }
            return results;
        };
        /**
           * Gets all the [[UTXO]]s as strings, optionally that match with UTXOIDs in an array.
           *
           * @param utxoids An optional array of UTXOIDs, returns all [[UTXO]]s if not provided
           *
           * @returns An array of [[UTXO]]s as cb58 serialized strings.
           */
        this.getAllUTXOStrings = (utxoids = undefined) => {
            const results = [];
            const utxos = Object.keys(this.utxos);
            if (typeof utxoids !== 'undefined' && Array.isArray(utxoids)) {
                for (let i = 0; i < utxoids.length; i++) {
                    if (utxoids[i] in this.utxos) {
                        results.push(this.utxos[utxoids[i]].toString());
                    }
                }
            }
            else {
                for (const u of utxos) {
                    results.push(this.utxos[u].toString());
                }
            }
            return results;
        };
        /**
           * Given an address or array of addresses, returns all the UTXOIDs for those addresses
           *
           * @param address An array of address {@link https://github.com/feross/buffer|Buffer}s
           * @param spendable If true, only retrieves UTXOIDs whose locktime has passed
           *
           * @returns An array of addresses.
           */
        this.getUTXOIDs = (addresses = undefined, spendable = true) => {
            if (typeof addresses !== 'undefined') {
                const results = [];
                const now = types_1.UnixNow();
                for (let i = 0; i < addresses.length; i++) {
                    if (addresses[i].toString('hex') in this.addressUTXOs) {
                        const entries = Object.entries(this.addressUTXOs[addresses[i].toString('hex')]);
                        for (const [utxoid, locktime] of entries) {
                            if ((results.indexOf(utxoid) === -1
                                && (spendable && locktime.lte(now)))
                                || !spendable) {
                                results.push(utxoid);
                            }
                        }
                    }
                }
                return results;
            }
            return Object.keys(this.utxos);
        };
        /**
           * Gets the addresses in the [[UTXOSet]] and returns an array of {@link https://github.com/feross/buffer|Buffer}.
           */
        this.getAddresses = () => Object.keys(this.addressUTXOs)
            .map((k) => buffer_1.Buffer.from(k, 'hex'));
        /**
           * Returns the balance of a set of addresses in the UTXOSet.
           *
           * @param addresses An array of addresses
           * @param assetID Either a {@link https://github.com/feross/buffer|Buffer} or an cb58 serialized representation of an AssetID
           * @param asOf The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           *
           * @returns Returns the total balance as a {@link https://github.com/indutny/bn.js/|BN}.
           */
        this.getBalance = (addresses, assetID, asOf = undefined) => {
            const utxoids = this.getUTXOIDs(addresses);
            const utxos = this.getAllUTXOs(utxoids);
            let spend = new bn_js_1.default(0);
            let asset;
            if (typeof assetID === 'string') {
                asset = bintools.cb58Decode(assetID);
            }
            else {
                asset = assetID;
            }
            for (let i = 0; i < utxos.length; i++) {
                if (utxos[i].getOutput() instanceof outputs_1.AmountOutput
                    && utxos[i].getAssetID().toString('hex') === asset.toString('hex')
                    && utxos[i].getOutput().meetsThreshold(addresses, asOf)) {
                    spend = spend.add(utxos[i].getOutput().getAmount());
                }
            }
            return spend;
        };
        /**
           * Gets all the Asset IDs, optionally that match with Asset IDs in an array
           *
           * @param utxoids An optional array of Addresses as string or Buffer, returns all Asset IDs if not provided
           *
           * @returns An array of {@link https://github.com/feross/buffer|Buffer} representing the Asset IDs.
           */
        this.getAssetIDs = (addresses = undefined) => {
            const results = new Set();
            let utxoids = [];
            if (typeof addresses !== 'undefined') {
                utxoids = this.getUTXOIDs(addresses);
            }
            else {
                utxoids = this.getUTXOIDs();
            }
            for (let i = 0; i < utxoids.length; i++) {
                if (utxoids[i] in this.utxos && !(utxoids[i] in results)) {
                    results.add(this.utxos[utxoids[i]].getAssetID());
                }
            }
            return [...results];
        };
        /**
           * Creates an [[UnsignedTx]] wrapping a [[BaseTx]]. For more granular control, you may create your own
           * [[UnsignedTx]] wrapping a [[BaseTx]] manually (with their corresponding [[TransferableInput]]s and [[TransferableOutput]]s).
           *
           * @param networkid The number representing NetworkID of the node
           * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
           * @param amount The amount of AVAX to be spent in $nAVAX
           * @param toAddresses The addresses to send the funds
           * @param fromAddresses The addresses being used to send the funds from the UTXOs {@link https://github.com/feross/buffer|Buffer}
           * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs
           * @param assetid {@link https://github.com/feross/buffer|Buffer} of the asset ID for the UTXO
           * @param memo Optional contains arbitrary bytes, up to 256 bytes
           * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           * @param locktime Optional. The locktime field created in the resulting outputs
           * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
           * @param outputID Optional. The outputID used for this transaction, must implement AmountOutput, default AVMConstants.SECPOUTPUTID
           *
           * @returns An unsigned transaction created from the passed in parameters.
           *
           */
        this.buildBaseTx = (networkid, blockchainid, amount, toAddresses, fromAddresses, changeAddresses, assetID, memo = undefined, asOf = types_1.UnixNow(), locktime = new bn_js_1.default(0), threshold = 1, outputID = types_1.AVMConstants.SECPOUTPUTID) => {
            const zero = new bn_js_1.default(0);
            let spendamount = zero.clone();
            const utxos = this.getAllUTXOs(this.getUTXOIDs(fromAddresses));
            let change = zero.clone();
            const outs = [];
            const ins = [];
            if (!(outputs_1.SelectOutputClass(outputID) instanceof outputs_1.AmountOutput)) {
                /* istanbul ignore next */
                throw new Error('Error - UTXOSet.buildBaseTx: outputID does not '
                    + `implement AmountOutput: ${outputID}`);
            }
            if (!amount.eq(zero)) {
                const sndout = outputs_1.SelectOutputClass(outputID, amount, toAddresses, locktime, threshold);
                const mainXferout = new outputs_1.TransferableOutput(assetID, sndout);
                outs.push(mainXferout);
                for (let i = 0; i < utxos.length && spendamount.lt(amount); i++) {
                    if (utxos[i].getOutput() instanceof outputs_1.AmountOutput
                        && (assetID === undefined
                            || utxos[i].getAssetID().compare(assetID) === 0)
                        && utxos[i].getOutput().meetsThreshold(fromAddresses, asOf)) {
                        const output = utxos[i].getOutput();
                        const amt = output.getAmount().clone();
                        spendamount = spendamount.add(amt);
                        change = spendamount.sub(amount);
                        change = change.gt(zero) ? change : zero.clone();
                        const txid = utxos[i].getTxID();
                        const outputidx = utxos[i].getOutputIdx();
                        const input = new inputs_1.SecpInput(amt);
                        const xferin = new inputs_1.TransferableInput(txid, outputidx, assetID, input);
                        const spenders = output.getSpenders(fromAddresses, asOf);
                        for (let j = 0; j < spenders.length; j++) {
                            const idx = output.getAddressIdx(spenders[j]);
                            if (idx === -1) {
                                /* istanbul ignore next */
                                throw new Error('Error - UTXOSet.buildBaseTx: no such '
                                    + `address in output: ${spenders[j]}`);
                            }
                            xferin.getInput().addSignatureIdx(idx, spenders[j]);
                        }
                        ins.push(xferin);
                        if (change.gt(zero)) {
                            if (assetID) {
                                const changeout = outputs_1.SelectOutputClass(outputID, change, changeAddresses, zero.clone(), 1);
                                const xferout = new outputs_1.TransferableOutput(assetID, changeout);
                                outs.push(xferout);
                            }
                            break;
                        }
                        /* istanbul ignore next */
                        if (spendamount.gte(amount)) {
                            break;
                        }
                    }
                }
                if (spendamount.lt(amount)) {
                    /* istanbul ignore next */
                    throw new Error('Error - UTXOSet.buildBaseTx: insufficient '
                        + 'funds to create the transaction');
                }
            }
            const baseTx = new tx_1.BaseTx(networkid, blockchainid, outs, ins, memo);
            return new tx_1.UnsignedTx(baseTx);
        };
        /**
           * Creates an unsigned transaction. For more granular control, you may create your own
           * [[CreateAssetTX]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s).
           *
           * @param networkid The number representing NetworkID of the node
           * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
           * @param avaxAssetId The AVAX Asset ID
           * @param fee The amount of AVAX to be paid for fees, in $nAVAX
           * @param feeSenderAddresses The addresses to send the fees
           * @param initialState The [[InitialStates]] that represent the intial state of a created asset
           * @param name String for the descriptive name of the asset
           * @param symbol String for the ticker symbol of the asset
           * @param denomination Optional number for the denomination which is 10^D. D must be >= 0 and <= 32. Ex: $1 AVAX = 10^9 $nAVAX
           * @param memo Optional contains arbitrary bytes, up to 256 bytes
           * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           *
           * @returns An unsigned transaction created from the passed in parameters.
           *
           */
        this.buildCreateAssetTx = (networkid, blockchainid, avaxAssetID, fee, feeSenderAddresses, initialState, name, symbol, denomination, memo = undefined, asOf = types_1.UnixNow()) => {
            // Cheating and using buildBaseTx to get Ins and Outs for fees.
            // Fees are burned, so no toAddresses, only fromAddresses and changeAddresses, both are the feeSenderAddresses
            let utx = this.buildBaseTx(networkid, blockchainid, fee, [], feeSenderAddresses, feeSenderAddresses, avaxAssetID, undefined, asOf);
            let ins = utx.getTransaction().getIns();
            let outs = utx.getTransaction().getOuts();
            let CAtx = new tx_1.CreateAssetTx(networkid, blockchainid, outs, ins, memo, name, symbol, denomination, initialState);
            return new tx_1.UnsignedTx(CAtx);
        };
        /**
         * Creates an unsigned transaction. For more granular control, you may create your own
          * [[CreateAssetTX]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s).
          *
          * @param networkid The number representing NetworkID of the node
          * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
          * @param avaxAssetId The AVAX Asset ID
          * @param fee The amount of AVAX to be paid for fees, in $nAVAX
          * @param feePayingAddresses The addresses to pay the fees
          * @param minterSets The minters and thresholds required to mint this nft asset
          * @param name String for the descriptive name of the nft asset
          * @param symbol String for the ticker symbol of the nft asset
          * @param memo Optional contains arbitrary bytes, up to 256 bytes
          * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
          * @param locktime Optional. The locktime field created in the resulting mint output
          *
          * @returns An unsigned transaction created from the passed in parameters.
          *
          */
        this.buildCreateNFTAssetTx = (networkid, blockchainid, avaxAssetID, fee, feePayingAddresses, minterSets, name, symbol, memo = undefined, asOf = types_1.UnixNow(), locktime = undefined) => {
            let initialState = new types_1.InitialStates();
            let utx = this.buildBaseTx(networkid, blockchainid, fee, [], feePayingAddresses, feePayingAddresses, avaxAssetID, undefined, asOf);
            let ins = utx.getTransaction().getIns();
            let outs = utx.getTransaction().getOuts();
            for (let i = 0; i < minterSets.length; i++) {
                let nftMintOutput = new outputs_1.NFTMintOutput(i, minterSets[i].getMinters(), locktime, minterSets[i].getThreshold());
                initialState.addOutput(nftMintOutput, types_1.AVMConstants.NFTFXID);
            }
            let denomination = 0; // NFTs are non-fungible
            let CAtx = new tx_1.CreateAssetTx(networkid, blockchainid, outs, ins, memo, name, symbol, denomination, initialState);
            return new tx_1.UnsignedTx(CAtx);
        };
        /**
         * Creates an unsigned NFT mint transaction. For more granular control, you may create your own
          * [[NFTMintTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
          *
          * @param networkid The number representing NetworkID of the node
          * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
          * @param feeAssetID The assetID for the AVAX fee to be paid
          * @param fee The amount of AVAX to be paid for fees, in $nAVAX
          * @param feeSenderAddresses The addresses to send the fees
          * @param outputOwners:Array An array of OutputOwners
          * @param fromAddresses An array for {@link https://github.com/feross/buffer|Buffer} who owns the NFT
          * @param utxoids An array of strings for the NFTs being transferred
          * @param groupID Optional. The group this NFT is issued to.
          * @param payload Optional. Data for NFT Payload.
          * @param memo Optional contains arbitrary bytes, up to 256 bytes
          * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
          * @param locktime Optional. The locktime field created in the resulting mint output
          * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
          *
          * @returns An unsigned transaction created from the passed in parameters.
          *
          */
        this.buildCreateNFTMintTx = (networkid, blockchainid, feeAssetID, fee, feeSenderAddresses, to, fromAddresses, utxoids, groupID = 0, payload = undefined, memo = undefined, asOf = types_1.UnixNow(), locktime, threshold = 1) => {
            let utx = this.buildBaseTx(networkid, blockchainid, fee, [], feeSenderAddresses, feeSenderAddresses, feeAssetID, undefined, asOf);
            let ins = utx.getTransaction().getIns();
            let outs = utx.getTransaction().getOuts();
            let ops = [];
            if (threshold > to.length) {
                /* istanbul ignore next */
                throw new Error(`Error - UTXOSet.buildCreateNFTMintTx: threshold is greater than number of addresses`);
            }
            let nftMintOperation = new ops_1.NFTMintOperation(groupID, payload, [new outputs_1.OutputOwners(to, locktime, threshold)]);
            for (let i = 0; i < utxoids.length; i++) {
                let utxo = this.getUTXO(utxoids[i]);
                let out = utxo.getOutput();
                let spenders = out.getSpenders(fromAddresses, asOf);
                for (let j = 0; j < spenders.length; j++) {
                    let idx;
                    idx = out.getAddressIdx(spenders[j]);
                    if (idx == -1) {
                        /* istanbul ignore next */
                        throw new Error(`Error - UTXOSet.buildCreateNFTMintTx: no such address in output: ${spenders[j]}`);
                    }
                    nftMintOperation.addSignatureIdx(idx, spenders[j]);
                }
                let transferableOperation = new ops_1.TransferableOperation(utxo.getAssetID(), utxoids, nftMintOperation);
                ops.push(transferableOperation);
            }
            let operationTx = new tx_1.OperationTx(networkid, blockchainid, outs, ins, memo, ops);
            return new tx_1.UnsignedTx(operationTx);
        };
        /**
         * Creates an unsigned NFT transfer transaction. For more granular control, you may create your own
          * [[NFTTransferOperation]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
          *
          * @param networkid The number representing NetworkID of the node
          * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
          * @param feeAssetID The assetID for the AVAX fee to be paid
          * @param fee The amount of AVAX to be paid for fees, in $nAVAX
          * @param feeSenderAddresses The addresses to send the fees
          * @param toAddresses An array of {@link https://github.com/feross/buffer|Buffer}s which indicate who recieves the NFT
          * @param fromAddresses An array for {@link https://github.com/feross/buffer|Buffer} who owns the NFT
          * @param utxoids An array of strings for the NFTs being transferred
          * @param memo Optional contains arbitrary bytes, up to 256 bytes
          * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
          * @param locktime Optional. The locktime field created in the resulting outputs
          * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
          * @returns An unsigned transaction created from the passed in parameters.
          *
          */
        this.buildNFTTransferTx = (networkid, blockchainid, feeAssetID, fee, feeSenderAddresses, toAddresses, fromAddresses, utxoids, memo = undefined, asOf = types_1.UnixNow(), locktime = new bn_js_1.default(0), threshold = 1) => {
            // Cheating and using buildBaseTx to get Ins and Outs for fees.
            // Fees are burned, so no toAddresses, only feeSenderAddresses and changeAddresses, both are the feeSenderAddresses
            const utx = this.buildBaseTx(networkid, blockchainid, fee, [], feeSenderAddresses, feeSenderAddresses, feeAssetID, undefined, asOf);
            const ins = utx.getTransaction().getIns();
            const outs = utx.getTransaction().getOuts();
            const ops = [];
            for (let i = 0; i < utxoids.length; i++) {
                const utxo = this.getUTXO(utxoids[i]);
                const out = utxo.getOutput();
                const spenders = out.getSpenders(fromAddresses, asOf);
                const outbound = new outputs_1.NFTTransferOutput(out.getGroupID(), out.getPayload(), toAddresses, locktime, threshold);
                const op = new ops_1.NFTTransferOperation(outbound);
                for (let j = 0; j < spenders.length; j++) {
                    const idx = out.getAddressIdx(spenders[j]);
                    if (idx === -1) {
                        /* istanbul ignore next */
                        throw new Error('Error - UTXOSet.buildNFTTransferTx: '
                            + `no such address in output: ${spenders[j]}`);
                    }
                    op.addSignatureIdx(idx, spenders[j]);
                }
                const xferop = new ops_1.TransferableOperation(utxo.getAssetID(), [utxoids[i]], op);
                ops.push(xferop);
            }
            const OpTx = new tx_1.OperationTx(networkid, blockchainid, outs, ins, memo, ops);
            return new tx_1.UnsignedTx(OpTx);
        };
        /**
        * In-Development, do not use: Creates an unsigned ImportTx transaction.
        *
        * @param networkid The number representing NetworkID of the node
        * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
        * @param feeAssetID The assetID for the AVAX fee to be paid
        * @param fee The amount of AVAX to be paid for fees, in $nAVAX
        * @param feeSenderAddresses The addresses to send the fees
        * @param importIns An array of [[TransferableInput]]s being imported
        * @param memo Optional contains arbitrary bytes, up to 256 bytes
        * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
        * @returns An unsigned transaction created from the passed in parameters.
        *
        */
        this.buildImportTx = (networkid, blockchainid, feeAssetID, fee, feeSenderAddresses, importIns, memo = undefined, asOf = types_1.UnixNow()) => {
            // Cheating and using buildBaseTx to get Ins and Outs for fees.
            // Fees are burned, so no toAddresses, only feeSenderAddresses and changeAddresses, both are the feeSenderAddresses
            const utx = this.buildBaseTx(networkid, blockchainid, fee, [], feeSenderAddresses, feeSenderAddresses, feeAssetID, undefined, asOf);
            const ins = utx.getTransaction().getIns();
            const outs = utx.getTransaction().getOuts();
            const importTx = new tx_1.ImportTx(networkid, blockchainid, outs, ins, memo, importIns);
            return new tx_1.UnsignedTx(importTx);
        };
        /**
        * In-Development, do not use: Creates an unsigned ExportTx transaction.
        *
        * @param networkid The number representing NetworkID of the node
        * @param blockchainid The {@link https://github.com/feross/buffer|Buffer} representing the BlockchainID for the transaction
        * @param feeAssetID The assetID for the AVAX fee to be paid
        * @param fee The amount of AVAX to be paid for fees, in $nAVAX
        * @param feeSenderAddresses The addresses to send the fees
        * @param utxoids An array of strings for the [[TransferableOutput]]s being exported
        * @param memo Optional contains arbitrary bytes, up to 256 bytes
        * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
        * @returns An unsigned transaction created from the passed in parameters.
        *
        */
        this.buildExportTx = (networkid, blockchainid, feeAssetID, fee, feeSenderAddresses, utxoids, memo = undefined, asOf = types_1.UnixNow()) => {
            // Cheating and using buildBaseTx to get Ins and Outs for fees.
            // Fees are burned, so no toAddresses, only feeSenderAddresses and changeAddresses, both are the feeSenderAddresses
            const utx = this.buildBaseTx(networkid, blockchainid, fee, [], feeSenderAddresses, feeSenderAddresses, feeAssetID, undefined, asOf);
            const ins = utx.getTransaction().getIns();
            const outs = utx.getTransaction().getOuts();
            const exportOuts = [];
            for (let i = 0; i < utxoids.length; i++) {
                const utxo = this.getUTXO(utxoids[i]);
                const assetID = utxo.getAssetID();
                const output = utxo.getOutput();
                const amt = output.getAmount().clone();
                const txid = utxo.getTxID();
                const outputidx = utxo.getOutputIdx();
                const input = new inputs_1.SecpInput(amt);
                const xferin = new inputs_1.TransferableInput(txid, outputidx, assetID, input);
                const fromAddresses = output.getAddresses(); // Verify correct approach
                const spenders = output.getSpenders(fromAddresses, asOf);
                for (let j = 0; j < spenders.length; j++) {
                    const idx = output.getAddressIdx(spenders[j]);
                    if (idx === -1) {
                        /* istanbul ignore next */
                        throw new Error('Error - UTXOSet.buildBaseTx: no such '
                            + `address in output: ${spenders[j]}`);
                    }
                    xferin.getInput().addSignatureIdx(idx, spenders[j]);
                }
                ins.push(xferin);
                const xferOut = new outputs_1.TransferableOutput(assetID, output);
                exportOuts.push(xferOut);
            }
            const exportTx = new tx_1.ExportTx(networkid, blockchainid, outs, ins, memo, exportOuts);
            return new tx_1.UnsignedTx(exportTx);
        };
        /**
           * Returns a new set with copy of UTXOs in this and set parameter.
           *
           * @param utxoset The [[UTXOSet]] to merge with this one
           * @param hasUTXOIDs Will subselect a set of [[UTXO]]s which have the UTXOIDs provided in this array, defults to all UTXOs
           *
           * @returns A new UTXOSet that contains all the filtered elements.
           */
        this.merge = (utxoset, hasUTXOIDs = undefined) => {
            const results = new UTXOSet();
            const utxos1 = this.getAllUTXOs(hasUTXOIDs);
            const utxos2 = utxoset.getAllUTXOs(hasUTXOIDs);
            const process = (utxo) => {
                results.add(utxo);
            };
            utxos1.forEach(process);
            utxos2.forEach(process);
            return results;
        };
        /**
           * Set intersetion between this set and a parameter.
           *
           * @param utxoset The set to intersect
           *
           * @returns A new UTXOSet containing the intersection
           */
        this.intersection = (utxoset) => {
            const us1 = this.getUTXOIDs();
            const us2 = utxoset.getUTXOIDs();
            const results = us1.filter((utxoid) => us2.includes(utxoid));
            return this.merge(utxoset, results);
        };
        /**
           * Set difference between this set and a parameter.
           *
           * @param utxoset The set to difference
           *
           * @returns A new UTXOSet containing the difference
           */
        this.difference = (utxoset) => {
            const us1 = this.getUTXOIDs();
            const us2 = utxoset.getUTXOIDs();
            const results = us1.filter((utxoid) => !us2.includes(utxoid));
            return this.merge(utxoset, results);
        };
        /**
           * Set symmetrical difference between this set and a parameter.
           *
           * @param utxoset The set to symmetrical difference
           *
           * @returns A new UTXOSet containing the symmetrical difference
           */
        this.symDifference = (utxoset) => {
            const us1 = this.getUTXOIDs();
            const us2 = utxoset.getUTXOIDs();
            const results = us1.filter((utxoid) => !us2.includes(utxoid))
                .concat(us2.filter((utxoid) => !us1.includes(utxoid)));
            return this.merge(utxoset, results);
        };
        /**
           * Set union between this set and a parameter.
           *
           * @param utxoset The set to union
           *
           * @returns A new UTXOSet containing the union
           */
        this.union = (utxoset) => this.merge(utxoset);
        /**
           * Merges a set by the rule provided.
           *
           * @param utxoset The set to merge by the MergeRule
           * @param mergeRule The [[MergeRule]] to apply
           *
           * @returns A new UTXOSet containing the merged data
           *
           * @remarks
           * The merge rules are as follows:
           *   * "intersection" - the intersection of the set
           *   * "differenceSelf" - the difference between the existing data and new set
           *   * "differenceNew" - the difference between the new data and the existing set
           *   * "symDifference" - the union of the differences between both sets of data
           *   * "union" - the unique set of all elements contained in both sets
           *   * "unionMinusNew" - the unique set of all elements contained in both sets, excluding values only found in the new set
           *   * "unionMinusSelf" - the unique set of all elements contained in both sets, excluding values only found in the existing set
           */
        this.mergeByRule = (utxoset, mergeRule) => {
            let uSet;
            switch (mergeRule) {
                case 'intersection':
                    return this.intersection(utxoset);
                case 'differenceSelf':
                    return this.difference(utxoset);
                case 'differenceNew':
                    return utxoset.difference(this);
                case 'symDifference':
                    return this.symDifference(utxoset);
                case 'union':
                    return this.union(utxoset);
                case 'unionMinusNew':
                    uSet = this.union(utxoset);
                    return uSet.difference(utxoset);
                case 'unionMinusSelf':
                    uSet = this.union(utxoset);
                    return uSet.difference(this);
                default:
                    throw new Error(`Error - UTXOSet.mergeByRule: bad MergeRule - ${mergeRule}`);
            }
        };
    }
}
exports.UTXOSet = UTXOSet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXR4b3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpcy9hdm0vdXR4b3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztHQUdHO0FBQ0gsb0NBQWlDO0FBQ2pDLG9FQUE0QztBQUM1QyxrREFBdUI7QUFDdkIsdUNBQXdJO0FBQ3hJLG1DQUEwRTtBQUMxRSw2QkFBMEY7QUFDMUYscUNBQXdEO0FBQ3hELCtCQUFzRjtBQUd0Rjs7R0FFRztBQUNILE1BQU0sUUFBUSxHQUFHLGtCQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFFeEM7O0dBRUc7QUFDSCxNQUFhLElBQUk7SUFrSGY7Ozs7Ozs7U0FPSztJQUNMLFlBQVksVUFBaUIsb0JBQVksQ0FBQyxXQUFXLEVBQUUsT0FBYyxTQUFTLEVBQzVFLFlBQTRCLFNBQVMsRUFDckMsVUFBaUIsU0FBUyxFQUMxQixTQUFnQixTQUFTO1FBNUhqQixZQUFPLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVqQyxTQUFJLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUvQixjQUFTLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVuQyxZQUFPLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVsQyxXQUFNLEdBQVUsU0FBUyxDQUFDO1FBRXBDOzthQUVLO1FBQ0wsZUFBVSxHQUFHLEdBRUwsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXJDOztZQUVJO1FBQ0gscUJBQWdCLEdBQUcsR0FBVSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUU5Qzs7YUFFSztRQUNMLFlBQU8sR0FBRyxHQUVGLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBRXJCOzthQUVLO1FBQ0ws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RCwwQkE4d0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVZNQVBJLVVUWE9zXG4gKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlci8nO1xuaW1wb3J0IEJpblRvb2xzIGZyb20gJy4uLy4uL3V0aWxzL2JpbnRvb2xzJztcbmltcG9ydCBCTiBmcm9tIFwiYm4uanNcIjtcbmltcG9ydCB7IE91dHB1dCwgQW1vdW50T3V0cHV0LCBTZWxlY3RPdXRwdXRDbGFzcywgVHJhbnNmZXJhYmxlT3V0cHV0LCBORlRUcmFuc2Zlck91dHB1dCwgTkZUTWludE91dHB1dCwgT3V0cHV0T3duZXJzIH0gZnJvbSAnLi9vdXRwdXRzJztcbmltcG9ydCB7IE1lcmdlUnVsZSwgVW5peE5vdywgQVZNQ29uc3RhbnRzLCBJbml0aWFsU3RhdGVzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBVbnNpZ25lZFR4LCBDcmVhdGVBc3NldFR4LCBPcGVyYXRpb25UeCwgQmFzZVR4LCBFeHBvcnRUeCwgSW1wb3J0VHggfSBmcm9tICcuL3R4JztcbmltcG9ydCB7IFNlY3BJbnB1dCwgVHJhbnNmZXJhYmxlSW5wdXQgfSBmcm9tICcuL2lucHV0cyc7XG5pbXBvcnQgeyBORlRUcmFuc2Zlck9wZXJhdGlvbiwgVHJhbnNmZXJhYmxlT3BlcmF0aW9uLCBORlRNaW50T3BlcmF0aW9uIH0gZnJvbSAnLi9vcHMnO1xuaW1wb3J0IHsgTWludGVyU2V0IH0gZnJvbSBcIi4uLy4uL3V0aWxzL3R5cGVzXCI7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29scyA9IEJpblRvb2xzLmdldEluc3RhbmNlKCk7XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIHNpbmdsZSBVVFhPLlxuICovXG5leHBvcnQgY2xhc3MgVVRYTyB7XG4gIHByb3RlY3RlZCBjb2RlY2lkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyKTtcblxuICBwcm90ZWN0ZWQgdHhpZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIpO1xuXG4gIHByb3RlY3RlZCBvdXRwdXRpZHg6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuXG4gIHByb3RlY3RlZCBhc3NldGlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMik7XG5cbiAgcHJvdGVjdGVkIG91dHB1dDpPdXRwdXQgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29kZWNJRC5cbiAgICAgKi9cbiAgZ2V0Q29kZWNJRCA9ICgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIDpudW1iZXIgPT4gdGhpcy5jb2RlY2lkLnJlYWRVSW50OCgwKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIENvZGVjSURcbiAgICAqL1xuICAgZ2V0Q29kZWNJREJ1ZmZlciA9ICgpOkJ1ZmZlciA9PiB0aGlzLmNvZGVjaWQ7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBUeElELlxuICAgICAqL1xuICBnZXRUeElEID0gKClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgOkJ1ZmZlciA9PiB0aGlzLnR4aWQ7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9ICBvZiB0aGUgT3V0cHV0SWR4LlxuICAgICAqL1xuICBnZXRPdXRwdXRJZHggPSAoKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICA6QnVmZmVyID0+IHRoaXMub3V0cHV0aWR4O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFzc2V0SUQgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfS5cbiAgICAgKi9cbiAgZ2V0QXNzZXRJRCA9ICgpOkJ1ZmZlciA9PiB0aGlzLmFzc2V0aWQ7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVRYT0lEIGFzIGEgYmFzZS01OCBzdHJpbmcgKFVUWE9JRCBpcyBhIHN0cmluZyApXG4gICAgICovXG4gIGdldFVUWE9JRCA9ICgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIDpzdHJpbmcgPT4gYmludG9vbHMuYnVmZmVyVG9CNTgoQnVmZmVyLmNvbmNhdChbdGhpcy5nZXRUeElEKCksIHRoaXMuZ2V0T3V0cHV0SWR4KCldKSk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgb3V0cHV0O1xuICAgICovXG4gIGdldE91dHB1dCA9ICgpOk91dHB1dCA9PiB0aGlzLm91dHB1dDtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgYW4gW1tVVFhPXV0sIHBhcnNlcyBpdCwgcG9wdWxhdGVzIHRoZSBjbGFzcywgYW5kIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgVVRYTyBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgYSByYXcgW1tVVFhPXV1cbiAgICAgKi9cbiAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgIHRoaXMuY29kZWNpZCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDIpO1xuICAgIG9mZnNldCArPSAyO1xuICAgIHRoaXMudHhpZCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDMyKTtcbiAgICBvZmZzZXQgKz0gMzI7XG4gICAgdGhpcy5vdXRwdXRpZHggPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aGlzLmFzc2V0aWQgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyAzMik7XG4gICAgb2Zmc2V0ICs9IDMyO1xuICAgIGNvbnN0IG91dHB1dGlkOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpLnJlYWRVSW50MzJCRSgwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aGlzLm91dHB1dCA9IFNlbGVjdE91dHB1dENsYXNzKG91dHB1dGlkKTtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tVVFhPXV0uXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICBjb25zdCBvdXRidWZmOkJ1ZmZlciA9IHRoaXMub3V0cHV0LnRvQnVmZmVyKCk7XG4gICAgY29uc3Qgb3V0cHV0aWRidWZmZXI6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIG91dHB1dGlkYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5vdXRwdXQuZ2V0T3V0cHV0SUQoKSwgMCk7XG4gICAgY29uc3QgYmFycjpBcnJheTxCdWZmZXI+ID0gW3RoaXMuY29kZWNpZCwgdGhpcy50eGlkLCB0aGlzLm91dHB1dGlkeCwgdGhpcy5hc3NldGlkLCBvdXRwdXRpZGJ1ZmZlciwgb3V0YnVmZl07XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmFyciwgXG4gICAgICB0aGlzLmNvZGVjaWQubGVuZ3RoICsgdGhpcy50eGlkLmxlbmd0aCBcbiAgICAgICsgdGhpcy5vdXRwdXRpZHgubGVuZ3RoICsgdGhpcy5hc3NldGlkLmxlbmd0aFxuICAgICAgKyBvdXRwdXRpZGJ1ZmZlci5sZW5ndGggKyBvdXRidWZmLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICAgKiBUYWtlcyBhIGJhc2UtNTggc3RyaW5nIGNvbnRhaW5pbmcgYW4gW1tVVFhPXV0sIHBhcnNlcyBpdCwgcG9wdWxhdGVzIHRoZSBjbGFzcywgYW5kIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgVVRYTyBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVkIEEgYmFzZS01OCBzdHJpbmcgY29udGFpbmluZyBhIHJhdyBbW1VUWE9dXVxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aCBvZiB0aGUgcmF3IFtbVVRYT11dXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIHVubGlrZSBtb3N0IGZyb21TdHJpbmdzLCBpdCBleHBlY3RzIHRoZSBzdHJpbmcgdG8gYmUgc2VyaWFsaXplZCBpbiBjYjU4IGZvcm1hdFxuICAgICAqL1xuICBmcm9tU3RyaW5nKHNlcmlhbGl6ZWQ6c3RyaW5nKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJpbnRvb2xzLmNiNThEZWNvZGUoc2VyaWFsaXplZCkpO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbVVRYT11dLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiB1bmxpa2UgbW9zdCB0b1N0cmluZ3MsIHRoaXMgcmV0dXJucyBpbiBjYjU4IHNlcmlhbGl6YXRpb24gZm9ybWF0XG4gICAgICovXG4gIHRvU3RyaW5nKCk6c3RyaW5nIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiBiaW50b29scy5jYjU4RW5jb2RlKHRoaXMudG9CdWZmZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgc2luZ2xlIFVUWE8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhpZCBPcHRpb25hbCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvZiB0cmFuc2FjdGlvbiBJRCBmb3IgdGhlIFVUWE9cbiAgICAgKiBAcGFyYW0gdHhpZHggT3B0aW9uYWwge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb3IgbnVtYmVyIGZvciB0aGUgaW5kZXggb2YgdGhlIHRyYW5zYWN0aW9uJ3MgW1tPdXRwdXRdXVxuICAgICAqIEBwYXJhbSBhc3NldGlkIE9wdGlvbmFsIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBhc3NldCBJRCBmb3IgdGhlIFVUWE9cbiAgICAgKiBAcGFyYW0gb3V0cHV0aWQgT3B0aW9uYWwge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb3IgbnVtYmVyIG9mIHRoZSBvdXRwdXQgSUQgZm9yIHRoZSBVVFhPXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKGNvZGVjSUQ6bnVtYmVyID0gQVZNQ29uc3RhbnRzLkxBVEVTVENPREVDLCB0eGlkOkJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBvdXRwdXRpZHg6QnVmZmVyIHwgbnVtYmVyID0gdW5kZWZpbmVkLFxuICAgIGFzc2V0aWQ6QnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG91dHB1dDpPdXRwdXQgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGNvZGVjSUQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB0eGlkICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHR5cGVvZiBvdXRwdXRpZHggIT09ICd1bmRlZmluZWQnXG4gICAgJiYgdHlwZW9mIGFzc2V0aWQgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgdHlwZW9mIG91dHB1dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuY29kZWNpZCAud3JpdGVVSW50OChjb2RlY0lELCAwKTtcbiAgICAgIHRoaXMudHhpZCA9IHR4aWQ7XG4gICAgICBpZiAodHlwZW9mIG91dHB1dGlkeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRpZHgud3JpdGVVSW50MzJCRShvdXRwdXRpZHgsIDApO1xuICAgICAgfSBlbHNlIGlmIChvdXRwdXRpZHggaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRpZHggPSBvdXRwdXRpZHg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gVVRYTy5jb25zdHJ1Y3Rvcjogb3V0cHV0aWR4IHBhcmFtZXRlciBpcyBub3QgYSAnXG4gICAgICAgICsgYG51bWJlciBvciBhIEJ1ZmZlcjogJHtvdXRwdXRpZHh9YCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXRpZCA9IGFzc2V0aWQ7XG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBzZXQgb2YgW1tVVFhPXV1zLlxuICovXG5leHBvcnQgY2xhc3MgVVRYT1NldCB7XG4gIHByb3RlY3RlZCB1dHhvczp7W3V0eG9pZDogc3RyaW5nXTogVVRYTyB9ID0ge307XG5cbiAgcHJvdGVjdGVkIGFkZHJlc3NVVFhPczp7W2FkZHJlc3M6IHN0cmluZ106IHtbdXR4b2lkOiBzdHJpbmddOiBCTn19ID0ge307IC8vIG1hcHMgYWRkcmVzcyB0byB1dHhvaWRzOmxvY2t0aW1lXG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBbW1VUWE9dXSBpcyBpbiB0aGUgVVRYT1NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbVVRYT11dIGEgY2I1OCBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgYSBVVFhPXG4gICAgICovXG4gIGluY2x1ZGVzID0gKHV0eG86VVRYTyB8IHN0cmluZyk6Ym9vbGVhbiA9PiB7XG4gICAgY29uc3QgdXR4b1g6VVRYTyA9IG5ldyBVVFhPKCk7XG4gICAgLy8gZm9yY2UgYSBjb3B5XG4gICAgaWYgKHR5cGVvZiB1dHhvID09PSAnc3RyaW5nJykge1xuICAgICAgdXR4b1guZnJvbUJ1ZmZlcihiaW50b29scy5jYjU4RGVjb2RlKHV0eG8pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXR4b1guZnJvbUJ1ZmZlcih1dHhvLnRvQnVmZmVyKCkpOyAvLyBmb3JjZXMgYSBjb3B5XG4gICAgfVxuICAgIGNvbnN0IHV0eG9pZDpzdHJpbmcgPSB1dHhvWC5nZXRVVFhPSUQoKTtcbiAgICByZXR1cm4gKHV0eG9pZCBpbiB0aGlzLnV0eG9zKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBBZGRzIGEgVVRYTyB0byB0aGUgVVRYT1NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbVVRYT11dIGFuIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVRYT1xuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgdHJ1ZSwgaWYgdGhlIFVUWE9JRCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0Li4uIGRlZmF1bHQgZmFsc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgW1tVVFhPXV0gaWYgb25lIHdhcyBhZGRlZCBhbmQgdW5kZWZpbmVkIGlmIG5vdGhpbmcgd2FzIGFkZGVkLlxuICAgICAqL1xuICBhZGQgPSAodXR4bzpVVFhPIHwgc3RyaW5nLCBvdmVyd3JpdGU6Ym9vbGVhbiA9IGZhbHNlKTpVVFhPID0+IHtcbiAgICBjb25zdCB1dHhvdmFyOlVUWE8gPSBuZXcgVVRYTygpO1xuICAgIC8vIGZvcmNlIGEgY29weVxuICAgIGlmICh0eXBlb2YgdXR4byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHV0eG92YXIuZnJvbUJ1ZmZlcihiaW50b29scy5jYjU4RGVjb2RlKHV0eG8pKTtcbiAgICB9IGVsc2UgaWYgKHV0eG8gaW5zdGFuY2VvZiBVVFhPKSB7XG4gICAgICB1dHhvdmFyLmZyb21CdWZmZXIodXR4by50b0J1ZmZlcigpKTsgLy8gZm9yY2VzIGEgY29weVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAtIFVUWE9TZXQuYWRkOiB1dHhvIHBhcmFtZXRlciBpcyBub3QgYSBVVFhPIG9yIHN0cmluZzogJHt1dHhvfWApO1xuICAgIH1cbiAgICBjb25zdCB1dHhvaWQ6c3RyaW5nID0gdXR4b3Zhci5nZXRVVFhPSUQoKTtcbiAgICBpZiAoISh1dHhvaWQgaW4gdGhpcy51dHhvcykgfHwgb3ZlcndyaXRlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnV0eG9zW3V0eG9pZF0gPSB1dHhvdmFyO1xuXG4gICAgICBjb25zdCBhZGRyZXNzZXM6QXJyYXk8QnVmZmVyPiA9IHV0eG92YXIuZ2V0T3V0cHV0KCkuZ2V0QWRkcmVzc2VzKCk7XG4gICAgICBjb25zdCBsb2NrdGltZTpCTiA9IHV0eG92YXIuZ2V0T3V0cHV0KCkuZ2V0TG9ja3RpbWUoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3M6c3RyaW5nID0gYWRkcmVzc2VzW2ldLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgaWYgKCEoYWRkcmVzcyBpbiB0aGlzLmFkZHJlc3NVVFhPcykpIHtcbiAgICAgICAgICB0aGlzLmFkZHJlc3NVVFhPc1thZGRyZXNzXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc1VUWE9zW2FkZHJlc3NdW3V0eG9pZF0gPSBsb2NrdGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1dHhvdmFyO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIEFkZHMgYW4gYXJyYXkgb2YgW1tVVFhPXV1zIHRvIHRoZSBbW1VUWE9TZXRdXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbVVRYT11dIGFuIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVRYT1xuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgdHJ1ZSwgaWYgdGhlIFVUWE9JRCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0Li4uIGRlZmF1bHQgZmFsc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFVUWE9zIHdoaWNoIHdlcmUgYWRkZWQuXG4gICAgICovXG4gIGFkZEFycmF5ID0gKHV0eG9zOkFycmF5PHN0cmluZyB8IFVUWE8+LCBvdmVyd3JpdGU6Ym9vbGVhbiA9IGZhbHNlKTpBcnJheTxVVFhPPiA9PiB7XG4gICAgY29uc3QgYWRkZWQ6QXJyYXk8VVRYTz4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV0eG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQ6VVRYTyA9IHRoaXMuYWRkKHV0eG9zW2ldLCBvdmVyd3JpdGUpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFkZGVkLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFJlbW92ZXMgYSBbW1VUWE9dXSBmcm9tIHRoZSBbW1VUWE9TZXRdXSBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4byBFaXRoZXIgYSBbW1VUWE9dXSBhbiBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIFVUWE9cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgW1tVVFhPXV0gaWYgaXQgd2FzIHJlbW92ZWQgYW5kIHVuZGVmaW5lZCBpZiBub3RoaW5nIHdhcyByZW1vdmVkLlxuICAgICAqL1xuICByZW1vdmUgPSAodXR4bzpVVFhPIHwgc3RyaW5nKTpVVFhPID0+IHtcbiAgICBjb25zdCB1dHhvdmFyOlVUWE8gPSBuZXcgVVRYTygpO1xuICAgIC8vIGZvcmNlIGEgY29weVxuICAgIGlmICh0eXBlb2YgdXR4byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHV0eG92YXIuZnJvbUJ1ZmZlcihiaW50b29scy5jYjU4RGVjb2RlKHV0eG8pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXR4b3Zhci5mcm9tQnVmZmVyKHV0eG8udG9CdWZmZXIoKSk7IC8vIGZvcmNlcyBhIGNvcHlcbiAgICB9XG4gICAgY29uc3QgdXR4b2lkOnN0cmluZyA9IHV0eG92YXIuZ2V0VVRYT0lEKCk7XG4gICAgaWYgKCEodXR4b2lkIGluIHRoaXMudXR4b3MpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy51dHhvc1t1dHhvaWRdO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IE9iamVjdC5rZXlzKHRoaXMuYWRkcmVzc1VUWE9zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHV0eG9pZCBpbiB0aGlzLmFkZHJlc3NVVFhPc1thZGRyZXNzZXNbaV1dKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFkZHJlc3NVVFhPc1thZGRyZXNzZXNbaV1dW3V0eG9pZF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1dHhvdmFyO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gYXJyYXkgb2YgW1tVVFhPXV1zIHRvIHRoZSBbW1VUWE9TZXRdXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbVVRYT11dIGFuIGNiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIGEgVVRYT1xuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgdHJ1ZSwgaWYgdGhlIFVUWE9JRCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0Li4uIGRlZmF1bHQgZmFsc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFVUWE9zIHdoaWNoIHdlcmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgcmVtb3ZlQXJyYXkgPSAodXR4b3M6QXJyYXk8c3RyaW5nIHwgVVRYTz4pOkFycmF5PFVUWE8+ID0+IHtcbiAgICBjb25zdCByZW1vdmVkOkFycmF5PFVUWE8+ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dHhvcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0OlVUWE8gPSB0aGlzLnJlbW92ZSh1dHhvc1tpXSk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIEdldHMgYSBbW1VUWE9dXSBmcm9tIHRoZSBbW1VUWE9TZXRdXSBieSBpdHMgVVRYT0lELlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9pZCBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBVVFhPSURcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgW1tVVFhPXV0gaWYgaXQgZXhpc3RzIGluIHRoZSBzZXQuXG4gICAgICovXG4gIGdldFVUWE8gPSAodXR4b2lkOnN0cmluZyk6VVRYTyA9PiB0aGlzLnV0eG9zW3V0eG9pZF07XG5cbiAgLyoqXG4gICAgICogR2V0cyBhbGwgdGhlIFtbVVRYT11dcywgb3B0aW9uYWxseSB0aGF0IG1hdGNoIHdpdGggVVRYT0lEcyBpbiBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9pZHMgQW4gb3B0aW9uYWwgYXJyYXkgb2YgVVRYT0lEcywgcmV0dXJucyBhbGwgW1tVVFhPXV1zIGlmIG5vdCBwcm92aWRlZFxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgW1tVVFhPXV1zLlxuICAgICAqL1xuICBnZXRBbGxVVFhPcyA9ICh1dHhvaWRzOkFycmF5PHN0cmluZz4gPSB1bmRlZmluZWQpOkFycmF5PFVUWE8+ID0+IHtcbiAgICBsZXQgcmVzdWx0czpBcnJheTxVVFhPPiA9IFtdO1xuICAgIGlmICh0eXBlb2YgdXR4b2lkcyAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh1dHhvaWRzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dHhvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1dHhvaWRzW2ldIGluIHRoaXMudXR4b3MgJiYgISh1dHhvaWRzW2ldIGluIHJlc3VsdHMpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudXR4b3NbdXR4b2lkc1tpXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSBPYmplY3QudmFsdWVzKHRoaXMudXR4b3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgW1tVVFhPXV1zIGFzIHN0cmluZ3MsIG9wdGlvbmFsbHkgdGhhdCBtYXRjaCB3aXRoIFVUWE9JRHMgaW4gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b2lkcyBBbiBvcHRpb25hbCBhcnJheSBvZiBVVFhPSURzLCByZXR1cm5zIGFsbCBbW1VUWE9dXXMgaWYgbm90IHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBbW1VUWE9dXXMgYXMgY2I1OCBzZXJpYWxpemVkIHN0cmluZ3MuXG4gICAgICovXG4gIGdldEFsbFVUWE9TdHJpbmdzID0gKHV0eG9pZHM6QXJyYXk8c3RyaW5nPiA9IHVuZGVmaW5lZCk6QXJyYXk8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcmVzdWx0czpBcnJheTxzdHJpbmc+ID0gW107XG4gICAgY29uc3QgdXR4b3MgPSBPYmplY3Qua2V5cyh0aGlzLnV0eG9zKTtcbiAgICBpZiAodHlwZW9mIHV0eG9pZHMgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkodXR4b2lkcykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXR4b2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodXR4b2lkc1tpXSBpbiB0aGlzLnV0eG9zKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudXR4b3NbdXR4b2lkc1tpXV0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCB1IG9mIHV0eG9zKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnV0eG9zW3VdLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICAgKiBHaXZlbiBhbiBhZGRyZXNzIG9yIGFycmF5IG9mIGFkZHJlc3NlcywgcmV0dXJucyBhbGwgdGhlIFVUWE9JRHMgZm9yIHRob3NlIGFkZHJlc3Nlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgQW4gYXJyYXkgb2YgYWRkcmVzcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfXNcbiAgICAgKiBAcGFyYW0gc3BlbmRhYmxlIElmIHRydWUsIG9ubHkgcmV0cmlldmVzIFVUWE9JRHMgd2hvc2UgbG9ja3RpbWUgaGFzIHBhc3NlZFxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzLlxuICAgICAqL1xuICBnZXRVVFhPSURzID0gKGFkZHJlc3NlczpBcnJheTxCdWZmZXI+ID0gdW5kZWZpbmVkLCBzcGVuZGFibGU6Ym9vbGVhbiA9IHRydWUpOkFycmF5PHN0cmluZz4gPT4ge1xuICAgIGlmICh0eXBlb2YgYWRkcmVzc2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgcmVzdWx0czpBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICBjb25zdCBub3c6Qk4gPSBVbml4Tm93KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYWRkcmVzc2VzW2ldLnRvU3RyaW5nKCdoZXgnKSBpbiB0aGlzLmFkZHJlc3NVVFhPcykge1xuICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLmFkZHJlc3NVVFhPc1thZGRyZXNzZXNbaV0udG9TdHJpbmcoJ2hleCcpXSk7XG4gICAgICAgICAgZm9yIChjb25zdCBbdXR4b2lkLCBsb2NrdGltZV0gb2YgZW50cmllcykge1xuICAgICAgICAgICAgaWYgKChyZXN1bHRzLmluZGV4T2YodXR4b2lkKSA9PT0gLTFcbiAgICAgICAgICAgICYmIChzcGVuZGFibGUgJiYgbG9ja3RpbWUubHRlKG5vdykpKVxuICAgICAgICAgICAgfHwgIXNwZW5kYWJsZSkge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godXR4b2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy51dHhvcyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogR2V0cyB0aGUgYWRkcmVzc2VzIGluIHRoZSBbW1VUWE9TZXRdXSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfS5cbiAgICAgKi9cbiAgZ2V0QWRkcmVzc2VzID0gKCk6QXJyYXk8QnVmZmVyPiA9PiBPYmplY3Qua2V5cyh0aGlzLmFkZHJlc3NVVFhPcylcbiAgICAubWFwKChrKSA9PiBCdWZmZXIuZnJvbShrLCAnaGV4JykpO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJhbGFuY2Ugb2YgYSBzZXQgb2YgYWRkcmVzc2VzIGluIHRoZSBVVFhPU2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0gYXNzZXRJRCBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhbiBjYjU4IHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gQXNzZXRJRFxuICAgICAqIEBwYXJhbSBhc09mIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHRvdGFsIGJhbGFuY2UgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfS5cbiAgICAgKi9cbiAgZ2V0QmFsYW5jZSA9IChhZGRyZXNzZXM6QXJyYXk8QnVmZmVyPiwgYXNzZXRJRDpCdWZmZXJ8c3RyaW5nLCBhc09mOkJOID0gdW5kZWZpbmVkKTpCTiA9PiB7XG4gICAgY29uc3QgdXR4b2lkczpBcnJheTxzdHJpbmc+ID0gdGhpcy5nZXRVVFhPSURzKGFkZHJlc3Nlcyk7XG4gICAgY29uc3QgdXR4b3M6QXJyYXk8VVRYTz4gPSB0aGlzLmdldEFsbFVUWE9zKHV0eG9pZHMpO1xuICAgIGxldCBzcGVuZDpCTiA9IG5ldyBCTigwKTtcbiAgICBsZXQgYXNzZXQ6QnVmZmVyO1xuICAgIGlmICh0eXBlb2YgYXNzZXRJRCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGFzc2V0ID0gYmludG9vbHMuY2I1OERlY29kZShhc3NldElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXQgPSBhc3NldElEO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV0eG9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodXR4b3NbaV0uZ2V0T3V0cHV0KCkgaW5zdGFuY2VvZiBBbW91bnRPdXRwdXRcbiAgICAgICYmIHV0eG9zW2ldLmdldEFzc2V0SUQoKS50b1N0cmluZygnaGV4JykgPT09IGFzc2V0LnRvU3RyaW5nKCdoZXgnKVxuICAgICAgJiYgdXR4b3NbaV0uZ2V0T3V0cHV0KCkubWVldHNUaHJlc2hvbGQoYWRkcmVzc2VzLCBhc09mKSkge1xuICAgICAgICBzcGVuZCA9IHNwZW5kLmFkZCgodXR4b3NbaV0uZ2V0T3V0cHV0KCkgYXMgQW1vdW50T3V0cHV0KS5nZXRBbW91bnQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVuZDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgQXNzZXQgSURzLCBvcHRpb25hbGx5IHRoYXQgbWF0Y2ggd2l0aCBBc3NldCBJRHMgaW4gYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvaWRzIEFuIG9wdGlvbmFsIGFycmF5IG9mIEFkZHJlc3NlcyBhcyBzdHJpbmcgb3IgQnVmZmVyLCByZXR1cm5zIGFsbCBBc3NldCBJRHMgaWYgbm90IHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEFzc2V0IElEcy5cbiAgICAgKi9cbiAgZ2V0QXNzZXRJRHMgPSAoYWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4gPSB1bmRlZmluZWQpOkFycmF5PEJ1ZmZlcj4gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6U2V0PEJ1ZmZlcj4gPSBuZXcgU2V0KCk7XG4gICAgbGV0IHV0eG9pZHM6QXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgIGlmICh0eXBlb2YgYWRkcmVzc2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdXR4b2lkcyA9IHRoaXMuZ2V0VVRYT0lEcyhhZGRyZXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dHhvaWRzID0gdGhpcy5nZXRVVFhPSURzKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dHhvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodXR4b2lkc1tpXSBpbiB0aGlzLnV0eG9zICYmICEodXR4b2lkc1tpXSBpbiByZXN1bHRzKSkge1xuICAgICAgICByZXN1bHRzLmFkZCh0aGlzLnV0eG9zW3V0eG9pZHNbaV1dLmdldEFzc2V0SUQoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFsuLi5yZXN1bHRzXTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIFtbVW5zaWduZWRUeF1dIHdyYXBwaW5nIGEgW1tCYXNlVHhdXS4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAgKiBbW1Vuc2lnbmVkVHhdXSB3cmFwcGluZyBhIFtbQmFzZVR4XV0gbWFudWFsbHkgKHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBbW1RyYW5zZmVyYWJsZUlucHV0XV1zIGFuZCBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya2lkIFRoZSBudW1iZXIgcmVwcmVzZW50aW5nIE5ldHdvcmtJRCBvZiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSBibG9ja2NoYWluaWQgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgQmxvY2tjaGFpbklEIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhbW91bnQgb2YgQVZBWCB0byBiZSBzcGVudCBpbiAkbkFWQVhcbiAgICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBmdW5kc1xuICAgICAqIEBwYXJhbSBmcm9tQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPc1xuICAgICAqIEBwYXJhbSBhc3NldGlkIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBhc3NldCBJRCBmb3IgdGhlIFVUWE9cbiAgICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAgICogQHBhcmFtIGxvY2t0aW1lIE9wdGlvbmFsLiBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIG91dHB1dHNcbiAgICAgKiBAcGFyYW0gdGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgVVRYT1xuICAgICAqIEBwYXJhbSBvdXRwdXRJRCBPcHRpb25hbC4gVGhlIG91dHB1dElEIHVzZWQgZm9yIHRoaXMgdHJhbnNhY3Rpb24sIG11c3QgaW1wbGVtZW50IEFtb3VudE91dHB1dCwgZGVmYXVsdCBBVk1Db25zdGFudHMuU0VDUE9VVFBVVElEXG4gICAgICogXG4gICAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqL1xuICBidWlsZEJhc2VUeCA9IChcbiAgICBuZXR3b3JraWQ6bnVtYmVyLFxuICAgIGJsb2NrY2hhaW5pZDpCdWZmZXIsXG4gICAgYW1vdW50OkJOLFxuICAgIHRvQWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4sXG4gICAgZnJvbUFkZHJlc3NlczpBcnJheTxCdWZmZXI+LFxuICAgIGNoYW5nZUFkZHJlc3NlczpBcnJheTxCdWZmZXI+LFxuICAgIGFzc2V0SUQ6QnVmZmVyLFxuICAgIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIGFzT2Y6Qk4gPSBVbml4Tm93KCksXG4gICAgbG9ja3RpbWU6Qk4gPSBuZXcgQk4oMCksXG4gICAgdGhyZXNob2xkOm51bWJlciA9IDEsXG4gICAgb3V0cHV0SUQgPSBBVk1Db25zdGFudHMuU0VDUE9VVFBVVElEXG4gICk6VW5zaWduZWRUeCA9PiB7XG4gICAgY29uc3QgemVybzpCTiA9IG5ldyBCTigwKTtcbiAgICBsZXQgc3BlbmRhbW91bnQ6Qk4gPSB6ZXJvLmNsb25lKCk7XG4gICAgY29uc3QgdXR4b3M6QXJyYXk8VVRYTz4gPSB0aGlzLmdldEFsbFVUWE9zKHRoaXMuZ2V0VVRYT0lEcyhmcm9tQWRkcmVzc2VzKSk7XG4gICAgbGV0IGNoYW5nZTpCTiA9IHplcm8uY2xvbmUoKTtcblxuICAgIGNvbnN0IG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IFtdO1xuICAgIGNvbnN0IGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSBbXTtcbiAgICBpZiAoIShTZWxlY3RPdXRwdXRDbGFzcyhvdXRwdXRJRCkgaW5zdGFuY2VvZiBBbW91bnRPdXRwdXQpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIFVUWE9TZXQuYnVpbGRCYXNlVHg6IG91dHB1dElEIGRvZXMgbm90ICdcbiAgICAgICsgYGltcGxlbWVudCBBbW91bnRPdXRwdXQ6ICR7b3V0cHV0SUR9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFhbW91bnQuZXEoemVybykpIHtcbiAgICAgIGNvbnN0IHNuZG91dDpBbW91bnRPdXRwdXQgPSBTZWxlY3RPdXRwdXRDbGFzcyhvdXRwdXRJRCxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICB0b0FkZHJlc3NlcyxcbiAgICAgICAgbG9ja3RpbWUsXG4gICAgICAgIHRocmVzaG9sZCkgYXMgQW1vdW50T3V0cHV0O1xuICAgICAgY29uc3QgbWFpblhmZXJvdXQ6VHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dChhc3NldElELCBzbmRvdXQpO1xuICAgICAgb3V0cy5wdXNoKG1haW5YZmVyb3V0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXR4b3MubGVuZ3RoICYmIHNwZW5kYW1vdW50Lmx0KGFtb3VudCk7IGkrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdXR4b3NbaV0uZ2V0T3V0cHV0KCkgaW5zdGFuY2VvZiBBbW91bnRPdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgIGFzc2V0SUQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgdXR4b3NbaV0uZ2V0QXNzZXRJRCgpLmNvbXBhcmUoYXNzZXRJRCkgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAmJiB1dHhvc1tpXS5nZXRPdXRwdXQoKS5tZWV0c1RocmVzaG9sZChmcm9tQWRkcmVzc2VzLCBhc09mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBvdXRwdXQ6QW1vdW50T3V0cHV0ID0gdXR4b3NbaV0uZ2V0T3V0cHV0KCkgYXMgQW1vdW50T3V0cHV0O1xuICAgICAgICAgIGNvbnN0IGFtdDpCTiA9IG91dHB1dC5nZXRBbW91bnQoKS5jbG9uZSgpO1xuICAgICAgICAgIHNwZW5kYW1vdW50ID0gc3BlbmRhbW91bnQuYWRkKGFtdCk7XG4gICAgICAgICAgY2hhbmdlID0gc3BlbmRhbW91bnQuc3ViKGFtb3VudCk7XG4gICAgICAgICAgY2hhbmdlID0gY2hhbmdlLmd0KHplcm8pID8gY2hhbmdlIDogemVyby5jbG9uZSgpO1xuXG4gICAgICAgICAgY29uc3QgdHhpZDpCdWZmZXIgPSB1dHhvc1tpXS5nZXRUeElEKCk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0aWR4OkJ1ZmZlciA9IHV0eG9zW2ldLmdldE91dHB1dElkeCgpO1xuICAgICAgICAgIGNvbnN0IGlucHV0OlNlY3BJbnB1dCA9IG5ldyBTZWNwSW5wdXQoYW10KTtcbiAgICAgICAgICBjb25zdCB4ZmVyaW46VHJhbnNmZXJhYmxlSW5wdXQgPSBuZXcgVHJhbnNmZXJhYmxlSW5wdXQodHhpZCwgb3V0cHV0aWR4LCBhc3NldElELCBpbnB1dCk7XG4gICAgICAgICAgY29uc3Qgc3BlbmRlcnM6QXJyYXk8QnVmZmVyPiA9IG91dHB1dC5nZXRTcGVuZGVycyhmcm9tQWRkcmVzc2VzLCBhc09mKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwZW5kZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBpZHg6bnVtYmVyID0gb3V0cHV0LmdldEFkZHJlc3NJZHgoc3BlbmRlcnNbal0pO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIFVUWE9TZXQuYnVpbGRCYXNlVHg6IG5vIHN1Y2ggJ1xuICAgICAgICAgICAgICArIGBhZGRyZXNzIGluIG91dHB1dDogJHtzcGVuZGVyc1tqXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhmZXJpbi5nZXRJbnB1dCgpLmFkZFNpZ25hdHVyZUlkeChpZHgsIHNwZW5kZXJzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zLnB1c2goeGZlcmluKTtcblxuICAgICAgICAgIGlmIChjaGFuZ2UuZ3QoemVybykpIHtcbiAgICAgICAgICAgIGlmIChhc3NldElEKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNoYW5nZW91dDpBbW91bnRPdXRwdXQgPSBTZWxlY3RPdXRwdXRDbGFzcyhvdXRwdXRJRCxcbiAgICAgICAgICAgICAgICBjaGFuZ2UsIGNoYW5nZUFkZHJlc3NlcywgemVyby5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIDEpIGFzIEFtb3VudE91dHB1dDtcbiAgICAgICAgICAgICAgY29uc3QgeGZlcm91dDpUcmFuc2ZlcmFibGVPdXRwdXQgPSBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KGFzc2V0SUQsIGNoYW5nZW91dCk7XG4gICAgICAgICAgICAgIG91dHMucHVzaCh4ZmVyb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGlmIChzcGVuZGFtb3VudC5ndGUoYW1vdW50KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVuZGFtb3VudC5sdChhbW91bnQpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBVVFhPU2V0LmJ1aWxkQmFzZVR4OiBpbnN1ZmZpY2llbnQgJ1xuICAgICAgICArICdmdW5kcyB0byBjcmVhdGUgdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJhc2VUeDpCYXNlVHggPSBuZXcgQmFzZVR4KG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8pO1xuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChiYXNlVHgpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb24uIEZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wsIHlvdSBtYXkgY3JlYXRlIHlvdXIgb3duXG4gICAgICogW1tDcmVhdGVBc3NldFRYXV0gbWFudWFsbHkgKHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBbW1RyYW5zZmVyYWJsZUlucHV0XV1zLCBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcykuXG4gICAgICogXG4gICAgICogQHBhcmFtIG5ldHdvcmtpZCBUaGUgbnVtYmVyIHJlcHJlc2VudGluZyBOZXR3b3JrSUQgb2YgdGhlIG5vZGVcbiAgICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIFRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEJsb2NrY2hhaW5JRCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGF2YXhBc3NldElkIFRoZSBBVkFYIEFzc2V0IElEXG4gICAgICogQHBhcmFtIGZlZSBUaGUgYW1vdW50IG9mIEFWQVggdG8gYmUgcGFpZCBmb3IgZmVlcywgaW4gJG5BVkFYXG4gICAgICogQHBhcmFtIGZlZVNlbmRlckFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRvIHNlbmQgdGhlIGZlZXNcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBbW0luaXRpYWxTdGF0ZXNdXSB0aGF0IHJlcHJlc2VudCB0aGUgaW50aWFsIHN0YXRlIG9mIGEgY3JlYXRlZCBhc3NldFxuICAgICAqIEBwYXJhbSBuYW1lIFN0cmluZyBmb3IgdGhlIGRlc2NyaXB0aXZlIG5hbWUgb2YgdGhlIGFzc2V0XG4gICAgICogQHBhcmFtIHN5bWJvbCBTdHJpbmcgZm9yIHRoZSB0aWNrZXIgc3ltYm9sIG9mIHRoZSBhc3NldFxuICAgICAqIEBwYXJhbSBkZW5vbWluYXRpb24gT3B0aW9uYWwgbnVtYmVyIGZvciB0aGUgZGVub21pbmF0aW9uIHdoaWNoIGlzIDEwXkQuIEQgbXVzdCBiZSA+PSAwIGFuZCA8PSAzMi4gRXg6ICQxIEFWQVggPSAxMF45ICRuQVZBWFxuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKi9cbiAgYnVpbGRDcmVhdGVBc3NldFR4ID0gKFxuICAgICAgbmV0d29ya2lkOm51bWJlciwgYmxvY2tjaGFpbmlkOkJ1ZmZlciwgYXZheEFzc2V0SUQ6QnVmZmVyLCBcbiAgICAgIGZlZTpCTiwgZmVlU2VuZGVyQWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4sIFxuICAgICAgaW5pdGlhbFN0YXRlOkluaXRpYWxTdGF0ZXMsIG5hbWU6c3RyaW5nLCBcbiAgICAgIHN5bWJvbDpzdHJpbmcsIGRlbm9taW5hdGlvbjpudW1iZXIsIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBhc09mOkJOID0gVW5peE5vdygpXG4gICk6VW5zaWduZWRUeCA9PiB7XG4gICAgICAvLyBDaGVhdGluZyBhbmQgdXNpbmcgYnVpbGRCYXNlVHggdG8gZ2V0IElucyBhbmQgT3V0cyBmb3IgZmVlcy5cbiAgICAgIC8vIEZlZXMgYXJlIGJ1cm5lZCwgc28gbm8gdG9BZGRyZXNzZXMsIG9ubHkgZnJvbUFkZHJlc3NlcyBhbmQgY2hhbmdlQWRkcmVzc2VzLCBib3RoIGFyZSB0aGUgZmVlU2VuZGVyQWRkcmVzc2VzXG4gICAgICBsZXQgdXR4OlVuc2lnbmVkVHggPSB0aGlzLmJ1aWxkQmFzZVR4KG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBmZWUsIFtdLCBmZWVTZW5kZXJBZGRyZXNzZXMsIGZlZVNlbmRlckFkZHJlc3NlcywgYXZheEFzc2V0SUQsIHVuZGVmaW5lZCwgYXNPZik7XG4gICAgICBsZXQgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHV0eC5nZXRUcmFuc2FjdGlvbigpLmdldElucygpO1xuICAgICAgbGV0IG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHV0eC5nZXRUcmFuc2FjdGlvbigpLmdldE91dHMoKTtcbiAgICAgIGxldCBDQXR4OkNyZWF0ZUFzc2V0VHggPSBuZXcgQ3JlYXRlQXNzZXRUeChuZXR3b3JraWQsIGJsb2NrY2hhaW5pZCwgb3V0cywgaW5zLCBtZW1vLCBuYW1lLCBzeW1ib2wsIGRlbm9taW5hdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChDQXR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uLiBGb3IgbW9yZSBncmFudWxhciBjb250cm9sLCB5b3UgbWF5IGNyZWF0ZSB5b3VyIG93blxuICAgICogW1tDcmVhdGVBc3NldFRYXV0gbWFudWFsbHkgKHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBbW1RyYW5zZmVyYWJsZUlucHV0XV1zLCBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcykuXG4gICAgKiBcbiAgICAqIEBwYXJhbSBuZXR3b3JraWQgVGhlIG51bWJlciByZXByZXNlbnRpbmcgTmV0d29ya0lEIG9mIHRoZSBub2RlXG4gICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIFRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEJsb2NrY2hhaW5JRCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgKiBAcGFyYW0gYXZheEFzc2V0SWQgVGhlIEFWQVggQXNzZXQgSURcbiAgICAqIEBwYXJhbSBmZWUgVGhlIGFtb3VudCBvZiBBVkFYIHRvIGJlIHBhaWQgZm9yIGZlZXMsIGluICRuQVZBWFxuICAgICogQHBhcmFtIGZlZVBheWluZ0FkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRvIHBheSB0aGUgZmVlc1xuICAgICogQHBhcmFtIG1pbnRlclNldHMgVGhlIG1pbnRlcnMgYW5kIHRocmVzaG9sZHMgcmVxdWlyZWQgdG8gbWludCB0aGlzIG5mdCBhc3NldFxuICAgICogQHBhcmFtIG5hbWUgU3RyaW5nIGZvciB0aGUgZGVzY3JpcHRpdmUgbmFtZSBvZiB0aGUgbmZ0IGFzc2V0XG4gICAgKiBAcGFyYW0gc3ltYm9sIFN0cmluZyBmb3IgdGhlIHRpY2tlciBzeW1ib2wgb2YgdGhlIG5mdCBhc3NldFxuICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAgKiBAcGFyYW0gbG9ja3RpbWUgT3B0aW9uYWwuIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgbWludCBvdXRwdXRcbiAgICAqIFxuICAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICAqIFxuICAgICovXG4gIGJ1aWxkQ3JlYXRlTkZUQXNzZXRUeCA9IChcbiAgICAgIG5ldHdvcmtpZDpudW1iZXIsIGJsb2NrY2hhaW5pZDpCdWZmZXIsIGF2YXhBc3NldElEOkJ1ZmZlciwgXG4gICAgICBmZWU6Qk4sIGZlZVBheWluZ0FkZHJlc3NlczpBcnJheTxCdWZmZXI+LCBcbiAgICAgIG1pbnRlclNldHM6QXJyYXk8TWludGVyU2V0PixcbiAgICAgIG5hbWU6c3RyaW5nLCBzeW1ib2w6c3RyaW5nLCBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgYXNPZjpCTiA9IFVuaXhOb3coKSxcbiAgICAgIGxvY2t0aW1lOkJOID0gdW5kZWZpbmVkXG4gICk6VW5zaWduZWRUeCA9PiB7XG4gICAgICBsZXQgaW5pdGlhbFN0YXRlOkluaXRpYWxTdGF0ZXMgPSBuZXcgSW5pdGlhbFN0YXRlcygpO1xuICAgICAgbGV0IHV0eDpVbnNpZ25lZFR4ID0gdGhpcy5idWlsZEJhc2VUeChuZXR3b3JraWQsIGJsb2NrY2hhaW5pZCwgZmVlLCBbXSwgZmVlUGF5aW5nQWRkcmVzc2VzLCBmZWVQYXlpbmdBZGRyZXNzZXMsIGF2YXhBc3NldElELCB1bmRlZmluZWQsIGFzT2YpO1xuICAgICAgbGV0IGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB1dHguZ2V0VHJhbnNhY3Rpb24oKS5nZXRJbnMoKTtcbiAgICAgIGxldCBvdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSB1dHguZ2V0VHJhbnNhY3Rpb24oKS5nZXRPdXRzKCk7XG4gICAgICBmb3IobGV0IGk6bnVtYmVyID0gMDsgaSA8IG1pbnRlclNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5mdE1pbnRPdXRwdXQ6TkZUTWludE91dHB1dCA9IG5ldyBORlRNaW50T3V0cHV0KFxuICAgICAgICAgIGksXG4gICAgICAgICAgbWludGVyU2V0c1tpXS5nZXRNaW50ZXJzKCksXG4gICAgICAgICAgbG9ja3RpbWUsIFxuICAgICAgICAgIG1pbnRlclNldHNbaV0uZ2V0VGhyZXNob2xkKClcbiAgICAgICAgICApO1xuICAgICAgICBpbml0aWFsU3RhdGUuYWRkT3V0cHV0KG5mdE1pbnRPdXRwdXQsIEFWTUNvbnN0YW50cy5ORlRGWElEKTtcbiAgICAgIH1cbiAgICAgIGxldCBkZW5vbWluYXRpb246bnVtYmVyID0gMDsgLy8gTkZUcyBhcmUgbm9uLWZ1bmdpYmxlXG4gICAgICBsZXQgQ0F0eDpDcmVhdGVBc3NldFR4ID0gbmV3IENyZWF0ZUFzc2V0VHgobmV0d29ya2lkLCBibG9ja2NoYWluaWQsIG91dHMsIGlucywgbWVtbywgbmFtZSwgc3ltYm9sLCBkZW5vbWluYXRpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgICByZXR1cm4gbmV3IFVuc2lnbmVkVHgoQ0F0eCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB1bnNpZ25lZCBORlQgbWludCB0cmFuc2FjdGlvbi4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAqIFtbTkZUTWludFR4XV0gbWFudWFsbHkgKHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBbW1RyYW5zZmVyYWJsZUlucHV0XV1zLCBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcywgYW5kIFtbVHJhbnNmZXJPcGVyYXRpb25dXXMpLlxuICAgICogXG4gICAgKiBAcGFyYW0gbmV0d29ya2lkIFRoZSBudW1iZXIgcmVwcmVzZW50aW5nIE5ldHdvcmtJRCBvZiB0aGUgbm9kZVxuICAgICogQHBhcmFtIGJsb2NrY2hhaW5pZCBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBCbG9ja2NoYWluSUQgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgICogQHBhcmFtIGZlZUFzc2V0SUQgVGhlIGFzc2V0SUQgZm9yIHRoZSBBVkFYIGZlZSB0byBiZSBwYWlkXG4gICAgKiBAcGFyYW0gZmVlIFRoZSBhbW91bnQgb2YgQVZBWCB0byBiZSBwYWlkIGZvciBmZWVzLCBpbiAkbkFWQVhcbiAgICAqIEBwYXJhbSBmZWVTZW5kZXJBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBmZWVzXG4gICAgKiBAcGFyYW0gb3V0cHV0T3duZXJzOkFycmF5IEFuIGFycmF5IG9mIE91dHB1dE93bmVyc1xuICAgICogQHBhcmFtIGZyb21BZGRyZXNzZXMgQW4gYXJyYXkgZm9yIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyBvd25zIHRoZSBORlRcbiAgICAqIEBwYXJhbSB1dHhvaWRzIEFuIGFycmF5IG9mIHN0cmluZ3MgZm9yIHRoZSBORlRzIGJlaW5nIHRyYW5zZmVycmVkXG4gICAgKiBAcGFyYW0gZ3JvdXBJRCBPcHRpb25hbC4gVGhlIGdyb3VwIHRoaXMgTkZUIGlzIGlzc3VlZCB0by5cbiAgICAqIEBwYXJhbSBwYXlsb2FkIE9wdGlvbmFsLiBEYXRhIGZvciBORlQgUGF5bG9hZC5cbiAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgICogQHBhcmFtIGxvY2t0aW1lIE9wdGlvbmFsLiBUaGUgbG9ja3RpbWUgZmllbGQgY3JlYXRlZCBpbiB0aGUgcmVzdWx0aW5nIG1pbnQgb3V0cHV0XG4gICAgKiBAcGFyYW0gdGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgVVRYT1xuICAgICogXG4gICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgICogXG4gICAgKi9cbiAgYnVpbGRDcmVhdGVORlRNaW50VHggPSAoXG4gICAgbmV0d29ya2lkOm51bWJlciwgYmxvY2tjaGFpbmlkOkJ1ZmZlciwgZmVlQXNzZXRJRDpCdWZmZXIsIGZlZTpCTiwgXG4gICAgICBmZWVTZW5kZXJBZGRyZXNzZXM6QXJyYXk8QnVmZmVyPiwgdG86QXJyYXk8QnVmZmVyPiwgZnJvbUFkZHJlc3NlczpBcnJheTxCdWZmZXI+LCBcbiAgICAgIHV0eG9pZHM6QXJyYXk8c3RyaW5nPiwgZ3JvdXBJRDpudW1iZXIgPSAwLCBwYXlsb2FkOkJ1ZmZlciA9IHVuZGVmaW5lZCwgbWVtbzpCdWZmZXIgPSB1bmRlZmluZWQsXG4gICAgICBhc09mOkJOID0gVW5peE5vdygpLCBsb2NrdGltZTpCTiwgdGhyZXNob2xkOm51bWJlciA9IDEgXG4gICk6VW5zaWduZWRUeCA9PiB7XG4gICAgICBsZXQgdXR4OlVuc2lnbmVkVHggPSB0aGlzLmJ1aWxkQmFzZVR4KG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBmZWUsIFtdLCBmZWVTZW5kZXJBZGRyZXNzZXMsIGZlZVNlbmRlckFkZHJlc3NlcywgZmVlQXNzZXRJRCwgdW5kZWZpbmVkLCBhc09mKTtcbiAgICAgIGxldCBpbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+ID0gdXR4LmdldFRyYW5zYWN0aW9uKCkuZ2V0SW5zKCk7XG4gICAgICBsZXQgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdXR4LmdldFRyYW5zYWN0aW9uKCkuZ2V0T3V0cygpO1xuICAgICAgbGV0IG9wczpUcmFuc2ZlcmFibGVPcGVyYXRpb25bXSA9IFtdO1xuXG4gICAgICBpZih0aHJlc2hvbGQgPiB0by5sZW5ndGgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgLSBVVFhPU2V0LmJ1aWxkQ3JlYXRlTkZUTWludFR4OiB0aHJlc2hvbGQgaXMgZ3JlYXRlciB0aGFuIG51bWJlciBvZiBhZGRyZXNzZXNgKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZnRNaW50T3BlcmF0aW9uOiBORlRNaW50T3BlcmF0aW9uID0gbmV3IE5GVE1pbnRPcGVyYXRpb24oZ3JvdXBJRCwgcGF5bG9hZCwgW25ldyBPdXRwdXRPd25lcnModG8sIGxvY2t0aW1lLCB0aHJlc2hvbGQpXSk7XG5cbiAgICAgIGZvcihsZXQgaTpudW1iZXIgPSAwOyBpIDwgdXR4b2lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCB1dHhvOlVUWE8gPSB0aGlzLmdldFVUWE8odXR4b2lkc1tpXSk7XG4gICAgICAgICAgbGV0IG91dDpORlRUcmFuc2Zlck91dHB1dCA9IHV0eG8uZ2V0T3V0cHV0KCkgYXMgTkZUVHJhbnNmZXJPdXRwdXQ7XG4gICAgICAgICAgbGV0IHNwZW5kZXJzOkFycmF5PEJ1ZmZlcj4gPSBvdXQuZ2V0U3BlbmRlcnMoZnJvbUFkZHJlc3NlcywgYXNPZik7XG5cbiAgICAgICAgICBmb3IobGV0IGo6bnVtYmVyID0gMDsgaiA8IHNwZW5kZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGxldCBpZHg6bnVtYmVyO1xuICAgICAgICAgICAgICBpZHggPSBvdXQuZ2V0QWRkcmVzc0lkeChzcGVuZGVyc1tqXSk7XG4gICAgICAgICAgICAgIGlmKGlkeCA9PSAtMSl7XG4gICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAtIFVUWE9TZXQuYnVpbGRDcmVhdGVORlRNaW50VHg6IG5vIHN1Y2ggYWRkcmVzcyBpbiBvdXRwdXQ6ICR7c3BlbmRlcnNbal19YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmZ0TWludE9wZXJhdGlvbi5hZGRTaWduYXR1cmVJZHgoaWR4LCBzcGVuZGVyc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgbGV0IHRyYW5zZmVyYWJsZU9wZXJhdGlvbjpUcmFuc2ZlcmFibGVPcGVyYXRpb24gPSBuZXcgVHJhbnNmZXJhYmxlT3BlcmF0aW9uKHV0eG8uZ2V0QXNzZXRJRCgpLCB1dHhvaWRzLCBuZnRNaW50T3BlcmF0aW9uKTtcbiAgICAgICAgICBvcHMucHVzaCh0cmFuc2ZlcmFibGVPcGVyYXRpb24pO1xuICAgICAgfVxuICBcbiAgICAgIGxldCBvcGVyYXRpb25UeDpPcGVyYXRpb25UeCA9IG5ldyBPcGVyYXRpb25UeChuZXR3b3JraWQsIGJsb2NrY2hhaW5pZCwgb3V0cywgaW5zLCBtZW1vLCBvcHMpO1xuICAgICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KG9wZXJhdGlvblR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIHVuc2lnbmVkIE5GVCB0cmFuc2ZlciB0cmFuc2FjdGlvbi4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAqIFtbTkZUVHJhbnNmZXJPcGVyYXRpb25dXSBtYW51YWxseSAod2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMsIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zLCBhbmQgW1tUcmFuc2Zlck9wZXJhdGlvbl1dcykuXG4gICAgKlxuICAgICogQHBhcmFtIG5ldHdvcmtpZCBUaGUgbnVtYmVyIHJlcHJlc2VudGluZyBOZXR3b3JrSUQgb2YgdGhlIG5vZGVcbiAgICAqIEBwYXJhbSBibG9ja2NoYWluaWQgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgQmxvY2tjaGFpbklEIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAqIEBwYXJhbSBmZWVBc3NldElEIFRoZSBhc3NldElEIGZvciB0aGUgQVZBWCBmZWUgdG8gYmUgcGFpZFxuICAgICogQHBhcmFtIGZlZSBUaGUgYW1vdW50IG9mIEFWQVggdG8gYmUgcGFpZCBmb3IgZmVlcywgaW4gJG5BVkFYXG4gICAgKiBAcGFyYW0gZmVlU2VuZGVyQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdG8gc2VuZCB0aGUgZmVlc1xuICAgICogQHBhcmFtIHRvQWRkcmVzc2VzIEFuIGFycmF5IG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9cyB3aGljaCBpbmRpY2F0ZSB3aG8gcmVjaWV2ZXMgdGhlIE5GVFxuICAgICogQHBhcmFtIGZyb21BZGRyZXNzZXMgQW4gYXJyYXkgZm9yIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHdobyBvd25zIHRoZSBORlRcbiAgICAqIEBwYXJhbSB1dHhvaWRzIEFuIGFycmF5IG9mIHN0cmluZ3MgZm9yIHRoZSBORlRzIGJlaW5nIHRyYW5zZmVycmVkXG4gICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAqIEBwYXJhbSBsb2NrdGltZSBPcHRpb25hbC4gVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyBvdXRwdXRzXG4gICAgKiBAcGFyYW0gdGhyZXNob2xkIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIGZ1bmRzIGluIHRoZSByZXN1bHRhbnQgVVRYT1xuICAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gY3JlYXRlZCBmcm9tIHRoZSBwYXNzZWQgaW4gcGFyYW1ldGVycy5cbiAgICAqXG4gICAgKi9cbiAgYnVpbGRORlRUcmFuc2ZlclR4ID0gKFxuICAgIG5ldHdvcmtpZDpudW1iZXIsIGJsb2NrY2hhaW5pZDpCdWZmZXIsIGZlZUFzc2V0SUQ6QnVmZmVyLCBmZWU6Qk4sXG4gICAgZmVlU2VuZGVyQWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4sIHRvQWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4sIGZyb21BZGRyZXNzZXM6QXJyYXk8QnVmZmVyPixcbiAgICB1dHhvaWRzOkFycmF5PHN0cmluZz4sIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBhc09mOkJOID0gVW5peE5vdygpLFxuICAgIGxvY2t0aW1lOkJOID0gbmV3IEJOKDApLCB0aHJlc2hvbGQ6bnVtYmVyID0gMSxcbiAgKTpVbnNpZ25lZFR4ID0+IHtcbiAgICAvLyBDaGVhdGluZyBhbmQgdXNpbmcgYnVpbGRCYXNlVHggdG8gZ2V0IElucyBhbmQgT3V0cyBmb3IgZmVlcy5cbiAgICAvLyBGZWVzIGFyZSBidXJuZWQsIHNvIG5vIHRvQWRkcmVzc2VzLCBvbmx5IGZlZVNlbmRlckFkZHJlc3NlcyBhbmQgY2hhbmdlQWRkcmVzc2VzLCBib3RoIGFyZSB0aGUgZmVlU2VuZGVyQWRkcmVzc2VzXG4gICAgY29uc3QgdXR4OlVuc2lnbmVkVHggPSB0aGlzLmJ1aWxkQmFzZVR4KFxuICAgICAgbmV0d29ya2lkLCBibG9ja2NoYWluaWQsIGZlZSwgW10sIGZlZVNlbmRlckFkZHJlc3NlcywgZmVlU2VuZGVyQWRkcmVzc2VzLCBmZWVBc3NldElELCB1bmRlZmluZWQsIGFzT2ZcbiAgICApO1xuICAgIGNvbnN0IGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB1dHguZ2V0VHJhbnNhY3Rpb24oKS5nZXRJbnMoKTtcbiAgICBjb25zdCBvdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSB1dHguZ2V0VHJhbnNhY3Rpb24oKS5nZXRPdXRzKCk7XG4gICAgY29uc3Qgb3BzOkFycmF5PFRyYW5zZmVyYWJsZU9wZXJhdGlvbj4gPSBbXTtcbiAgICBmb3IgKGxldCBpOm51bWJlciA9IDA7IGkgPCB1dHhvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB1dHhvOlVUWE8gPSB0aGlzLmdldFVUWE8odXR4b2lkc1tpXSk7XG4gIFxuICAgICAgY29uc3Qgb3V0Ok5GVFRyYW5zZmVyT3V0cHV0ID0gdXR4by5nZXRPdXRwdXQoKSBhcyBORlRUcmFuc2Zlck91dHB1dDtcbiAgICAgIGNvbnN0IHNwZW5kZXJzOkFycmF5PEJ1ZmZlcj4gPSBvdXQuZ2V0U3BlbmRlcnMoZnJvbUFkZHJlc3NlcywgYXNPZik7XG4gIFxuICAgICAgY29uc3Qgb3V0Ym91bmQ6TkZUVHJhbnNmZXJPdXRwdXQgPSBuZXcgTkZUVHJhbnNmZXJPdXRwdXQoXG4gICAgICAgIG91dC5nZXRHcm91cElEKCksIG91dC5nZXRQYXlsb2FkKCksIHRvQWRkcmVzc2VzLCBsb2NrdGltZSwgdGhyZXNob2xkLCBcbiAgICAgICk7XG4gICAgICBjb25zdCBvcDpORlRUcmFuc2Zlck9wZXJhdGlvbiA9IG5ldyBORlRUcmFuc2Zlck9wZXJhdGlvbihvdXRib3VuZCk7XG4gIFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGVuZGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBpZHg6bnVtYmVyID0gb3V0LmdldEFkZHJlc3NJZHgoc3BlbmRlcnNbal0pO1xuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIFVUWE9TZXQuYnVpbGRORlRUcmFuc2ZlclR4OiAnXG4gICAgICAgICAgKyBgbm8gc3VjaCBhZGRyZXNzIGluIG91dHB1dDogJHtzcGVuZGVyc1tqXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBvcC5hZGRTaWduYXR1cmVJZHgoaWR4LCBzcGVuZGVyc1tqXSk7XG4gICAgICB9XG4gIFxuICAgICAgY29uc3QgeGZlcm9wOlRyYW5zZmVyYWJsZU9wZXJhdGlvbiA9IG5ldyBUcmFuc2ZlcmFibGVPcGVyYXRpb24odXR4by5nZXRBc3NldElEKCksXG4gICAgICAgIFt1dHhvaWRzW2ldXSxcbiAgICAgICAgb3ApO1xuICAgICAgb3BzLnB1c2goeGZlcm9wKTtcbiAgICB9XG4gICAgY29uc3QgT3BUeDpPcGVyYXRpb25UeCA9IG5ldyBPcGVyYXRpb25UeChuZXR3b3JraWQsIGJsb2NrY2hhaW5pZCwgb3V0cywgaW5zLCBtZW1vLCBvcHMpO1xuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChPcFR4KTtcbiAgfTtcblxuICAgIC8qKlxuICAgICogSW4tRGV2ZWxvcG1lbnQsIGRvIG5vdCB1c2U6IENyZWF0ZXMgYW4gdW5zaWduZWQgSW1wb3J0VHggdHJhbnNhY3Rpb24uXG4gICAgKlxuICAgICogQHBhcmFtIG5ldHdvcmtpZCBUaGUgbnVtYmVyIHJlcHJlc2VudGluZyBOZXR3b3JrSUQgb2YgdGhlIG5vZGVcbiAgICAqIEBwYXJhbSBibG9ja2NoYWluaWQgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgQmxvY2tjaGFpbklEIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAqIEBwYXJhbSBmZWVBc3NldElEIFRoZSBhc3NldElEIGZvciB0aGUgQVZBWCBmZWUgdG8gYmUgcGFpZFxuICAgICogQHBhcmFtIGZlZSBUaGUgYW1vdW50IG9mIEFWQVggdG8gYmUgcGFpZCBmb3IgZmVlcywgaW4gJG5BVkFYXG4gICAgKiBAcGFyYW0gZmVlU2VuZGVyQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdG8gc2VuZCB0aGUgZmVlc1xuICAgICogQHBhcmFtIGltcG9ydElucyBBbiBhcnJheSBvZiBbW1RyYW5zZmVyYWJsZUlucHV0XV1zIGJlaW5nIGltcG9ydGVkXG4gICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGNyZWF0ZWQgZnJvbSB0aGUgcGFzc2VkIGluIHBhcmFtZXRlcnMuXG4gICAgKlxuICAgICovXG4gICBidWlsZEltcG9ydFR4ID0gKFxuICAgIG5ldHdvcmtpZDpudW1iZXIsIGJsb2NrY2hhaW5pZDpCdWZmZXIsIGZlZUFzc2V0SUQ6QnVmZmVyLCBmZWU6Qk4sXG4gICAgZmVlU2VuZGVyQWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4sIGltcG9ydEluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4sIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBhc09mOkJOID0gVW5peE5vdygpLFxuICApOlVuc2lnbmVkVHggPT4ge1xuICAgIC8vIENoZWF0aW5nIGFuZCB1c2luZyBidWlsZEJhc2VUeCB0byBnZXQgSW5zIGFuZCBPdXRzIGZvciBmZWVzLlxuICAgIC8vIEZlZXMgYXJlIGJ1cm5lZCwgc28gbm8gdG9BZGRyZXNzZXMsIG9ubHkgZmVlU2VuZGVyQWRkcmVzc2VzIGFuZCBjaGFuZ2VBZGRyZXNzZXMsIGJvdGggYXJlIHRoZSBmZWVTZW5kZXJBZGRyZXNzZXNcbiAgICBjb25zdCB1dHg6VW5zaWduZWRUeCA9IHRoaXMuYnVpbGRCYXNlVHgoXG4gICAgICBuZXR3b3JraWQsIGJsb2NrY2hhaW5pZCwgZmVlLCBbXSwgZmVlU2VuZGVyQWRkcmVzc2VzLCBmZWVTZW5kZXJBZGRyZXNzZXMsIGZlZUFzc2V0SUQsIHVuZGVmaW5lZCwgYXNPZlxuICAgICk7XG4gICAgY29uc3QgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHV0eC5nZXRUcmFuc2FjdGlvbigpLmdldElucygpO1xuICAgIGNvbnN0IG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHV0eC5nZXRUcmFuc2FjdGlvbigpLmdldE91dHMoKTtcblxuICAgIGNvbnN0IGltcG9ydFR4OkltcG9ydFR4ID0gbmV3IEltcG9ydFR4KG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8sIGltcG9ydElucyk7XG4gICAgcmV0dXJuIG5ldyBVbnNpZ25lZFR4KGltcG9ydFR4KTtcbiAgfTtcblxuICAgIC8qKlxuICAgICogSW4tRGV2ZWxvcG1lbnQsIGRvIG5vdCB1c2U6IENyZWF0ZXMgYW4gdW5zaWduZWQgRXhwb3J0VHggdHJhbnNhY3Rpb24uIFxuICAgICpcbiAgICAqIEBwYXJhbSBuZXR3b3JraWQgVGhlIG51bWJlciByZXByZXNlbnRpbmcgTmV0d29ya0lEIG9mIHRoZSBub2RlXG4gICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIFRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEJsb2NrY2hhaW5JRCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgKiBAcGFyYW0gZmVlQXNzZXRJRCBUaGUgYXNzZXRJRCBmb3IgdGhlIEFWQVggZmVlIHRvIGJlIHBhaWRcbiAgICAqIEBwYXJhbSBmZWUgVGhlIGFtb3VudCBvZiBBVkFYIHRvIGJlIHBhaWQgZm9yIGZlZXMsIGluICRuQVZBWFxuICAgICogQHBhcmFtIGZlZVNlbmRlckFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRvIHNlbmQgdGhlIGZlZXNcbiAgICAqIEBwYXJhbSB1dHhvaWRzIEFuIGFycmF5IG9mIHN0cmluZ3MgZm9yIHRoZSBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcyBiZWluZyBleHBvcnRlZFxuICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBjcmVhdGVkIGZyb20gdGhlIHBhc3NlZCBpbiBwYXJhbWV0ZXJzLlxuICAgICpcbiAgICAqL1xuICAgYnVpbGRFeHBvcnRUeCA9IChcbiAgICBuZXR3b3JraWQ6bnVtYmVyLCBibG9ja2NoYWluaWQ6QnVmZmVyLCBmZWVBc3NldElEOkJ1ZmZlciwgZmVlOkJOLFxuICAgIGZlZVNlbmRlckFkZHJlc3NlczpBcnJheTxCdWZmZXI+LCB1dHhvaWRzOkFycmF5PHN0cmluZz4sIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBhc09mOkJOID0gVW5peE5vdygpXG4gICk6VW5zaWduZWRUeCA9PiB7XG4gICAgLy8gQ2hlYXRpbmcgYW5kIHVzaW5nIGJ1aWxkQmFzZVR4IHRvIGdldCBJbnMgYW5kIE91dHMgZm9yIGZlZXMuXG4gICAgLy8gRmVlcyBhcmUgYnVybmVkLCBzbyBubyB0b0FkZHJlc3Nlcywgb25seSBmZWVTZW5kZXJBZGRyZXNzZXMgYW5kIGNoYW5nZUFkZHJlc3NlcywgYm90aCBhcmUgdGhlIGZlZVNlbmRlckFkZHJlc3Nlc1xuICAgIGNvbnN0IHV0eDpVbnNpZ25lZFR4ID0gdGhpcy5idWlsZEJhc2VUeChcbiAgICAgIG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBmZWUsIFtdLCBmZWVTZW5kZXJBZGRyZXNzZXMsIGZlZVNlbmRlckFkZHJlc3NlcywgZmVlQXNzZXRJRCwgdW5kZWZpbmVkLCBhc09mXG4gICAgKTtcbiAgICBjb25zdCBpbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+ID0gdXR4LmdldFRyYW5zYWN0aW9uKCkuZ2V0SW5zKCk7XG4gICAgY29uc3Qgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdXR4LmdldFRyYW5zYWN0aW9uKCkuZ2V0T3V0cygpO1xuICAgIGNvbnN0IGV4cG9ydE91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IFtdO1xuICAgIGZvciAobGV0IGk6bnVtYmVyID0gMDsgaSA8IHV0eG9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHV0eG86VVRYTyA9IHRoaXMuZ2V0VVRYTyh1dHhvaWRzW2ldKTtcbiAgICAgIGNvbnN0IGFzc2V0SUQ6QnVmZmVyID0gdXR4by5nZXRBc3NldElEKCk7XG4gICAgICBjb25zdCBvdXRwdXQ6QW1vdW50T3V0cHV0ID0gdXR4by5nZXRPdXRwdXQoKSBhcyBBbW91bnRPdXRwdXQ7XG4gICAgICBjb25zdCBhbXQ6Qk4gPSBvdXRwdXQuZ2V0QW1vdW50KCkuY2xvbmUoKTtcbiAgICAgIGNvbnN0IHR4aWQ6QnVmZmVyID0gdXR4by5nZXRUeElEKCk7XG4gICAgICBjb25zdCBvdXRwdXRpZHg6QnVmZmVyID0gdXR4by5nZXRPdXRwdXRJZHgoKTtcbiAgICAgIGNvbnN0IGlucHV0OlNlY3BJbnB1dCA9IG5ldyBTZWNwSW5wdXQoYW10KTtcbiAgICAgIGNvbnN0IHhmZXJpbjpUcmFuc2ZlcmFibGVJbnB1dCA9IG5ldyBUcmFuc2ZlcmFibGVJbnB1dCh0eGlkLCBvdXRwdXRpZHgsIGFzc2V0SUQsIGlucHV0KTtcbiAgICAgIGNvbnN0IGZyb21BZGRyZXNzZXM6QXJyYXk8QnVmZmVyPiA9IG91dHB1dC5nZXRBZGRyZXNzZXMoKTsgLy8gVmVyaWZ5IGNvcnJlY3QgYXBwcm9hY2hcbiAgICAgIGNvbnN0IHNwZW5kZXJzOkFycmF5PEJ1ZmZlcj4gPSBvdXRwdXQuZ2V0U3BlbmRlcnMoZnJvbUFkZHJlc3NlcywgYXNPZik7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwZW5kZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGlkeDpudW1iZXIgPSBvdXRwdXQuZ2V0QWRkcmVzc0lkeChzcGVuZGVyc1tqXSk7XG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gVVRYT1NldC5idWlsZEJhc2VUeDogbm8gc3VjaCAnXG4gICAgICAgICAgKyBgYWRkcmVzcyBpbiBvdXRwdXQ6ICR7c3BlbmRlcnNbal19YCk7XG4gICAgICAgIH1cbiAgICAgICAgeGZlcmluLmdldElucHV0KCkuYWRkU2lnbmF0dXJlSWR4KGlkeCwgc3BlbmRlcnNbal0pO1xuICAgICAgfVxuICAgICAgaW5zLnB1c2goeGZlcmluKTtcbiAgICAgIGNvbnN0IHhmZXJPdXQ6VHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dChhc3NldElELCBvdXRwdXQpO1xuICAgICAgZXhwb3J0T3V0cy5wdXNoKHhmZXJPdXQpXG4gICAgfVxuICAgIGNvbnN0IGV4cG9ydFR4OkV4cG9ydFR4ID0gbmV3IEV4cG9ydFR4KG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8sIGV4cG9ydE91dHMpO1xuICAgIHJldHVybiBuZXcgVW5zaWduZWRUeChleHBvcnRUeCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXQgd2l0aCBjb3B5IG9mIFVUWE9zIGluIHRoaXMgYW5kIHNldCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgW1tVVFhPU2V0XV0gdG8gbWVyZ2Ugd2l0aCB0aGlzIG9uZVxuICAgICAqIEBwYXJhbSBoYXNVVFhPSURzIFdpbGwgc3Vic2VsZWN0IGEgc2V0IG9mIFtbVVRYT11dcyB3aGljaCBoYXZlIHRoZSBVVFhPSURzIHByb3ZpZGVkIGluIHRoaXMgYXJyYXksIGRlZnVsdHMgdG8gYWxsIFVUWE9zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBVVFhPU2V0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBmaWx0ZXJlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgbWVyZ2UgPSAodXR4b3NldDpVVFhPU2V0LCBoYXNVVFhPSURzOkFycmF5PHN0cmluZz4gPSB1bmRlZmluZWQpOiBVVFhPU2V0ID0+IHtcbiAgICBjb25zdCByZXN1bHRzOlVUWE9TZXQgPSBuZXcgVVRYT1NldCgpO1xuICAgIGNvbnN0IHV0eG9zMTpBcnJheTxVVFhPPiA9IHRoaXMuZ2V0QWxsVVRYT3MoaGFzVVRYT0lEcyk7XG4gICAgY29uc3QgdXR4b3MyOkFycmF5PFVUWE8+ID0gdXR4b3NldC5nZXRBbGxVVFhPcyhoYXNVVFhPSURzKTtcbiAgICBjb25zdCBwcm9jZXNzID0gKHV0eG86VVRYTykgPT4ge1xuICAgICAgcmVzdWx0cy5hZGQodXR4byk7XG4gICAgfTtcbiAgICB1dHhvczEuZm9yRWFjaChwcm9jZXNzKTtcbiAgICB1dHhvczIuZm9yRWFjaChwcm9jZXNzKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvKipcbiAgICAgKiBTZXQgaW50ZXJzZXRpb24gYmV0d2VlbiB0aGlzIHNldCBhbmQgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgc2V0IHRvIGludGVyc2VjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgVVRYT1NldCBjb250YWluaW5nIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgKi9cbiAgaW50ZXJzZWN0aW9uID0gKHV0eG9zZXQ6VVRYT1NldCk6VVRYT1NldCA9PiB7XG4gICAgY29uc3QgdXMxOkFycmF5PHN0cmluZz4gPSB0aGlzLmdldFVUWE9JRHMoKTtcbiAgICBjb25zdCB1czI6QXJyYXk8c3RyaW5nPiA9IHV0eG9zZXQuZ2V0VVRYT0lEcygpO1xuICAgIGNvbnN0IHJlc3VsdHM6QXJyYXk8c3RyaW5nPiA9IHVzMS5maWx0ZXIoKHV0eG9pZCkgPT4gdXMyLmluY2x1ZGVzKHV0eG9pZCkpO1xuICAgIHJldHVybiB0aGlzLm1lcmdlKHV0eG9zZXQsIHJlc3VsdHMpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFNldCBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBzZXQgYW5kIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9zZXQgVGhlIHNldCB0byBkaWZmZXJlbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBVVFhPU2V0IGNvbnRhaW5pbmcgdGhlIGRpZmZlcmVuY2VcbiAgICAgKi9cbiAgZGlmZmVyZW5jZSA9ICh1dHhvc2V0OlVUWE9TZXQpOlVUWE9TZXQgPT4ge1xuICAgIGNvbnN0IHVzMTpBcnJheTxzdHJpbmc+ID0gdGhpcy5nZXRVVFhPSURzKCk7XG4gICAgY29uc3QgdXMyOkFycmF5PHN0cmluZz4gPSB1dHhvc2V0LmdldFVUWE9JRHMoKTtcbiAgICBjb25zdCByZXN1bHRzOkFycmF5PHN0cmluZz4gPSB1czEuZmlsdGVyKCh1dHhvaWQpID0+ICF1czIuaW5jbHVkZXModXR4b2lkKSk7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2UodXR4b3NldCwgcmVzdWx0cyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogU2V0IHN5bW1ldHJpY2FsIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIHNldCBhbmQgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgc2V0IHRvIHN5bW1ldHJpY2FsIGRpZmZlcmVuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFVUWE9TZXQgY29udGFpbmluZyB0aGUgc3ltbWV0cmljYWwgZGlmZmVyZW5jZVxuICAgICAqL1xuICBzeW1EaWZmZXJlbmNlID0gKHV0eG9zZXQ6VVRYT1NldCk6VVRYT1NldCA9PiB7XG4gICAgY29uc3QgdXMxOkFycmF5PHN0cmluZz4gPSB0aGlzLmdldFVUWE9JRHMoKTtcbiAgICBjb25zdCB1czI6QXJyYXk8c3RyaW5nPiA9IHV0eG9zZXQuZ2V0VVRYT0lEcygpO1xuICAgIGNvbnN0IHJlc3VsdHM6QXJyYXk8c3RyaW5nPiA9IHVzMS5maWx0ZXIoKHV0eG9pZCkgPT4gIXVzMi5pbmNsdWRlcyh1dHhvaWQpKVxuICAgICAgLmNvbmNhdCh1czIuZmlsdGVyKCh1dHhvaWQpID0+ICF1czEuaW5jbHVkZXModXR4b2lkKSkpO1xuICAgIHJldHVybiB0aGlzLm1lcmdlKHV0eG9zZXQsIHJlc3VsdHMpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFNldCB1bmlvbiBiZXR3ZWVuIHRoaXMgc2V0IGFuZCBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvc2V0IFRoZSBzZXQgdG8gdW5pb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFVUWE9TZXQgY29udGFpbmluZyB0aGUgdW5pb25cbiAgICAgKi9cbiAgdW5pb24gPSAodXR4b3NldDpVVFhPU2V0KTpVVFhPU2V0ID0+IHRoaXMubWVyZ2UodXR4b3NldCk7XG5cbiAgLyoqXG4gICAgICogTWVyZ2VzIGEgc2V0IGJ5IHRoZSBydWxlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9zZXQgVGhlIHNldCB0byBtZXJnZSBieSB0aGUgTWVyZ2VSdWxlXG4gICAgICogQHBhcmFtIG1lcmdlUnVsZSBUaGUgW1tNZXJnZVJ1bGVdXSB0byBhcHBseVxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgVVRYT1NldCBjb250YWluaW5nIHRoZSBtZXJnZWQgZGF0YVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgbWVyZ2UgcnVsZXMgYXJlIGFzIGZvbGxvd3M6XG4gICAgICogICAqIFwiaW50ZXJzZWN0aW9uXCIgLSB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSBzZXRcbiAgICAgKiAgICogXCJkaWZmZXJlbmNlU2VsZlwiIC0gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZXhpc3RpbmcgZGF0YSBhbmQgbmV3IHNldFxuICAgICAqICAgKiBcImRpZmZlcmVuY2VOZXdcIiAtIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG5ldyBkYXRhIGFuZCB0aGUgZXhpc3Rpbmcgc2V0XG4gICAgICogICAqIFwic3ltRGlmZmVyZW5jZVwiIC0gdGhlIHVuaW9uIG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGJvdGggc2V0cyBvZiBkYXRhXG4gICAgICogICAqIFwidW5pb25cIiAtIHRoZSB1bmlxdWUgc2V0IG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gYm90aCBzZXRzXG4gICAgICogICAqIFwidW5pb25NaW51c05ld1wiIC0gdGhlIHVuaXF1ZSBzZXQgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiBib3RoIHNldHMsIGV4Y2x1ZGluZyB2YWx1ZXMgb25seSBmb3VuZCBpbiB0aGUgbmV3IHNldFxuICAgICAqICAgKiBcInVuaW9uTWludXNTZWxmXCIgLSB0aGUgdW5pcXVlIHNldCBvZiBhbGwgZWxlbWVudHMgY29udGFpbmVkIGluIGJvdGggc2V0cywgZXhjbHVkaW5nIHZhbHVlcyBvbmx5IGZvdW5kIGluIHRoZSBleGlzdGluZyBzZXRcbiAgICAgKi9cbiAgbWVyZ2VCeVJ1bGUgPSAodXR4b3NldDpVVFhPU2V0LCBtZXJnZVJ1bGU6TWVyZ2VSdWxlKTpVVFhPU2V0ID0+IHtcbiAgICBsZXQgdVNldDpVVFhPU2V0O1xuICAgIHN3aXRjaCAobWVyZ2VSdWxlKSB7XG4gICAgICBjYXNlICdpbnRlcnNlY3Rpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb24odXR4b3NldCk7XG4gICAgICBjYXNlICdkaWZmZXJlbmNlU2VsZic6XG4gICAgICAgIHJldHVybiB0aGlzLmRpZmZlcmVuY2UodXR4b3NldCk7XG4gICAgICBjYXNlICdkaWZmZXJlbmNlTmV3JzpcbiAgICAgICAgcmV0dXJuIHV0eG9zZXQuZGlmZmVyZW5jZSh0aGlzKTtcbiAgICAgIGNhc2UgJ3N5bURpZmZlcmVuY2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5zeW1EaWZmZXJlbmNlKHV0eG9zZXQpO1xuICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICByZXR1cm4gdGhpcy51bmlvbih1dHhvc2V0KTtcbiAgICAgIGNhc2UgJ3VuaW9uTWludXNOZXcnOlxuICAgICAgICB1U2V0ID0gdGhpcy51bmlvbih1dHhvc2V0KTtcbiAgICAgICAgcmV0dXJuIHVTZXQuZGlmZmVyZW5jZSh1dHhvc2V0KTtcbiAgICAgIGNhc2UgJ3VuaW9uTWludXNTZWxmJzpcbiAgICAgICAgdVNldCA9IHRoaXMudW5pb24odXR4b3NldCk7XG4gICAgICAgIHJldHVybiB1U2V0LmRpZmZlcmVuY2UodGhpcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIC0gVVRYT1NldC5tZXJnZUJ5UnVsZTogYmFkIE1lcmdlUnVsZSAtICR7bWVyZ2VSdWxlfWApO1xuICAgIH1cbiAgfTtcbn1cbiJdfQ==