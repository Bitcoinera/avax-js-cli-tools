"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AVMKeyChain = exports.AVMKeyPair = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI-KeyChain
 */
const buffer_1 = require("buffer/");
const elliptic = __importStar(require("elliptic"));
const create_hash_1 = __importDefault(require("create-hash"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("../../utils/types");
/**
 * @ignore
 */
const EC = elliptic.ec;
/**
 * @ignore
 */
const ec = new EC('secp256k1');
/**
 * @ignore
 */
const ecparams = ec.curve;
/**
 * @ignore
 */
const BN = ecparams.n.constructor;
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Class for representing a private and public keypair in the AVM.
 */
class AVMKeyPair extends types_1.KeyPair {
    /**
       * Class for representing a private and public keypair in Avalanche.
       */
    constructor(hrp, chainid, entropy = undefined) {
        super(hrp, chainid);
        /**
           * @ignore
           */
        this._sigFromSigBuffer = (sig) => {
            const r = new BN(bintools.copyFrom(sig, 0, 32));
            const s = new BN(bintools.copyFrom(sig, 32, 64));
            const recoveryParam = bintools.copyFrom(sig, 64, 65).readUIntBE(0, 1);
            const sigOpt = {
                r,
                s,
                recoveryParam,
            };
            return sigOpt;
        };
        /**
           * Generates a new keypair.
           *
           * @param entropy Optional parameter that may be necessary to produce secure keys
           */
        this.generateKey = (entropy) => {
            this.entropy = entropy;
            this.keypair = ec.genKeyPair();
            // doing hex translation to get Buffer class
            this.privk = buffer_1.Buffer.from(this.keypair.getPrivate('hex'), 'hex');
            this.pubk = buffer_1.Buffer.from(this.keypair.getPublic(true, 'hex'), 'hex');
        };
        /**
           * Imports a private key and generates the appropriate public key.
           *
           * @param privk A {@link https://github.com/feross/buffer|Buffer} representing the private key
           *
           * @returns true on success, false on failure
           */
        this.importKey = (privk) => {
            this.keypair = ec.keyFromPrivate(privk.toString('hex'), 'hex');
            // doing hex translation to get Buffer class
            this.privk = buffer_1.Buffer.from(this.keypair.getPrivate('hex'), 'hex');
            this.pubk = buffer_1.Buffer.from(this.keypair.getPublic(true, 'hex'), 'hex');
            return true; // silly I know, but the interface requires so it returns true on success, so if Buffer fails validation...
        };
        /**
           * Returns the address as a {@link https://github.com/feross/buffer|Buffer}.
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} representation of the address
           */
        this.getAddress = () => this.addressFromPublicKey(this.pubk);
        /**
           * Returns the address's string representation.
           *
           * @returns A string representation of the address
           */
        this.getAddressString = () => {
            const addr = this.addressFromPublicKey(this.pubk);
            return bintools.addressToString(this.hrp, this.chainid, addr);
        };
        /**
           * Returns an address given a public key.
           *
           * @param pubk A {@link https://github.com/feross/buffer|Buffer} representing the public key
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} for the address of the public key.
           */
        this.addressFromPublicKey = (pubk) => {
            if (pubk.length === 65) {
                /* istanbul ignore next */
                pubk = buffer_1.Buffer.from(ec.keyFromPublic(pubk).getPublic(true, 'hex'), 'hex'); // make compact, stick back into buffer
            }
            if (pubk.length === 33) {
                const sha256 = buffer_1.Buffer.from(create_hash_1.default('sha256').update(pubk).digest());
                const ripesha = buffer_1.Buffer.from(create_hash_1.default('rmd160').update(sha256).digest());
                return ripesha;
            }
            /* istanbul ignore next */
            throw new Error('Unable to make address.');
        };
        /**
           * Returns a string representation of the private key.
           *
           * @returns A b58 serialized string representation of the private key
           */
        this.getPrivateKeyString = () => "PrivateKey-" + bintools.cb58Encode(this.privk);
        /**
           * Returns the public key.
           *
           * @returns A b58 serialized string representation of the public key
           */
        this.getPublicKeyString = () => bintools.cb58Encode(this.pubk);
        /**
           * Takes a message, signs it, and returns the signature.
           *
           * @param msg The message to sign, be sure to hash first if expected
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} containing the signature
           */
        this.sign = (msg) => {
            const sigObj = this.keypair.sign(msg, undefined, { canonical: true });
            const recovery = buffer_1.Buffer.alloc(1);
            recovery.writeUInt8(sigObj.recoveryParam, 0);
            const r = buffer_1.Buffer.from(sigObj.r.toArray('be', 32)); // we have to skip native Buffer class, so this is the way
            const s = buffer_1.Buffer.from(sigObj.s.toArray('be', 32)); // we have to skip native Buffer class, so this is the way
            const result = buffer_1.Buffer.concat([r, s, recovery], 65);
            return result;
        };
        /**
           * Verifies that the private key associated with the provided public key produces the signature associated with the given message.
           *
           * @param msg The message associated with the signature
           * @param sig The signature of the signed message
           *
           * @returns True on success, false on failure
           */
        this.verify = (msg, sig) => {
            const sigObj = this._sigFromSigBuffer(sig);
            return ec.verify(msg, sigObj, this.keypair);
        };
        /**
           * Recovers the public key of a message signer from a message and its associated signature.
           *
           * @param msg The message that's signed
           * @param sig The signature that's signed on the message
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public key of the signer
           */
        this.recover = (msg, sig) => {
            const sigObj = this._sigFromSigBuffer(sig);
            const pubk = ec.recoverPubKey(msg, sigObj, sigObj.recoveryParam);
            return buffer_1.Buffer.from(pubk.encodeCompressed());
        };
        this.entropy = entropy;
        this.generateKey();
    }
}
exports.AVMKeyPair = AVMKeyPair;
/**
 * Class for representing a key chain in Avalanche.
 *
 * @typeparam AVMKeyPair Class extending [[KeyPair]] which is used as the key in [[AVMKeyChain]]
 */
class AVMKeyChain extends types_1.KeyChain {
    /**
       * Returns instance of AVMKeyChain.
       */
    constructor(hrp, chainid) {
        super(hrp, chainid);
        /**
           * Makes a new key pair, returns the address.
           *
           * @param entropy Optional parameter that may be necessary to produce secure keys
           *
           * @returns Address of the new key pair
           */
        this.makeKey = (entropy = undefined) => {
            const keypair = new AVMKeyPair(this.hrp, this.chainid, entropy);
            this.addKey(keypair);
            return keypair.getAddress();
        };
        /**
           * Given a private key, makes a new key pair, returns the address.
           *
           * @param privk A {@link https://github.com/feross/buffer|Buffer} or b58 serialized string representing the private key
           *
           * @returns Address of the new key pair
           */
        this.importKey = (privk) => {
            const keypair = new AVMKeyPair(this.hrp, this.chainid);
            let pk;
            if (typeof privk === 'string') {
                pk = bintools.cb58Decode(privk.split('-')[1]);
            }
            else {
                pk = bintools.copyFrom(privk);
            }
            keypair.importKey(pk);
            if (!(keypair.getAddress().toString('hex') in this.keys)) {
                this.addKey(keypair);
            }
            return keypair.getAddress();
        };
        /**
           * DEPRECATED: use UnsignedTx.sign(keychain) instead
           * Signs a [[UnsignedTx]] and returns signed [[Tx]]
           *
           * @param utx A [[UnsignedTx]] that needs to be signed
           *
           * @returns A signed [[Tx]]
           */
        this.signTx = (utx) => utx.sign(this);
    }
}
exports.AVMKeyChain = AVMKeyChain;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpcy9hdm0va2V5Y2hhaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7R0FHRztBQUNILG9DQUFpQztBQUNqQyxtREFBcUM7QUFDckMsOERBQXFDO0FBQ3JDLG9FQUE0QztBQUU1Qyw2Q0FBc0Q7QUFHdEQ7O0dBRUc7QUFDSCxNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDO0FBRXZCOztHQUVHO0FBQ0gsTUFBTSxFQUFFLEdBQUcsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDO0FBRTFCOztHQUVHO0FBQ0gsTUFBTSxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFFbEM7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRXhDOztHQUVHO0FBQ0gsTUFBYSxVQUFXLFNBQVEsZUFBTztJQWlKckM7O1NBRUs7SUFDTCxZQUFZLEdBQVUsRUFBRSxPQUFjLEVBQUUsVUFBaUIsU0FBUztRQUNoRSxLQUFLLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBaEp0Qjs7YUFFSztRQUNLLHNCQUFpQixHQUFHLENBQUMsR0FBVSxFQUErQixFQUFFO1lBQ3hFLE1BQU0sQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2pELE1BQU0sYUFB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LENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JCLE9BQU8sT0FBTyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzlCLENBQUMsQ0FBQztRQUVGOzs7Ozs7YUFNSztRQUNMLGNBQVMsR0FBRyxDQUFDLEtBQXFCLEVBQVMsRUFBRTtZQUMzQyxNQUFNLE9BQU8sR0FBYyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNsRSxJQUFJLEVBQVMsQ0FBQztZQUNkLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO2dCQUM3QixFQUFFLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDL0M7aUJBQU07Z0JBQ0wsRUFBRSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDL0I7WUFDRCxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3RCLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN4RCxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3RCO1lBQ0QsT0FBTyxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDOUIsQ0FBQyxDQUFDO1FBRUY7Ozs7Ozs7YUFPSztRQUNMLFdBQU0sR0FBRyxDQUFDLEdBQWMsRUFBSyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQU8vQyxDQUFDO0NBQ0Y7QUFwREQsa0NBb0RDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVZNQVBJLUtleUNoYWluXG4gKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlci8nO1xuaW1wb3J0ICogYXMgZWxsaXB0aWMgZnJvbSAnZWxsaXB0aWMnO1xuaW1wb3J0IGNyZWF0ZUhhc2ggZnJvbSAnY3JlYXRlLWhhc2gnO1xuaW1wb3J0IEJpblRvb2xzIGZyb20gJy4uLy4uL3V0aWxzL2JpbnRvb2xzJztcbmltcG9ydCB7IFR4LCBVbnNpZ25lZFR4IH0gZnJvbSAnLi90eCc7XG5pbXBvcnQgeyBLZXlQYWlyLCBLZXlDaGFpbiB9IGZyb20gJy4uLy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IEFWTUNvbnN0YW50cyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgRUMgPSBlbGxpcHRpYy5lYztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGVjcGFyYW1zID0gZWMuY3VydmU7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBCTiA9IGVjcGFyYW1zLm4uY29uc3RydWN0b3I7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29scyA9IEJpblRvb2xzLmdldEluc3RhbmNlKCk7XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIHByaXZhdGUgYW5kIHB1YmxpYyBrZXlwYWlyIGluIHRoZSBBVk0uXG4gKi9cbmV4cG9ydCBjbGFzcyBBVk1LZXlQYWlyIGV4dGVuZHMgS2V5UGFpciB7XG4gIHByb3RlY3RlZCBrZXlwYWlyOmVsbGlwdGljLmVjLktleVBhaXI7XG5cbiAgcHJvdGVjdGVkIGVudHJvcHk6QnVmZmVyO1xuXG4gIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgcHJvdGVjdGVkIF9zaWdGcm9tU2lnQnVmZmVyID0gKHNpZzpCdWZmZXIpOmVsbGlwdGljLmVjLlNpZ25hdHVyZU9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHIgPSBuZXcgQk4oYmludG9vbHMuY29weUZyb20oc2lnLCAwLCAzMikpO1xuICAgIGNvbnN0IHMgPSBuZXcgQk4oYmludG9vbHMuY29weUZyb20oc2lnLCAzMiwgNjQpKTtcbiAgICBjb25zdCByZWNvdmVyeVBhcmFtOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKHNpZywgNjQsIDY1KS5yZWFkVUludEJFKDAsIDEpO1xuICAgIGNvbnN0IHNpZ09wdCA9IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgcmVjb3ZlcnlQYXJhbSxcbiAgICB9O1xuICAgIHJldHVybiBzaWdPcHQ7XG4gIH07XG5cbiAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IGtleXBhaXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW50cm9weSBPcHRpb25hbCBwYXJhbWV0ZXIgdGhhdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHByb2R1Y2Ugc2VjdXJlIGtleXNcbiAgICAgKi9cbiAgZ2VuZXJhdGVLZXkgPSAoZW50cm9weT86QnVmZmVyKSA9PiB7XG4gICAgdGhpcy5lbnRyb3B5ID0gZW50cm9weTtcbiAgICB0aGlzLmtleXBhaXIgPSBlYy5nZW5LZXlQYWlyKCk7XG5cbiAgICAvLyBkb2luZyBoZXggdHJhbnNsYXRpb24gdG8gZ2V0IEJ1ZmZlciBjbGFzc1xuICAgIHRoaXMucHJpdmsgPSBCdWZmZXIuZnJvbSh0aGlzLmtleXBhaXIuZ2V0UHJpdmF0ZSgnaGV4JyksICdoZXgnKTtcbiAgICB0aGlzLnB1YmsgPSBCdWZmZXIuZnJvbSh0aGlzLmtleXBhaXIuZ2V0UHVibGljKHRydWUsICdoZXgnKSwgJ2hleCcpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIEltcG9ydHMgYSBwcml2YXRlIGtleSBhbmQgZ2VuZXJhdGVzIHRoZSBhcHByb3ByaWF0ZSBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHByaXZrIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlXG4gICAgICovXG4gIGltcG9ydEtleSA9IChwcml2azpCdWZmZXIpOmJvb2xlYW4gPT4ge1xuICAgIHRoaXMua2V5cGFpciA9IGVjLmtleUZyb21Qcml2YXRlKHByaXZrLnRvU3RyaW5nKCdoZXgnKSwgJ2hleCcpO1xuICAgIC8vIGRvaW5nIGhleCB0cmFuc2xhdGlvbiB0byBnZXQgQnVmZmVyIGNsYXNzXG4gICAgdGhpcy5wcml2ayA9IEJ1ZmZlci5mcm9tKHRoaXMua2V5cGFpci5nZXRQcml2YXRlKCdoZXgnKSwgJ2hleCcpO1xuICAgIHRoaXMucHViayA9IEJ1ZmZlci5mcm9tKHRoaXMua2V5cGFpci5nZXRQdWJsaWModHJ1ZSwgJ2hleCcpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIHRydWU7IC8vIHNpbGx5IEkga25vdywgYnV0IHRoZSBpbnRlcmZhY2UgcmVxdWlyZXMgc28gaXQgcmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIHNvIGlmIEJ1ZmZlciBmYWlscyB2YWxpZGF0aW9uLi4uXG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgICAqL1xuICBnZXRBZGRyZXNzID0gKCk6QnVmZmVyID0+IHRoaXMuYWRkcmVzc0Zyb21QdWJsaWNLZXkodGhpcy5wdWJrKTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzJ3Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKi9cbiAgZ2V0QWRkcmVzc1N0cmluZyA9ICgpOnN0cmluZyA9PiB7XG4gICAgY29uc3QgYWRkcjpCdWZmZXIgPSB0aGlzLmFkZHJlc3NGcm9tUHVibGljS2V5KHRoaXMucHViayk7XG4gICAgcmV0dXJuIGJpbnRvb2xzLmFkZHJlc3NUb1N0cmluZyh0aGlzLmhycCwgdGhpcy5jaGFpbmlkLCBhZGRyKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFkZHJlc3MgZ2l2ZW4gYSBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHB1YmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIHB1YmxpYyBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBhZGRyZXNzIG9mIHRoZSBwdWJsaWMga2V5LlxuICAgICAqL1xuICBhZGRyZXNzRnJvbVB1YmxpY0tleSA9IChwdWJrOkJ1ZmZlcik6IEJ1ZmZlciA9PiB7XG4gICAgaWYgKHB1YmsubGVuZ3RoID09PSA2NSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHB1YmsgPSBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHVibGljKHB1YmspLmdldFB1YmxpYyh0cnVlLCAnaGV4JyksICdoZXgnKTsgLy8gbWFrZSBjb21wYWN0LCBzdGljayBiYWNrIGludG8gYnVmZmVyXG4gICAgfVxuICAgIGlmIChwdWJrLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgIGNvbnN0IHNoYTI1NjpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUocHViaykuZGlnZXN0KCkpO1xuICAgICAgY29uc3QgcmlwZXNoYTpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoc2hhMjU2KS5kaWdlc3QoKSk7XG4gICAgICByZXR1cm4gcmlwZXNoYTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBtYWtlIGFkZHJlc3MuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGI1OCBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKi9cbiAgZ2V0UHJpdmF0ZUtleVN0cmluZyA9ICgpOnN0cmluZyA9PiBcIlByaXZhdGVLZXktXCIgKyBiaW50b29scy5jYjU4RW5jb2RlKHRoaXMucHJpdmspO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGI1OCBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgICAqL1xuICBnZXRQdWJsaWNLZXlTdHJpbmcgPSAoKTpzdHJpbmcgPT4gYmludG9vbHMuY2I1OEVuY29kZSh0aGlzLnB1YmspO1xuXG4gIC8qKlxuICAgICAqIFRha2VzIGEgbWVzc2FnZSwgc2lnbnMgaXQsIGFuZCByZXR1cm5zIHRoZSBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIHNpZ24sIGJlIHN1cmUgdG8gaGFzaCBmaXJzdCBpZiBleHBlY3RlZFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgc2lnbiA9IChtc2c6QnVmZmVyKTpCdWZmZXIgPT4ge1xuICAgIGNvbnN0IHNpZ09iaiA9IHRoaXMua2V5cGFpci5zaWduKG1zZywgdW5kZWZpbmVkLCB7IGNhbm9uaWNhbDogdHJ1ZSB9KTtcbiAgICBjb25zdCByZWNvdmVyeTpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgcmVjb3Zlcnkud3JpdGVVSW50OChzaWdPYmoucmVjb3ZlcnlQYXJhbSwgMCk7XG4gICAgY29uc3QgcjpCdWZmZXIgPSBCdWZmZXIuZnJvbShzaWdPYmouci50b0FycmF5KCdiZScsIDMyKSk7IC8vIHdlIGhhdmUgdG8gc2tpcCBuYXRpdmUgQnVmZmVyIGNsYXNzLCBzbyB0aGlzIGlzIHRoZSB3YXlcbiAgICBjb25zdCBzOkJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNpZ09iai5zLnRvQXJyYXkoJ2JlJywgMzIpKTsgLy8gd2UgaGF2ZSB0byBza2lwIG5hdGl2ZSBCdWZmZXIgY2xhc3MsIHNvIHRoaXMgaXMgdGhlIHdheVxuICAgIGNvbnN0IHJlc3VsdDpCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtyLCBzLCByZWNvdmVyeV0sIDY1KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoYXQgdGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZWQgcHVibGljIGtleSBwcm9kdWNlcyB0aGUgc2lnbmF0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICAgKiBAcGFyYW0gc2lnIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgdmVyaWZ5ID0gKG1zZzpCdWZmZXIsIHNpZzpCdWZmZXIpOmJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHNpZ09iajplbGxpcHRpYy5lYy5TaWduYXR1cmVPcHRpb25zID0gdGhpcy5fc2lnRnJvbVNpZ0J1ZmZlcihzaWcpO1xuICAgIHJldHVybiBlYy52ZXJpZnkobXNnLCBzaWdPYmosIHRoaXMua2V5cGFpcik7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmVjb3ZlcnMgdGhlIHB1YmxpYyBrZXkgb2YgYSBtZXNzYWdlIHNpZ25lciBmcm9tIGEgbWVzc2FnZSBhbmQgaXRzIGFzc29jaWF0ZWQgc2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyBUaGUgbWVzc2FnZSB0aGF0J3Mgc2lnbmVkXG4gICAgICogQHBhcmFtIHNpZyBUaGUgc2lnbmF0dXJlIHRoYXQncyBzaWduZWQgb24gdGhlIG1lc3NhZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyB0aGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyXG4gICAgICovXG4gIHJlY292ZXIgPSAobXNnOkJ1ZmZlciwgc2lnOkJ1ZmZlcik6QnVmZmVyID0+IHtcbiAgICBjb25zdCBzaWdPYmo6ZWxsaXB0aWMuZWMuU2lnbmF0dXJlT3B0aW9ucyA9IHRoaXMuX3NpZ0Zyb21TaWdCdWZmZXIoc2lnKTtcbiAgICBjb25zdCBwdWJrID0gZWMucmVjb3ZlclB1YktleShtc2csIHNpZ09iaiwgc2lnT2JqLnJlY292ZXJ5UGFyYW0pO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShwdWJrLmVuY29kZUNvbXByZXNzZWQoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIHByaXZhdGUgYW5kIHB1YmxpYyBrZXlwYWlyIGluIEF2YWxhbmNoZS5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoaHJwOnN0cmluZywgY2hhaW5pZDpzdHJpbmcsIGVudHJvcHk6QnVmZmVyID0gdW5kZWZpbmVkKSB7XG4gICAgc3VwZXIoaHJwLCBjaGFpbmlkKTtcbiAgICB0aGlzLmVudHJvcHkgPSBlbnRyb3B5O1xuICAgIHRoaXMuZ2VuZXJhdGVLZXkoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYSBrZXkgY2hhaW4gaW4gQXZhbGFuY2hlLlxuICpcbiAqIEB0eXBlcGFyYW0gQVZNS2V5UGFpciBDbGFzcyBleHRlbmRpbmcgW1tLZXlQYWlyXV0gd2hpY2ggaXMgdXNlZCBhcyB0aGUga2V5IGluIFtbQVZNS2V5Q2hhaW5dXVxuICovXG5leHBvcnQgY2xhc3MgQVZNS2V5Q2hhaW4gZXh0ZW5kcyBLZXlDaGFpbjxBVk1LZXlQYWlyPiB7XG4gIC8qKlxuICAgICAqIE1ha2VzIGEgbmV3IGtleSBwYWlyLCByZXR1cm5zIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudHJvcHkgT3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBwcm9kdWNlIHNlY3VyZSBrZXlzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIHRoZSBuZXcga2V5IHBhaXJcbiAgICAgKi9cbiAgbWFrZUtleSA9IChlbnRyb3B5OkJ1ZmZlciA9IHVuZGVmaW5lZCk6QnVmZmVyID0+IHtcbiAgICBjb25zdCBrZXlwYWlyOkFWTUtleVBhaXIgPSBuZXcgQVZNS2V5UGFpcih0aGlzLmhycCwgdGhpcy5jaGFpbmlkLCBlbnRyb3B5KTtcbiAgICB0aGlzLmFkZEtleShrZXlwYWlyKTtcbiAgICByZXR1cm4ga2V5cGFpci5nZXRBZGRyZXNzKCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogR2l2ZW4gYSBwcml2YXRlIGtleSwgbWFrZXMgYSBuZXcga2V5IHBhaXIsIHJldHVybnMgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJpdmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBiNTggc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBwcml2YXRlIGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMgQWRkcmVzcyBvZiB0aGUgbmV3IGtleSBwYWlyXG4gICAgICovXG4gIGltcG9ydEtleSA9IChwcml2azpCdWZmZXIgfCBzdHJpbmcpOkJ1ZmZlciA9PiB7XG4gICAgY29uc3Qga2V5cGFpcjpBVk1LZXlQYWlyID0gbmV3IEFWTUtleVBhaXIodGhpcy5ocnAsIHRoaXMuY2hhaW5pZCk7XG4gICAgbGV0IHBrOkJ1ZmZlcjtcbiAgICBpZiAodHlwZW9mIHByaXZrID09PSAnc3RyaW5nJykge1xuICAgICAgcGsgPSBiaW50b29scy5jYjU4RGVjb2RlKHByaXZrLnNwbGl0KCctJylbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwayA9IGJpbnRvb2xzLmNvcHlGcm9tKHByaXZrKTtcbiAgICB9XG4gICAga2V5cGFpci5pbXBvcnRLZXkocGspO1xuICAgIGlmICghKGtleXBhaXIuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKSBpbiB0aGlzLmtleXMpKSB7XG4gICAgICB0aGlzLmFkZEtleShrZXlwYWlyKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXBhaXIuZ2V0QWRkcmVzcygpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIERFUFJFQ0FURUQ6IHVzZSBVbnNpZ25lZFR4LnNpZ24oa2V5Y2hhaW4pIGluc3RlYWRcbiAgICAgKiBTaWducyBhIFtbVW5zaWduZWRUeF1dIGFuZCByZXR1cm5zIHNpZ25lZCBbW1R4XV1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHggQSBbW1Vuc2lnbmVkVHhdXSB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzaWduZWQgW1tUeF1dXG4gICAgICovXG4gIHNpZ25UeCA9ICh1dHg6VW5zaWduZWRUeCk6VHggPT4gdXR4LnNpZ24odGhpcyk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiBBVk1LZXlDaGFpbi5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoaHJwOnN0cmluZywgY2hhaW5pZDpzdHJpbmcpIHtcbiAgICBzdXBlcihocnAsIGNoYWluaWQpO1xuICB9XG59XG4iXX0=