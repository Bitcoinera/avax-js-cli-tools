"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnixNow = exports.InitialStates = exports.UTXOID = exports.Address = exports.Signature = exports.SigIdx = exports.AVMConstants = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI-Types
 */
const buffer_1 = require("buffer/");
const bn_js_1 = __importDefault(require("bn.js"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("../../utils/types");
const outputs_1 = require("./outputs");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
class AVMConstants {
}
exports.AVMConstants = AVMConstants;
AVMConstants.LATESTCODEC = 0;
AVMConstants.ONEAVAX = new bn_js_1.default(1000000000);
AVMConstants.DECIAVAX = AVMConstants.ONEAVAX.div(new bn_js_1.default(10));
AVMConstants.CENTIAVAX = AVMConstants.ONEAVAX.div(new bn_js_1.default(100));
AVMConstants.MILLIAVAX = AVMConstants.ONEAVAX.div(new bn_js_1.default(1000));
AVMConstants.MICROAVAX = AVMConstants.ONEAVAX.div(new bn_js_1.default(1000000));
AVMConstants.SECPFXID = 0;
AVMConstants.NFTFXID = 1;
AVMConstants.SECPOUTPUTID = 7;
AVMConstants.NFTXFEROUTPUTID = 11;
AVMConstants.NFTMINTOUTPUTID = 10;
AVMConstants.SECPINPUTID = 5;
AVMConstants.NFTMINTOPID = 12;
AVMConstants.NFTXFEROP = 13;
AVMConstants.BASETX = 0;
AVMConstants.CREATEASSETTX = 1;
AVMConstants.OPERATIONTX = 2;
AVMConstants.IMPORTTX = 3;
AVMConstants.EXPORTTX = 4;
AVMConstants.SECPCREDENTIAL = 9;
AVMConstants.NFTCREDENTIAL = 14;
AVMConstants.ASSETIDLEN = 32;
AVMConstants.BLOCKCHAINIDLEN = 32;
AVMConstants.SYMBOLMAXLEN = 4;
AVMConstants.ASSETNAMELEN = 128;
AVMConstants.ADDRESSLENGTH = 20;
/**
 * Type representing a [[Signature]] index used in [[Input]]
 */
class SigIdx extends types_1.NBytes {
    /**
       * Type representing a [[Signature]] index used in [[Input]]
       */
    constructor() {
        super();
        /**
           * Sets the source address for the signature
           */
        this.setSource = (address) => {
            this.source = address;
        };
        /**
           * Retrieves the source address for the signature
           */
        this.getSource = () => this.source;
        this.bytes = buffer_1.Buffer.alloc(4);
        this.bsize = 4;
    }
}
exports.SigIdx = SigIdx;
/**
 * Signature for a [[Tx]]
 */
class Signature extends types_1.NBytes {
    /**
       * Signature for a [[Tx]]
       */
    constructor() {
        super();
        this.bytes = buffer_1.Buffer.alloc(65);
        this.bsize = 65;
    }
}
exports.Signature = Signature;
/**
 * Class for representing an address used in [[Output]] types
 */
class Address extends types_1.NBytes {
    /**
       * Class for representing an address used in [[Output]] types
       */
    constructor() {
        super();
        this.bytes = buffer_1.Buffer.alloc(20);
        this.bsize = 20;
    }
    /**
       * Returns a base-58 representation of the [[Address]].
       */
    toString() {
        return bintools.cb58Encode(this.toBuffer());
    }
    /**
       * Takes a base-58 string containing an [[Address]], parses it, populates the class, and returns the length of the Address in bytes.
       *
       * @param bytes A base-58 string containing a raw [[Address]]
       *
       * @returns The length of the raw [[Address]]
       */
    fromString(addr) {
        const addrbuff = bintools.b58ToBuffer(addr);
        if (addrbuff.length === 24 && bintools.validateChecksum(addrbuff)) {
            const newbuff = bintools.copyFrom(addrbuff, 0, addrbuff.length - 4);
            if (newbuff.length === 20) {
                this.bytes = newbuff;
            }
        }
        else if (addrbuff.length === 24) {
            throw new Error('Error - Address.fromString: invalid checksum on address');
        }
        else if (addrbuff.length === 20) {
            this.bytes = addrbuff;
        }
        else {
            /* istanbul ignore next */
            throw new Error('Error - Address.fromString: invalid address');
        }
        return this.getSize();
    }
}
exports.Address = Address;
/**
   * Returns a function used to sort an array of [[Address]]es
   */
Address.comparator = () => (a, b) => buffer_1.Buffer.compare(a.toBuffer(), b.toBuffer());
/**
 * Class for representing a UTXOID used in [[TransferableOp]] types
 */
class UTXOID extends types_1.NBytes {
    /**
       * Class for representing a UTXOID used in [[TransferableOp]] types
       */
    constructor() {
        super();
        this.bytes = buffer_1.Buffer.alloc(36);
        this.bsize = 36;
    }
    /**
       * Returns a base-58 representation of the [[UTXOID]].
       */
    toString() {
        return bintools.cb58Encode(this.toBuffer());
    }
    /**
       * Takes a base-58 string containing an [[UTXOID]], parses it, populates the class, and returns the length of the UTXOID in bytes.
       *
       * @param bytes A base-58 string containing a raw [[UTXOID]]
       *
       * @returns The length of the raw [[UTXOID]]
       */
    fromString(utxoid) {
        const utxoidbuff = bintools.b58ToBuffer(utxoid);
        if (utxoidbuff.length === 40 && bintools.validateChecksum(utxoidbuff)) {
            const newbuff = bintools.copyFrom(utxoidbuff, 0, utxoidbuff.length - 4);
            if (newbuff.length === 36) {
                this.bytes = newbuff;
            }
        }
        else if (utxoidbuff.length === 40) {
            throw new Error('Error - UTXOID.fromString: invalid checksum on address');
        }
        else if (utxoidbuff.length === 36) {
            this.bytes = utxoidbuff;
        }
        else {
            /* istanbul ignore next */
            throw new Error('Error - UTXOID.fromString: invalid address');
        }
        return this.getSize();
    }
}
exports.UTXOID = UTXOID;
/**
   * Returns a function used to sort an array of [[UTXOID]]s
   */
UTXOID.comparator = () => (a, b) => buffer_1.Buffer.compare(a.toBuffer(), b.toBuffer());
/**
 * Class for creating initial output states used in asset creation
 */
class InitialStates {
    constructor() {
        this.fxs = {};
    }
    /**
       *
       * @param out The output state to add to the collection
       * @param fxid The FxID that will be used for this output, default AVMConstants.SECPFXID
       */
    addOutput(out, fxid = AVMConstants.SECPFXID) {
        if (!(fxid in this.fxs)) {
            this.fxs[fxid] = [];
        }
        this.fxs[fxid].push(out);
    }
    fromBuffer(bytes, offset = 0) {
        const result = [];
        const klen = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const klennum = klen.readUInt32BE(0);
        for (let i = 0; i < klennum; i++) {
            const fxidbuff = bintools.copyFrom(bytes, offset, offset + 4);
            offset += 4;
            const fxid = fxidbuff.readUInt32BE(0);
            result[fxid] = [];
            const statelenbuff = bintools.copyFrom(bytes, offset, offset + 4);
            offset += 4;
            const statelen = statelenbuff.readUInt32BE(0);
            for (let j = 0; j < statelen; j++) {
                const outputid = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
                offset += 4;
                const out = outputs_1.SelectOutputClass(outputid);
                offset = out.fromBuffer(bytes, offset);
                result[fxid].push(out);
            }
        }
        this.fxs = result;
        return offset;
    }
    toBuffer() {
        const buff = [];
        const keys = Object.keys(this.fxs).map((k) => parseInt(k, 10)).sort();
        const klen = buffer_1.Buffer.alloc(4);
        klen.writeUInt32BE(keys.length, 0);
        buff.push(klen);
        for (let i = 0; i < keys.length; i++) {
            const fxid = keys[i];
            const fxidbuff = buffer_1.Buffer.alloc(4);
            fxidbuff.writeUInt32BE(fxid, 0);
            buff.push(fxidbuff);
            const initialState = this.fxs[fxid].sort(outputs_1.Output.comparator());
            const statelen = buffer_1.Buffer.alloc(4);
            statelen.writeUInt32BE(initialState.length, 0);
            buff.push(statelen);
            for (let j = 0; j < initialState.length; j++) {
                const outputid = buffer_1.Buffer.alloc(4);
                outputid.writeInt32BE(initialState[j].getOutputID(), 0);
                buff.push(outputid);
                buff.push(initialState[j].toBuffer());
            }
        }
        return buffer_1.Buffer.concat(buff);
    }
}
exports.InitialStates = InitialStates;
/**
 * Function providing the current UNIX time using a {@link https://github.com/indutny/bn.js/|BN}
 */
function UnixNow() {
    return new bn_js_1.default(Math.round((new Date()).getTime() / 1000));
}
exports.UnixNow = UnixNow;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpcy9hdm0vdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztHQUdHO0FBQ0gsb0NBQWlDO0FBQ2pDLGtEQUF1QjtBQUN2QixvRUFBNEM7QUFFNUMsNkNBQTJDO0FBQzNDLHVDQUFzRDtBQUV0RDs7R0FFRztBQUNILE1BQU0sUUFBUSxHQUFZLGtCQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFFakQsTUFBYSxZQUFZOztBQUF6QixvQ0FvREM7QUFuRFEsd0JBQVcsR0FBVSxDQUFDLENBQUM7QUFFdkIsb0JBQU8sR0FBTSxJQUFJLGVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUVoQyxxQkFBUSxHQUFNLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksZUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFFbkQsc0JBQVMsR0FBTSxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLGVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBRXJELHNCQUFTLEdBQU0sWUFBWSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxlQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUV0RCxzQkFBUyxHQUFNLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksZUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFFekQscUJBQVEsR0FBVSxDQUFDLENBQUM7QUFFcEIsb0JBQU8sR0FBVSxDQUFDLENBQUM7QUFFbkIseUJBQVksR0FBVSxDQUFDLENBQUM7QUFFeEIsNEJBQWUsR0FBVSxFQUFFLENBQUM7QUFFNUIsNEJBQWUsR0FBVSxFQUFFLENBQUM7QUFFNUIsd0JBQVcsR0FBVSxDQUFDLENBQUM7QUFFdkIsd0JBQVcsR0FBVSxFQUFFLENBQUM7QUFFeEIsc0JBQVMsR0FBVSxFQUFF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QUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDNUMsTUFBTSxRQUFRLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDeEMsUUFBUSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7YUFDdkM7U0FDRjtRQUNELE9BQU8sZUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixDQUFDO0NBR0Y7QUFsRUQsc0NBa0VDO0FBY0Q7O0dBRUc7QUFDSCxTQUFnQixPQUFPO0lBQ3JCLE9BQU8sSUFBSSxlQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUM7QUFGRCwwQkFFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEFWTUFQSS1UeXBlc1xuICovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXIvJztcbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgQmluVG9vbHMgZnJvbSAnLi4vLi4vdXRpbHMvYmludG9vbHMnO1xuXG5pbXBvcnQgeyBOQnl0ZXMgfSBmcm9tICcuLi8uLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBPdXRwdXQsIFNlbGVjdE91dHB1dENsYXNzIH0gZnJvbSAnLi9vdXRwdXRzJztcblxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IGJpbnRvb2xzOkJpblRvb2xzID0gQmluVG9vbHMuZ2V0SW5zdGFuY2UoKTtcblxuZXhwb3J0IGNsYXNzIEFWTUNvbnN0YW50cyB7XG4gIHN0YXRpYyBMQVRFU1RDT0RFQzpudW1iZXIgPSAwO1xuXG4gIHN0YXRpYyBPTkVBVkFYOkJOID0gbmV3IEJOKDEwMDAwMDAwMDApO1xuXG4gIHN0YXRpYyBERUNJQVZBWDpCTiA9IEFWTUNvbnN0YW50cy5PTkVBVkFYLmRpdihuZXcgQk4oMTApKTtcblxuICBzdGF0aWMgQ0VOVElBVkFYOkJOID0gQVZNQ29uc3RhbnRzLk9ORUFWQVguZGl2KG5ldyBCTigxMDApKTtcblxuICBzdGF0aWMgTUlMTElBVkFYOkJOID0gQVZNQ29uc3RhbnRzLk9ORUFWQVguZGl2KG5ldyBCTigxMDAwKSk7XG5cbiAgc3RhdGljIE1JQ1JPQVZBWDpCTiA9IEFWTUNvbnN0YW50cy5PTkVBVkFYLmRpdihuZXcgQk4oMTAwMDAwMCkpO1xuXG4gIHN0YXRpYyBTRUNQRlhJRDpudW1iZXIgPSAwO1xuXG4gIHN0YXRpYyBORlRGWElEOm51bWJlciA9IDE7XG5cbiAgc3RhdGljIFNFQ1BPVVRQVVRJRDpudW1iZXIgPSA3O1xuXG4gIHN0YXRpYyBORlRYRkVST1VUUFVUSUQ6bnVtYmVyID0gMTE7XG5cbiAgc3RhdGljIE5GVE1JTlRPVVRQVVRJRDpudW1iZXIgPSAxMDtcblxuICBzdGF0aWMgU0VDUElOUFVUSUQ6bnVtYmVyID0gNTtcblxuICBzdGF0aWMgTkZUTUlOVE9QSUQ6bnVtYmVyID0gMTI7XG5cbiAgc3RhdGljIE5GVFhGRVJPUDpudW1iZXIgPSAxMztcblxuICBzdGF0aWMgQkFTRVRYOm51bWJlciA9IDA7XG5cbiAgc3RhdGljIENSRUFURUFTU0VUVFg6bnVtYmVyID0gMTtcblxuICBzdGF0aWMgT1BFUkFUSU9OVFg6bnVtYmVyID0gMjtcblxuICBzdGF0aWMgSU1QT1JUVFg6bnVtYmVyID0gMztcblxuICBzdGF0aWMgRVhQT1JUVFg6bnVtYmVyID0gNDtcblxuICBzdGF0aWMgU0VDUENSRURFTlRJQUw6bnVtYmVyID0gOTtcblxuICBzdGF0aWMgTkZUQ1JFREVOVElBTDpudW1iZXIgPSAxNDtcblxuICBzdGF0aWMgQVNTRVRJRExFTjpudW1iZXIgPSAzMjtcblxuICBzdGF0aWMgQkxPQ0tDSEFJTklETEVOOm51bWJlciA9IDMyO1xuXG4gIHN0YXRpYyBTWU1CT0xNQVhMRU46bnVtYmVyID0gNDtcblxuICBzdGF0aWMgQVNTRVROQU1FTEVOOm51bWJlciA9IDEyODtcblxuICBzdGF0aWMgQUREUkVTU0xFTkdUSDpudW1iZXIgPSAyMDtcbn1cblxuLyoqXG4gKiBUeXBlIHJlcHJlc2VudGluZyBhIFtbU2lnbmF0dXJlXV0gaW5kZXggdXNlZCBpbiBbW0lucHV0XV1cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ0lkeCBleHRlbmRzIE5CeXRlcyB7XG4gIHNvdXJjZTpCdWZmZXI7XG5cbiAgLyoqXG4gICAgICogU2V0cyB0aGUgc291cmNlIGFkZHJlc3MgZm9yIHRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgc2V0U291cmNlID0gKGFkZHJlc3M6QnVmZmVyKSA9PiB7XG4gICAgdGhpcy5zb3VyY2UgPSBhZGRyZXNzO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgc291cmNlIGFkZHJlc3MgZm9yIHRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgZ2V0U291cmNlID0gKCk6QnVmZmVyID0+IHRoaXMuc291cmNlO1xuXG4gIC8qKlxuICAgICAqIFR5cGUgcmVwcmVzZW50aW5nIGEgW1tTaWduYXR1cmVdXSBpbmRleCB1c2VkIGluIFtbSW5wdXRdXVxuICAgICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYnl0ZXMgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgdGhpcy5ic2l6ZSA9IDQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaWduYXR1cmUgZm9yIGEgW1tUeF1dXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWduYXR1cmUgZXh0ZW5kcyBOQnl0ZXMge1xuICAvKipcbiAgICAgKiBTaWduYXR1cmUgZm9yIGEgW1tUeF1dXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ieXRlcyA9IEJ1ZmZlci5hbGxvYyg2NSk7XG4gICAgdGhpcy5ic2l6ZSA9IDY1O1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhbiBhZGRyZXNzIHVzZWQgaW4gW1tPdXRwdXRdXSB0eXBlc1xuICovXG5leHBvcnQgY2xhc3MgQWRkcmVzcyBleHRlbmRzIE5CeXRlcyB7XG4gIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgYW4gYXJyYXkgb2YgW1tBZGRyZXNzXV1lc1xuICAgICAqL1xuICBzdGF0aWMgY29tcGFyYXRvciA9ICgpXG4gICAgOihhOkFkZHJlc3MsIGI6QWRkcmVzcykgPT4gKDF8LTF8MCkgPT4gKGE6QWRkcmVzcywgYjpBZGRyZXNzKVxuICAgIDooMXwtMXwwKSA9PiBCdWZmZXIuY29tcGFyZShhLnRvQnVmZmVyKCksIGIudG9CdWZmZXIoKSkgYXMgKDF8LTF8MCk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbQWRkcmVzc11dLlxuICAgICAqL1xuICB0b1N0cmluZygpOnN0cmluZyB7XG4gICAgcmV0dXJuIGJpbnRvb2xzLmNiNThFbmNvZGUodGhpcy50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEgYmFzZS01OCBzdHJpbmcgY29udGFpbmluZyBhbiBbW0FkZHJlc3NdXSwgcGFyc2VzIGl0LCBwb3B1bGF0ZXMgdGhlIGNsYXNzLCBhbmQgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBBZGRyZXNzIGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIEEgYmFzZS01OCBzdHJpbmcgY29udGFpbmluZyBhIHJhdyBbW0FkZHJlc3NdXVxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aCBvZiB0aGUgcmF3IFtbQWRkcmVzc11dXG4gICAgICovXG4gIGZyb21TdHJpbmcoYWRkcjpzdHJpbmcpOm51bWJlciB7XG4gICAgY29uc3QgYWRkcmJ1ZmY6QnVmZmVyID0gYmludG9vbHMuYjU4VG9CdWZmZXIoYWRkcik7XG4gICAgaWYgKGFkZHJidWZmLmxlbmd0aCA9PT0gMjQgJiYgYmludG9vbHMudmFsaWRhdGVDaGVja3N1bShhZGRyYnVmZikpIHtcbiAgICAgIGNvbnN0IG5ld2J1ZmY6QnVmZmVyID0gYmludG9vbHMuY29weUZyb20oYWRkcmJ1ZmYsIDAsIGFkZHJidWZmLmxlbmd0aCAtIDQpO1xuICAgICAgaWYgKG5ld2J1ZmYubGVuZ3RoID09PSAyMCkge1xuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3YnVmZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFkZHJidWZmLmxlbmd0aCA9PT0gMjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBBZGRyZXNzLmZyb21TdHJpbmc6IGludmFsaWQgY2hlY2tzdW0gb24gYWRkcmVzcycpO1xuICAgIH0gZWxzZSBpZiAoYWRkcmJ1ZmYubGVuZ3RoID09PSAyMCkge1xuICAgICAgdGhpcy5ieXRlcyA9IGFkZHJidWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIEFkZHJlc3MuZnJvbVN0cmluZzogaW52YWxpZCBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFNpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIENsYXNzIGZvciByZXByZXNlbnRpbmcgYW4gYWRkcmVzcyB1c2VkIGluIFtbT3V0cHV0XV0gdHlwZXNcbiAgICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJ5dGVzID0gQnVmZmVyLmFsbG9jKDIwKTtcbiAgICB0aGlzLmJzaXplID0gMjA7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgVVRYT0lEIHVzZWQgaW4gW1tUcmFuc2ZlcmFibGVPcF1dIHR5cGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBVVFhPSUQgZXh0ZW5kcyBOQnl0ZXMge1xuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdXNlZCB0byBzb3J0IGFuIGFycmF5IG9mIFtbVVRYT0lEXV1zXG4gICAgICovXG4gIHN0YXRpYyBjb21wYXJhdG9yID0gKCk6KGE6VVRYT0lELCBiOlVUWE9JRCkgPT4gKDF8LTF8MCkgPT4gKGE6VVRYT0lELCBiOlVUWE9JRClcbiAgICA6KDF8LTF8MCkgPT4gQnVmZmVyLmNvbXBhcmUoYS50b0J1ZmZlcigpLCBiLnRvQnVmZmVyKCkpIGFzICgxfC0xfDApO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBbW1VUWE9JRF1dLlxuICAgICAqL1xuICB0b1N0cmluZygpOnN0cmluZyB7XG4gICAgcmV0dXJuIGJpbnRvb2xzLmNiNThFbmNvZGUodGhpcy50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEgYmFzZS01OCBzdHJpbmcgY29udGFpbmluZyBhbiBbW1VUWE9JRF1dLCBwYXJzZXMgaXQsIHBvcHVsYXRlcyB0aGUgY2xhc3MsIGFuZCByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIFVUWE9JRCBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBBIGJhc2UtNTggc3RyaW5nIGNvbnRhaW5pbmcgYSByYXcgW1tVVFhPSURdXVxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxlbmd0aCBvZiB0aGUgcmF3IFtbVVRYT0lEXV1cbiAgICAgKi9cbiAgZnJvbVN0cmluZyh1dHhvaWQ6c3RyaW5nKTpudW1iZXIge1xuICAgIGNvbnN0IHV0eG9pZGJ1ZmY6QnVmZmVyID0gYmludG9vbHMuYjU4VG9CdWZmZXIodXR4b2lkKTtcbiAgICBpZiAodXR4b2lkYnVmZi5sZW5ndGggPT09IDQwICYmIGJpbnRvb2xzLnZhbGlkYXRlQ2hlY2tzdW0odXR4b2lkYnVmZikpIHtcbiAgICAgIGNvbnN0IG5ld2J1ZmY6QnVmZmVyID0gYmludG9vbHMuY29weUZyb20odXR4b2lkYnVmZiwgMCwgdXR4b2lkYnVmZi5sZW5ndGggLSA0KTtcbiAgICAgIGlmIChuZXdidWZmLmxlbmd0aCA9PT0gMzYpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IG5ld2J1ZmY7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh1dHhvaWRidWZmLmxlbmd0aCA9PT0gNDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgLSBVVFhPSUQuZnJvbVN0cmluZzogaW52YWxpZCBjaGVja3N1bSBvbiBhZGRyZXNzJyk7XG4gICAgfSBlbHNlIGlmICh1dHhvaWRidWZmLmxlbmd0aCA9PT0gMzYpIHtcbiAgICAgIHRoaXMuYnl0ZXMgPSB1dHhvaWRidWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIFVUWE9JRC5mcm9tU3RyaW5nOiBpbnZhbGlkIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2l6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIFVUWE9JRCB1c2VkIGluIFtbVHJhbnNmZXJhYmxlT3BdXSB0eXBlc1xuICAgICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYnl0ZXMgPSBCdWZmZXIuYWxsb2MoMzYpO1xuICAgIHRoaXMuYnNpemUgPSAzNjtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIGZvciBjcmVhdGluZyBpbml0aWFsIG91dHB1dCBzdGF0ZXMgdXNlZCBpbiBhc3NldCBjcmVhdGlvblxuICovXG5leHBvcnQgY2xhc3MgSW5pdGlhbFN0YXRlcyB7XG4gIHByb3RlY3RlZCBmeHM6e1tmeGlkOm51bWJlcl06QXJyYXk8T3V0cHV0Pn0gPSB7fTtcblxuICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdXQgVGhlIG91dHB1dCBzdGF0ZSB0byBhZGQgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZnhpZCBUaGUgRnhJRCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhpcyBvdXRwdXQsIGRlZmF1bHQgQVZNQ29uc3RhbnRzLlNFQ1BGWElEXG4gICAgICovXG4gIGFkZE91dHB1dChvdXQ6T3V0cHV0LCBmeGlkOm51bWJlciA9IEFWTUNvbnN0YW50cy5TRUNQRlhJRCk6dm9pZCB7XG4gICAgaWYgKCEoZnhpZCBpbiB0aGlzLmZ4cykpIHtcbiAgICAgIHRoaXMuZnhzW2Z4aWRdID0gW107XG4gICAgfVxuICAgIHRoaXMuZnhzW2Z4aWRdLnB1c2gob3V0KTtcbiAgfVxuXG4gIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICBjb25zdCByZXN1bHQ6e1tmeGlkOm51bWJlcl06QXJyYXk8T3V0cHV0Pn0gPSBbXTtcbiAgICBjb25zdCBrbGVuOkJ1ZmZlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IGtsZW5udW06bnVtYmVyID0ga2xlbi5yZWFkVUludDMyQkUoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrbGVubnVtOyBpKyspIHtcbiAgICAgIGNvbnN0IGZ4aWRidWZmOkJ1ZmZlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBjb25zdCBmeGlkOm51bWJlciA9IGZ4aWRidWZmLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgIHJlc3VsdFtmeGlkXSA9IFtdO1xuICAgICAgY29uc3Qgc3RhdGVsZW5idWZmOkJ1ZmZlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBjb25zdCBzdGF0ZWxlbjpudW1iZXIgPSBzdGF0ZWxlbmJ1ZmYucmVhZFVJbnQzMkJFKDApO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZWxlbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dGlkOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpLnJlYWRVSW50MzJCRSgwKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGNvbnN0IG91dDpPdXRwdXQgPSBTZWxlY3RPdXRwdXRDbGFzcyhvdXRwdXRpZCk7XG4gICAgICAgIG9mZnNldCA9IG91dC5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICByZXN1bHRbZnhpZF0ucHVzaChvdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZ4cyA9IHJlc3VsdDtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgdG9CdWZmZXIoKTpCdWZmZXIge1xuICAgIGNvbnN0IGJ1ZmY6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgIGNvbnN0IGtleXM6QXJyYXk8bnVtYmVyPiA9IE9iamVjdC5rZXlzKHRoaXMuZnhzKS5tYXAoKGspID0+IHBhcnNlSW50KGssIDEwKSkuc29ydCgpO1xuICAgIGNvbnN0IGtsZW46QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGtsZW4ud3JpdGVVSW50MzJCRShrZXlzLmxlbmd0aCwgMCk7XG4gICAgYnVmZi5wdXNoKGtsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZnhpZDpudW1iZXIgPSBrZXlzW2ldO1xuICAgICAgY29uc3QgZnhpZGJ1ZmY6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgZnhpZGJ1ZmYud3JpdGVVSW50MzJCRShmeGlkLCAwKTtcbiAgICAgIGJ1ZmYucHVzaChmeGlkYnVmZik7XG4gICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB0aGlzLmZ4c1tmeGlkXS5zb3J0KE91dHB1dC5jb21wYXJhdG9yKCkpO1xuICAgICAgY29uc3Qgc3RhdGVsZW46QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgc3RhdGVsZW4ud3JpdGVVSW50MzJCRShpbml0aWFsU3RhdGUubGVuZ3RoLCAwKTtcbiAgICAgIGJ1ZmYucHVzaChzdGF0ZWxlbik7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluaXRpYWxTdGF0ZS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBvdXRwdXRpZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIG91dHB1dGlkLndyaXRlSW50MzJCRShpbml0aWFsU3RhdGVbal0uZ2V0T3V0cHV0SUQoKSwgMCk7XG4gICAgICAgIGJ1ZmYucHVzaChvdXRwdXRpZCk7XG4gICAgICAgIGJ1ZmYucHVzaChpbml0aWFsU3RhdGVbal0udG9CdWZmZXIoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmYpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7fVxufVxuXG4vKipcbiAqIFJ1bGVzIHVzZWQgd2hlbiBtZXJnaW5nIHNldHNcbiAqL1xuZXhwb3J0IHR5cGUgTWVyZ2VSdWxlID0gJ2ludGVyc2VjdGlvbicgLy8gU2VsZiBJTlRFUlNFQ1QgTmV3XG58ICdkaWZmZXJlbmNlU2VsZicgLy8gU2VsZiBNSU5VUyBOZXdcbnwgJ2RpZmZlcmVuY2VOZXcnIC8vIE5ldyBNSU5VUyBTZWxmXG58ICdzeW1EaWZmZXJlbmNlJyAvLyBkaWZmZXJlbmNlU2VsZiBVTklPTiBkaWZmZXJlbmNlTmV3XG58ICd1bmlvbicgLy8gU2VsZiBVTklPTiBOZXdcbnwgJ3VuaW9uTWludXNOZXcnIC8vIHVuaW9uIE1JTlVTIGRpZmZlcmVuY2VOZXdcbnwgJ3VuaW9uTWludXNTZWxmJyAvLyB1bmlvbiBNSU5VUyBkaWZmZXJlbmNlU2VsZlxufCAnRVJST1InOyAvLyBnZW5lcmF0ZSBlcnJvciBmb3IgdGVzdGluZ1xuXG4vKipcbiAqIEZ1bmN0aW9uIHByb3ZpZGluZyB0aGUgY3VycmVudCBVTklYIHRpbWUgdXNpbmcgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICovXG5leHBvcnQgZnVuY3Rpb24gVW5peE5vdygpOkJOIHtcbiAgcmV0dXJuIG5ldyBCTihNYXRoLnJvdW5kKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLyAxMDAwKSk7XG59XG4iXX0=