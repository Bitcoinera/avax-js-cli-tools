"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistanceOptions = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI
 */
const bn_js_1 = __importDefault(require("bn.js"));
const buffer_1 = require("buffer/");
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("../../utils/types");
const utxos_1 = require("./utxos");
const types_2 = require("./types");
const keychain_1 = require("./keychain");
const tx_1 = require("./tx");
const payload_1 = require("../../utils/payload");
const inputs_1 = require("./inputs");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * A class for defining the persistance behavior of this an API call.
 *
 */
class PersistanceOptions {
    /**
       *
       * @param name The namespace of the database the data
       * @param overwrite True if the data should be completey overwritten
       * @param MergeRule The type of process used to merge with existing data: "intersection", "differenceSelf", "differenceNew", "symDifference", "union", "unionMinusNew", "unionMinusSelf"
       *
       * @remarks
       * The merge rules are as follows:
       *   * "intersection" - the intersection of the set
       *   * "differenceSelf" - the difference between the existing data and new set
       *   * "differenceNew" - the difference between the new data and the existing set
       *   * "symDifference" - the union of the differences between both sets of data
       *   * "union" - the unique set of all elements contained in both sets
       *   * "unionMinusNew" - the unique set of all elements contained in both sets, excluding values only found in the new set
       *   * "unionMinusSelf" - the unique set of all elements contained in both sets, excluding values only found in the existing set
       */
    constructor(name, overwrite = false, mergeRule) {
        this.name = undefined;
        this.overwrite = false;
        this.mergeRule = 'union';
        /**
           * Returns the namespace of the instance
           */
        this.getName = () => this.name;
        /**
           * Returns the overwrite rule of the instance
           */
        this.getOverwrite = () => this.overwrite;
        /**
           * Returns the [[MergeRule]] of the instance
           */
        this.getMergeRule = () => this.mergeRule;
        this.name = name;
        this.overwrite = overwrite;
        this.mergeRule = mergeRule;
    }
}
exports.PersistanceOptions = PersistanceOptions;
/**
 * Class for interacting with a node endpoint that is using the AVM.
 *
 * @category RPCAPIs
 *
 * @remarks This extends the [[JRPCAPI]] class. This class should not be directly called. Instead, use the [[Avalanche.addAPI]] function to register this interface with Avalanche.
 */
class AVMAPI extends types_1.JRPCAPI {
    /**
       * This class should not be instantiated directly. Instead use the [[Avalanche.addAPI]] method.
       *
       * @param core A reference to the Avalanche class
       * @param baseurl Defaults to the string "/ext/bc/avm" as the path to blockchain's baseurl
       */
    constructor(core, baseurl = '/ext/bc/avm', blockchainID = '') {
        super(core, baseurl);
        /**
           * @ignore
           */
        this.keychain = new keychain_1.AVMKeyChain('', '');
        this.blockchainID = '';
        this.AVAXAssetID = undefined;
        /**
           * Gets the alias for the blockchainID if it exists, otherwise returns `undefined`.
           *
           * @returns The alias for the blockchainID
           */
        this.getBlockchainAlias = () => {
            const netid = this.core.getNetworkID();
            if (netid in types_1.Defaults.network && this.blockchainID in types_1.Defaults.network[netid]) {
                return types_1.Defaults.network[netid][this.blockchainID].alias;
            }
            /* istanbul ignore next */
            return undefined;
        };
        /**
           * Gets the blockchainID and returns it.
           *
           * @returns The blockchainID
           */
        this.getBlockchainID = () => this.blockchainID;
        /**
           * Refresh blockchainID, and if a blockchainID is passed in, use that.
           *
           * @param Optional. BlockchainID to assign, if none, uses the default based on networkID.
           *
           * @returns The blockchainID
           */
        this.refreshBlockchainID = (blockchainID = undefined) => {
            const netid = this.core.getNetworkID();
            if (typeof blockchainID === 'undefined' && typeof types_1.Defaults.network[netid] !== "undefined") {
                this.blockchainID = types_1.Defaults.network[netid].avm.blockchainID;
                return true;
            }
            if (typeof blockchainID === 'string') {
                this.blockchainID = blockchainID;
                return true;
            }
            return false;
        };
        /**
           * Takes an address string and returns its {@link https://github.com/feross/buffer|Buffer} representation if valid.
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} for the address if valid, undefined if not valid.
           */
        this.parseAddress = (addr) => {
            const alias = this.getBlockchainAlias();
            const blockchainID = this.getBlockchainID();
            return bintools.parseAddress(addr, blockchainID, alias, types_2.AVMConstants.ADDRESSLENGTH);
        };
        this.addressFromBuffer = (address) => {
            const chainid = this.getBlockchainAlias() ? this.getBlockchainAlias() : this.getBlockchainID();
            return bintools.addressToString(this.core.getHRP(), chainid, address);
        };
        /**
           * Fetches the AVAX AssetID and returns it in a Promise.
           *
           * @returns The the provided string representing the blockchainID
           */
        this.getAVAXAssetID = () => __awaiter(this, void 0, void 0, function* () {
            if (typeof this.AVAXAssetID === 'undefined') {
                const asset = yield this.getAssetDescription('AVAX');
                // TODO - Remove hardcoded 'AVAX'
                this.AVAXAssetID = asset.assetID;
            }
            return this.AVAXAssetID;
        });
        /**
           * Gets a reference to the keychain for this class.
           *
           * @returns The instance of [[AVMKeyChain]] for this class
           */
        this.keyChain = () => this.keychain;
        /**
           * @ignore
           */
        this.newKeyChain = () => {
            // warning, overwrites the old keychain
            const alias = this.getBlockchainAlias();
            if (alias) {
                this.keychain = new keychain_1.AVMKeyChain(this.core.getHRP(), alias);
            }
            else {
                this.keychain = new keychain_1.AVMKeyChain(this.core.getHRP(), this.blockchainID);
            }
            return this.keychain;
        };
        /**
         * Helper function which determines if a tx is a goose egg transaction.
         *
         * @param utx An UnsignedTx
         *
         * @returns boolean true if passes goose egg test and false if fails.
         *
         * @remarks
         * A "Goose Egg Transaction" is when the fee far exceeds a reasonable amount
         */
        this.checkGooseEgg = (utx) => __awaiter(this, void 0, void 0, function* () {
            const avaxAssetID = yield this.getAVAXAssetID();
            const outputTotal = utx.getOutputTotal(avaxAssetID);
            const fee = utx.getBurn(avaxAssetID);
            if (fee.lte(types_2.AVMConstants.ONEAVAX.mul(new bn_js_1.default(10))) || fee.lte(outputTotal)) {
                return true;
            }
            else {
                return false;
            }
        });
        /**
           * Gets the balance of a particular asset on a blockchain.
           *
           * @param address The address to pull the asset balance from
           * @param assetID The assetID to pull the balance from
           *
           * @returns Promise with the balance of the assetID as a {@link https://github.com/indutny/bn.js/|BN} on the provided address for the blockchain.
           */
        this.getBalance = (address, assetID) => __awaiter(this, void 0, void 0, function* () {
            if (typeof this.parseAddress(address) === 'undefined') {
                /* istanbul ignore next */
                throw new Error(`Error - AVMAPI.getBalance: Invalid address format ${address}`);
            }
            const params = {
                address,
                assetID,
            };
            return this.callMethod('avm.getBalance', params).then((response) => new bn_js_1.default(response.data.result.balance, 10));
        });
        /**
           * Creates an address (and associated private keys) on a user on a blockchain.
           *
           * @param username Name of the user to create the address under
           * @param password Password to unlock the user and encrypt the private key
           *
           * @returns Promise for a string representing the address created by the vm.
           */
        this.createAddress = (username, password) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
            };
            return this.callMethod('avm.createAddress', params).then((response) => response.data.result.address);
        });
        /**
           * Create a new fixed-cap, fungible asset. A quantity of it is created at initialization and there no more is ever created.
           *
           * @param username The user paying the transaction fee (in $AVAX) for asset creation
           * @param password The password for the user paying the transaction fee (in $AVAX) for asset creation
           * @param name The human-readable name for the asset
           * @param symbol Optional. The shorthand symbol for the asset. Between 0 and 4 characters
           * @param denomination Optional. Determines how balances of this asset are displayed by user interfaces. Default is 0
           * @param initialHolders An array of objects containing the field "address" and "amount" to establish the genesis values for the new asset
           *
           * ```js
           * Example initialHolders:
           * [
           *     {
           *         "address": "X-7sik3Pr6r1FeLrvK1oWwECBS8iJ5VPuSh",
           *         "amount": 10000
           *     },
           *     {
           *         "address": "X-7sik3Pr6r1FeLrvK1oWwECBS8iJ5VPuSh",
           *         "amount": 50000
           *     }
           * ]
           * ```
           *
           * @returns Returns a Promise<string> containing the base 58 string representation of the ID of the newly created asset.
           */
        this.createFixedCapAsset = (username, password, name, symbol, denomination, initialHolders) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                name,
                symbol,
                denomination,
                username,
                password,
                initialHolders,
            };
            return this.callMethod('avm.createFixedCapAsset', params).then((response) => response.data.result.assetID);
        });
        /**
           * Create a new variable-cap, fungible asset. No units of the asset exist at initialization. Minters can mint units of this asset using createMintTx, signMintTx and sendMintTx.
           *
           * @param username The user paying the transaction fee (in $AVAX) for asset creation
           * @param password The password for the user paying the transaction fee (in $AVAX) for asset creation
           * @param name The human-readable name for the asset
           * @param symbol Optional. The shorthand symbol for the asset -- between 0 and 4 characters
           * @param denomination Optional. Determines how balances of this asset are displayed by user interfaces. Default is 0
           * @param minterSets is a list where each element specifies that threshold of the addresses in minters may together mint more of the asset by signing a minting transaction
           *
           * ```js
           * Example minterSets:
           * [
           *      {
           *          "minters":[
           *              "X-4peJsFvhdn7XjhNF4HWAQy6YaJts27s9q"
           *          ],
           *          "threshold": 1
           *      },
           *      {
           *          "minters": [
           *              "X-dcJ6z9duLfyQTgbjq2wBCowkvcPZHVDF",
           *              "X-2fE6iibqfERz5wenXE6qyvinsxDvFhHZk",
           *              "X-7ieAJbfrGQbpNZRAQEpZCC1Gs1z5gz4HU"
           *          ],
           *          "threshold": 2
           *      }
           * ]
           * ```
           *
           * @returns Returns a Promise<string> containing the base 58 string representation of the ID of the newly created asset.
           */
        this.createVariableCapAsset = (username, password, name, symbol, denomination, minterSets) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                name,
                symbol,
                denomination,
                username,
                password,
                minterSets,
            };
            return this.callMethod('avm.createVariableCapAsset', params).then((response) => response.data.result.assetID);
        });
        /**
           * Create an unsigned transaction to mint more of an asset.
           *
           * @param amount The units of the asset to mint
           * @param assetID The ID of the asset to mint
           * @param to The address to assign the units of the minted asset
           * @param minters Addresses of the minters responsible for signing the transaction
           *
           * @returns Returns a Promise<string> containing the base 58 string representation of the unsigned transaction.
           */
        this.createMintTx = (amount, assetID, to, minters) => __awaiter(this, void 0, void 0, function* () {
            let asset;
            let amnt;
            if (typeof assetID !== 'string') {
                asset = bintools.cb58Encode(assetID);
            }
            else {
                asset = assetID;
            }
            if (typeof amount === 'number') {
                amnt = new bn_js_1.default(amount);
            }
            else {
                amnt = amount;
            }
            const params = {
                amount: amnt.toString(10),
                assetID: asset,
                to,
                minters,
            };
            return this.callMethod('avm.createMintTx', params).then((response) => response.data.result.tx);
        });
        /**
           * Sign an unsigned or partially signed mint transaction.
           *
           * @param username The user signing
           * @param password The password for the user signing
           * @param tx The output of createMintTx or signMintTx
           * @param minter The minter signing this transaction
           *
           * @returns Returns a Promise<string> containing the base 58 string representation of the unsigned transaction.
           */
        this.signMintTx = (username, password, tx, minter) => __awaiter(this, void 0, void 0, function* () {
            if (typeof this.parseAddress(minter) === 'undefined') {
                /* istanbul ignore next */
                throw new Error(`Error - AVMAPI.signMintTx: Invalid address format ${minter}`);
            }
            const params = {
                username,
                password,
                tx,
                minter,
            };
            return this.callMethod('avm.signMintTx', params).then((response) => response.data.result.tx);
        });
        /**
           * Exports the private key for an address.
           *
           * @param username The name of the user with the private key
           * @param password The password used to decrypt the private key
           * @param address The address whose private key should be exported
           *
           * @returns Promise with the decrypted private key as store in the database
           */
        this.exportKey = (username, password, address) => __awaiter(this, void 0, void 0, function* () {
            if (typeof this.parseAddress(address) === 'undefined') {
                /* istanbul ignore next */
                throw new Error(`Error - AVMAPI.exportKey: Invalid address format ${address}`);
            }
            const params = {
                username,
                password,
                address,
            };
            return this.callMethod('avm.exportKey', params).then((response) => response.data.result.privateKey);
        });
        /**
           * Imports a private key into the node's keystore under an user and for a blockchain.
           *
           * @param username The name of the user to store the private key
           * @param password The password that unlocks the user
           * @param privateKey A string representing the private key in the vm's format
           *
           * @returns The address for the imported private key.
           */
        this.importKey = (username, password, privateKey) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
                privateKey,
            };
            return this.callMethod('avm.importKey', params).then((response) => response.data.result.address);
        });
        /**
           * Send AVAX from the X-Chain to an account on the P-Chain.
           *
           * After calling this method, you must call the P-Chain’s importAVAX method to complete the transfer.
           *
           * @param username The Keystore user that controls the P-Chain account specified in `to`
           * @param password The password of the Keystore user
           * @param to The account on the P-Chain to send the AVAX to. Do not include P- in the address
           * @param amount Amount of AVAX to export as a {@link https://github.com/indutny/bn.js/|BN}
           *
           * @returns String representing the transaction id
           */
        this.exportAVAX = (username, password, to, amount) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                to,
                amount: amount.toString(10),
                username,
                password,
            };
            return this.callMethod('avm.exportAVAX', params).then((response) => response.data.result.txID);
        });
        /**
           * Finalize a transfer of AVAX from the P-Chain to the X-Chain.
           *
           * Before this method is called, you must call the P-Chain’s `exportAVAX` method to initiate the transfer.
           *
           * @param to The address the AVAX is sent to. This must be the same as the to argument in the corresponding call to the P-Chain’s exportAVAX, except that the prepended X- should be included in this argument
           * @param username The Keystore user that controls the address specified in `to`
           * @param password The password of the Keystore user
           *
           * @returns String representing the transaction id
           */
        this.importAVAX = (username, password, to) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                to,
                username,
                password,
            };
            return this.callMethod('avm.importAVAX', params).then((response) => response.data.result.txID);
        });
        /**
           * Lists all the addresses under a user.
           *
           * @param username The user to list addresses
           * @param password The password of the user to list the addresses
           *
           * @returns Promise of an array of address strings in the format specified by the blockchain.
           */
        this.listAddresses = (username, password) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                username,
                password,
            };
            return this.callMethod('avm.listAddresses', params).then((response) => response.data.result.addresses);
        });
        /**
           * Retrieves all assets for an address on a server and their associated balances.
           *
           * @param address The address to get a list of assets
           *
           * @returns Promise of an object mapping assetID strings with {@link https://github.com/indutny/bn.js/|BN} balance for the address on the blockchain.
           */
        this.getAllBalances = (address) => __awaiter(this, void 0, void 0, function* () {
            if (typeof this.parseAddress(address) === 'undefined') {
                /* istanbul ignore next */
                throw new Error(`Error - AVMAPI.getAllBalances: Invalid address format ${address}`);
            }
            const params = {
                address,
            };
            return this.callMethod('avm.getAllBalances', params).then((response) => response.data.result.balances);
        });
        /**
           * Retrieves an assets name and symbol.
           *
           * @param assetID Either a {@link https://github.com/feross/buffer|Buffer} or an b58 serialized string for the AssetID or its alias.
           *
           * @returns Returns a Promise<object> with keys "name" and "symbol".
           */
        this.getAssetDescription = (assetID) => __awaiter(this, void 0, void 0, function* () {
            let asset;
            if (typeof assetID !== 'string') {
                asset = bintools.cb58Encode(assetID);
            }
            else {
                asset = assetID;
            }
            const params = {
                assetID: asset,
            };
            return this.callMethod('avm.getAssetDescription', params).then((response) => ({
                name: response.data.result.name,
                symbol: response.data.result.symbol,
                assetID: bintools.cb58Decode(response.data.result.assetID),
                denomination: parseInt(response.data.result.denomination, 10),
            }));
        });
        /**
           * Returns the treansaction data of a provided transaction ID by calling the node's `getTx` method.
           *
           * @param txid The string representation of the transaction ID
           *
           * @returns Returns a Promise<string> containing the bytes retrieved from the node
           */
        this.getTx = (txid) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                txID: txid,
            };
            return this.callMethod('avm.getTx', params).then((response) => response.data.result.tx);
        });
        /**
           * Returns the status of a provided transaction ID by calling the node's `getTxStatus` method.
           *
           * @param txid The string representation of the transaction ID
           *
           * @returns Returns a Promise<string> containing the status retrieved from the node
           */
        this.getTxStatus = (txid) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                txID: txid,
            };
            return this.callMethod('avm.getTxStatus', params).then((response) => response.data.result.status);
        });
        /**
           * Retrieves the UTXOs related to the addresses provided from the node's `getUTXOs` method.
           *
           * @param addresses An array of addresses as cb58 strings or addresses as {@link https://github.com/feross/buffer|Buffer}s
           * @param persistOpts Options available to persist these UTXOs in local storage
           *
           * @remarks
           * persistOpts is optional and must be of type [[PersistanceOptions]]
           *
           */
        this.getUTXOs = (addresses, persistOpts = undefined) => __awaiter(this, void 0, void 0, function* () {
            const addrs = this._cleanAddressArray(addresses, 'getUTXOs');
            const params = {
                addresses: addrs,
            };
            return this.callMethod('avm.getUTXOs', params).then((response) => {
                const utxos = new utxos_1.UTXOSet();
                let data = response.data.result.utxos;
                if (persistOpts && typeof persistOpts === 'object') {
                    if (this.db.has(persistOpts.getName())) {
                        const selfArray = this.db.get(persistOpts.getName());
                        if (Array.isArray(selfArray)) {
                            utxos.addArray(data);
                            const self = new utxos_1.UTXOSet();
                            self.addArray(selfArray);
                            self.mergeByRule(utxos, persistOpts.getMergeRule());
                            data = self.getAllUTXOStrings();
                        }
                    }
                    this.db.set(persistOpts.getName(), data, persistOpts.getOverwrite());
                }
                utxos.addArray(data);
                return utxos;
            });
        });
        /**
           * Retrieves the UTXOs able to be imported by the addresses, provided from the node's `getAtomicUTXOs` method.
           *
           * @param addresses An array of addresses as cb58 strings or addresses as {@link https://github.com/feross/buffer|Buffer}s
           * @param persistOpts Options available to persist these UTXOs in local storage
           *
           * @remarks
           * persistOpts is optional and must be of type [[PersistanceOptions]]
           *
           */
        this.getAtomicUTXOs = (addresses, persistOpts = undefined) => __awaiter(this, void 0, void 0, function* () {
            const addrs = this._cleanAddressArray(addresses, 'getAtomicUTXOs');
            const params = {
                addresses: addrs,
            };
            return this.callMethod('avm.getAtomicUTXOs', params).then((response) => {
                const utxos = new utxos_1.UTXOSet();
                let data = response.data.result.utxos;
                if (persistOpts && typeof persistOpts === 'object') {
                    if (this.db.has(persistOpts.getName())) {
                        const selfArray = this.db.get(persistOpts.getName());
                        if (Array.isArray(selfArray)) {
                            utxos.addArray(data);
                            const self = new utxos_1.UTXOSet();
                            self.addArray(selfArray);
                            self.mergeByRule(utxos, persistOpts.getMergeRule());
                            data = self.getAllUTXOStrings();
                        }
                    }
                    this.db.set(persistOpts.getName(), data, persistOpts.getOverwrite());
                }
                utxos.addArray(data);
                return utxos;
            });
        });
        /**
           * Helper function which creates an unsigned transaction. For more granular control, you may create your own
           * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
           *
           * @param utxoset A set of UTXOs that the transaction is built on
           * @param amount The amount of AVAX to be spent in $nAVAX
           * @param toAddresses The addresses to send the funds
           * @param fromAddresses The addresses being used to send the funds from the UTXOs provided
           * @param changeAddresses The addresses that can spend the change remaining from the spent UTXOs
           * @param assetID The assetID of the value being sent
           * @param memo Optional contains arbitrary bytes, up to 256 bytes
           * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           * @param locktime Optional. The locktime field created in the resulting outputs
           * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
           *
           * @returns An unsigned transaction ([[UnsignedTx]]) which contains a [[BaseTx]].
           *
           * @remarks
           * This helper exists because the endpoint API should be the primary point of entry for most functionality.
           */
        this.buildBaseTx = (utxoset, amount, toAddresses, fromAddresses, changeAddresses, assetID = undefined, memo = undefined, asOf = types_2.UnixNow(), locktime = new bn_js_1.default(0), threshold = 1) => __awaiter(this, void 0, void 0, function* () {
            const to = this._cleanAddressArray(toAddresses, 'buildBaseTx').map((a) => bintools.stringToAddress(a));
            const from = this._cleanAddressArray(fromAddresses, 'buildBaseTx').map((a) => bintools.stringToAddress(a));
            const change = this._cleanAddressArray(changeAddresses, 'buildBaseTx').map((a) => bintools.stringToAddress(a));
            if (typeof assetID === 'string') {
                assetID = bintools.cb58Decode(assetID);
            }
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            const builtUnsignedTx = utxoset.buildBaseTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), amount, to, from, change, assetID, memo, asOf, locktime, threshold);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
           * Helper function which creates an unsigned NFT Transfer. For more granular control, you may create your own
           * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
           *
           * @param utxoset  A set of UTXOs that the transaction is built on
           * @param utxoid A base58 utxoID or an array of base58 utxoIDs for the nfts this transaction is sending
           * @param toAddresses The addresses to send the NFT
           * @param fromAddresses The addresses being used to send the NFT from the utxoID provided
           * @param feeAmount The amount of fees being paid for this transaction
           * @param feeAddresses The addresses that have the AVAX funds to pay for fees of the UTXO
           * @param memo Optional contains arbitrary bytes, up to 256 bytes
           * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           * @param locktime Optional. The locktime field created in the resulting outputs
           * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
           *
           * @returns An unsigned transaction ([[UnsignedTx]]) which contains a [[NFTTransferTx]].
           *
           * @remarks
           * This helper exists because the endpoint API should be the primary point of entry for most functionality.
           */
        this.buildNFTTransferTx = (utxoset, utxoid, toAddresses, fromAddresses, feeAmount, feeAddresses, memo = undefined, asOf = types_2.UnixNow(), locktime = new bn_js_1.default(0), threshold = 1) => __awaiter(this, void 0, void 0, function* () {
            const to = this._cleanAddressArray(toAddresses, 'buildNFTTransferTx').map((a) => bintools.stringToAddress(a));
            const from = this._cleanAddressArray(fromAddresses, 'buildNFTTransferTx').map((a) => bintools.stringToAddress(a));
            const feeAddrs = this._cleanAddressArray(feeAddresses, 'buildNFTTransferTx').map((a) => bintools.stringToAddress(a));
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            const avaxAssetID = yield this.getAVAXAssetID();
            let utxoidArray = [];
            if (typeof utxoid === 'string') {
                utxoidArray = [utxoid];
            }
            else if (Array.isArray(utxoid)) {
                utxoidArray = utxoid;
            }
            const builtUnsignedTx = utxoset.buildNFTTransferTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), avaxAssetID, feeAmount, feeAddrs, to, from, utxoidArray, memo, asOf, locktime, threshold);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
         * In-Development, do not use: Helper function which creates an unsigned Import Tx. For more granular control, you may create your own
         * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
         *
         * @param utxoset  A set of UTXOs that the transaction is built on
         * @param ownerAddresses The addresses being used to import
         * @param feeAmount The amount of fees being paid for this transaction
         * @param feeAddresses The addresses that have the AVAX funds to pay for fees of the UTXO
         * @param memo Optional contains arbitrary bytes, up to 256 bytes
         * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
         * @param locktime Optional. The locktime field created in the resulting outputs
         * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
         *
         * @returns An unsigned transaction ([[UnsignedTx]]) which contains a [[ImportTx]].
         *
         * @remarks
         * This helper exists because the endpoint API should be the primary point of entry for most functionality.
         */
        this.buildImportTx = (utxoset, ownerAddresses, feeAmount, feeAddresses, memo = undefined, asOf = types_2.UnixNow()) => __awaiter(this, void 0, void 0, function* () {
            const owners = this._cleanAddressArray(ownerAddresses, 'buildImportTx').map((a) => bintools.stringToAddress(a));
            const feeAddrs = this._cleanAddressArray(feeAddresses, 'buildImportTx').map((a) => bintools.stringToAddress(a));
            const atomicUTXOs = yield this.getAtomicUTXOs(owners);
            const avaxAssetID = yield this.getAVAXAssetID();
            const avaxAssetIDStr = avaxAssetID.toString("hex");
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            const atomics = atomicUTXOs.getAllUTXOs();
            const importIns = [];
            for (let i = 0; i < atomics.length; i++) {
                const utxo = atomics[i];
                const assetID = utxo.getAssetID();
                if (assetID.toString("hex") === avaxAssetIDStr) {
                    const output = utxo.getOutput();
                    const amt = output.getAmount().clone();
                    const txid = utxo.getTxID();
                    const outputidx = utxo.getOutputIdx();
                    const input = new inputs_1.SecpInput(amt);
                    const xferin = new inputs_1.TransferableInput(txid, outputidx, assetID, input);
                    const fromAddresses = output.getAddresses(); // Verify correct approach
                    const spenders = output.getSpenders(fromAddresses, asOf);
                    for (let j = 0; j < spenders.length; j++) {
                        const idx = output.getAddressIdx(spenders[j]);
                        if (idx === -1) {
                            /* istanbul ignore next */
                            throw new Error('Error - UTXOSet.buildBaseTx: no such '
                                + `address in output: ${spenders[j]}`);
                        }
                        xferin.getInput().addSignatureIdx(idx, spenders[j]);
                    }
                    importIns.push(xferin);
                }
            }
            const builtUnsignedTx = utxoset.buildImportTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), avaxAssetID, feeAmount, feeAddrs, importIns, memo, asOf);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
           * In-Development, do not use: Helper function which creates an unsigned Export Tx. For more granular control, you may create your own
           * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
           *
           * @param utxoset A set of UTXOs that the transaction is built on
           * @param utxoid A base58 utxoID or an array of base58 utxoIDs for the AVAX this transaction is exporting
           * @param feeAmount The amount of fees being paid for this transaction
           * @param feeAddresses The addresses that have the AVAX funds to pay for fees of the UTXO
           * @param memo Optional contains arbitrary bytes, up to 256 bytes
           * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           *
           * @returns An unsigned transaction ([[UnsignedTx]]) which contains an [[ExportTx]].
           *
           * @remarks
           * This helper exists because the endpoint API should be the primary point of entry for most functionality.
           */
        this.buildExportTx = (utxoset, utxoid, feeAmount, feeAddresses, memo = undefined, asOf = types_2.UnixNow()) => __awaiter(this, void 0, void 0, function* () {
            const feeAddrs = this._cleanAddressArray(feeAddresses, 'buildExportTx').map((a) => bintools.stringToAddress(a));
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            const avaxAssetID = yield this.getAVAXAssetID();
            let utxoidArray = [];
            if (typeof utxoid === 'string') {
                utxoidArray = [utxoid];
            }
            else if (Array.isArray(utxoid)) {
                utxoidArray = utxoid;
            }
            const builtUnsignedTx = utxoset.buildExportTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), avaxAssetID, feeAmount, feeAddrs, utxoidArray, memo, asOf);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
           * Creates an unsigned transaction. For more granular control, you may create your own
           * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
           *
           * @param utxoset A set of UTXOs that the transaction is built on
           * @param fee The amount of AVAX to be paid for fees, in $nAVAX
           * @param creatorAddresses The addresses to send the fees
           * @param initialStates The [[InitialStates]] that represent the intial state of a created asset
           * @param name String for the descriptive name of the asset
           * @param symbol String for the ticker symbol of the asset
           * @param denomination Optional number for the denomination which is 10^D. D must be >= 0 and <= 32. Ex: $1 AVAX = 10^9 $nAVAX
           * @param memo Optional contains arbitrary bytes, up to 256 bytes
           * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           *
           * @returns An unsigned transaction ([[UnsignedTx]]) which contains a [[CreateAssetTx]].
           *
           */
        this.buildCreateAssetTx = (utxoset, fee, creatorAddresses, initialStates, name, symbol, denomination, memo = undefined, asOf = types_2.UnixNow(), locktime = undefined) => __awaiter(this, void 0, void 0, function* () {
            let creators = this._cleanAddressArray(creatorAddresses, "buildCreateAssetTx").map(a => bintools.stringToAddress(a));
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            /* istanbul ignore next */
            if (symbol.length > types_2.AVMConstants.SYMBOLMAXLEN) {
                /* istanbul ignore next */
                throw new Error("Error - AVMAPI.buildCreateAssetTx: Symbols may not exceed length of " + types_2.AVMConstants.SYMBOLMAXLEN);
            }
            /* istanbul ignore next */
            if (name.length > types_2.AVMConstants.ASSETNAMELEN) {
                /* istanbul ignore next */
                throw new Error("Error - AVMAPI.buildCreateAssetTx: Names may not exceed length of " + types_2.AVMConstants.ASSETNAMELEN);
            }
            const avaxAssetID = yield this.getAVAXAssetID();
            const builtUnsignedTx = utxoset.buildCreateAssetTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), avaxAssetID, fee, creators, initialStates, name, symbol, denomination, memo, asOf);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
         * Creates an unsigned transaction. For more granular control, you may create your own
          * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
          *
          * @param utxoset A set of UTXOs that the transaction is built on
          * @param fee The amount of AVAX to be paid for fees, in $nAVAX
          * @param feePayingAddresses The addresses to pay the fees
          * @param name String for the descriptive name of the asset
          * @param symbol String for the ticker symbol of the asset
          * @param minterSets is a list where each element specifies that threshold of the addresses in minters may together mint more of the asset by signing a minting transaction
          * @param memo Optional contains arbitrary bytes, up to 256 bytes
          * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
          * @param locktime Optional. The locktime field created in the resulting mint output
          *
          * ```js
          * Example minterSets:
          * [
          *      {
          *          "minters":[
          *              "X-4peJsFvhdn7XjhNF4HWAQy6YaJts27s9q"
          *          ],
          *          "threshold": 1
          *      },
          *      {
          *          "minters": [
          *              "X-dcJ6z9duLfyQTgbjq2wBCowkvcPZHVDF",
          *              "X-2fE6iibqfERz5wenXE6qyvinsxDvFhHZk",
          *              "X-7ieAJbfrGQbpNZRAQEpZCC1Gs1z5gz4HU"
          *          ],
          *          "threshold": 2
          *      }
          * ]
          * ```
          *
          * @returns An unsigned transaction ([[UnsignedTx]]) which contains a [[CreateAssetTx]].
          *
          */
        this.buildCreateNFTAssetTx = (utxoset, fee, feePayingAddresses, name, symbol, minterSets, memo = undefined, asOf = types_2.UnixNow(), locktime = new bn_js_1.default(0)) => __awaiter(this, void 0, void 0, function* () {
            let feeAddrs = this._cleanAddressArray(feePayingAddresses, "buildCreateNFTAssetTx").map(a => bintools.stringToAddress(a));
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            if (name.length > types_2.AVMConstants.ASSETNAMELEN) {
                /* istanbul ignore next */
                throw new Error("Error - AVMAPI.buildCreateNFTAssetTx: Names may not exceed length of " + types_2.AVMConstants.ASSETNAMELEN);
            }
            if (symbol.length > types_2.AVMConstants.SYMBOLMAXLEN) {
                /* istanbul ignore next */
                throw new Error("Error - AVMAPI.buildCreateNFTAssetTx: Symbols may not exceed length of " + types_2.AVMConstants.SYMBOLMAXLEN);
            }
            let avaxAssetID = yield this.getAVAXAssetID();
            const builtUnsignedTx = utxoset.buildCreateNFTAssetTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), avaxAssetID, fee, feeAddrs, minterSets, name, symbol, memo, asOf, locktime);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
         * Creates an unsigned transaction. For more granular control, you may create your own
          * [[UnsignedTx]] manually (with their corresponding [[TransferableInput]]s, [[TransferableOutput]]s, and [[TransferOperation]]s).
          *
          * @param utxoset  A set of UTXOs that the transaction is built on
          * @param utxoid A base58 utxoID or an array of base58 utxoIDs for the nft mint output this transaction is sending
          * @param toAddresses The addresses to send the nft output
          * @param fromAddresses The addresses being used to send the NFT from the utxoID provided
          * @param fee The amount of fees being paid for this transaction
          * @param feeAddresses The addresses that have the AVAX funds to pay for fees of the UTXO
          * @param groupID Optional. The group this NFT is issued to.
          * @param payload Optional. Data for NFT Payload as either a [[PayloadBase]] or a {@link https://github.com/feross/buffer|Buffer}
          * @param memo Optional contains arbitrary bytes, up to 256 bytes
          * @param asOf Optional. The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
          * @param locktime Optional. The locktime field created in the resulting mint output
          * @param threshold Optional. The number of signatures required to spend the funds in the resultant UTXO
          *
          *
          * @returns An unsigned transaction ([[UnsignedTx]]) which contains an [[OperationTx]].
          *
          */
        this.buildCreateNFTMintTx = (utxoset, utxoid, toAddresses, fromAddresses, fee, feeAddresses, groupID = 0, payload = undefined, memo = undefined, asOf = types_2.UnixNow(), locktime = new bn_js_1.default(0), threshold = 1) => __awaiter(this, void 0, void 0, function* () {
            let to = this._cleanAddressArray(toAddresses, "buildCreateNFTMintTx").map(a => bintools.stringToAddress(a));
            let from = this._cleanAddressArray(fromAddresses, "buildCreateNFTMintTx").map(a => bintools.stringToAddress(a));
            let feeAddrs = this._cleanAddressArray(feeAddresses, "buildCreateNFTMintTx").map(a => bintools.stringToAddress(a));
            if (memo instanceof payload_1.PayloadBase) {
                memo = memo.getPayload();
            }
            if (payload instanceof payload_1.PayloadBase) {
                payload = payload.getPayload();
            }
            if (typeof utxoid === 'string') {
                utxoid = [utxoid];
            }
            let avaxAssetID = yield this.getAVAXAssetID();
            const builtUnsignedTx = utxoset.buildCreateNFTMintTx(this.core.getNetworkID(), bintools.cb58Decode(this.blockchainID), avaxAssetID, fee, feeAddrs, to, from, utxoid, groupID, payload, memo, asOf, locktime, threshold);
            if (!(yield this.checkGooseEgg(builtUnsignedTx))) {
                /* istanbul ignore next */
                throw new Error("Failed Goose Egg Check");
            }
            return builtUnsignedTx;
        });
        /**
         * Helper function which takes an unsigned transaction and signs it, returning the resulting [[Tx]].
          *
          * @param utx The unsigned transaction of type [[UnsignedTx]]
          *
          * @returns A signed transaction of type [[Tx]]
          */
        this.signTx = (utx) => this.keychain.signTx(utx);
        /**
           * Calls the node's issueTx method from the API and returns the resulting transaction ID as a string.
           *
           * @param tx A string, {@link https://github.com/feross/buffer|Buffer}, or [[Tx]] representing a transaction
           *
           * @returns A Promise<string> representing the transaction ID of the posted transaction.
           */
        this.issueTx = (tx) => __awaiter(this, void 0, void 0, function* () {
            let Transaction = '';
            if (typeof tx === 'string') {
                Transaction = tx;
            }
            else if (tx instanceof buffer_1.Buffer) {
                const txobj = new tx_1.Tx();
                txobj.fromBuffer(tx);
                Transaction = txobj.toString();
            }
            else if (tx instanceof tx_1.Tx) {
                Transaction = tx.toString();
            }
            else {
                /* istanbul ignore next */
                throw new Error('Error - avm.issueTx: provided tx is not expected type of string, Buffer, or Tx');
            }
            const params = {
                tx: Transaction.toString(),
            };
            return this.callMethod('avm.issueTx', params).then((response) => response.data.result.txID);
        });
        /**
           * Sends an amount of assetID to the specified address from a list of owned of addresses.
           *
           * @param username The user that owns the private keys associated with the `from` addresses
           * @param password The password unlocking the user
           * @param assetID The assetID of the asset to send
           * @param amount The amount of the asset to be sent
           * @param to The address of the recipient
           * @param from An array of addresses managed by the node's keystore for this blockchain which will fund this transaction
           *
           * @returns Promise for the string representing the transaction's ID.
           */
        this.send = (username, password, assetID, amount, to, from) => __awaiter(this, void 0, void 0, function* () {
            let asset;
            let amnt;
            if (typeof this.parseAddress(to) === 'undefined') {
                /* istanbul ignore next */
                throw new Error(`Error - AVMAPI.sen: Invalid address format ${to}`);
            }
            from = this._cleanAddressArray(from, 'send');
            if (typeof assetID !== 'string') {
                asset = bintools.cb58Encode(assetID);
            }
            else {
                asset = assetID;
            }
            if (typeof amount === 'number') {
                amnt = new bn_js_1.default(amount);
            }
            else {
                amnt = amount;
            }
            const params = {
                username,
                password,
                assetID: asset,
                amount: amnt.toString(10),
                to,
                from,
            };
            return this.callMethod('avm.send', params).then((response) => response.data.result.txID);
        });
        /**
           * Given a JSON representation of this Virtual Machine’s genesis state, create the byte representation of that state.
           *
           * @param genesisData The blockchain's genesis data object
           *
           * @returns Promise of a string of bytes
           */
        this.buildGenesis = (genesisData) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                genesisData,
            };
            return this.callMethod('avm.buildGenesis', params).then((response) => {
                const r = response.data.result.bytes;
                return r;
            });
        });
        this.blockchainID = blockchainID;
        const netid = core.getNetworkID();
        if (netid in types_1.Defaults.network && blockchainID in types_1.Defaults.network[netid]) {
            const { alias } = types_1.Defaults.network[netid][blockchainID];
            this.keychain = new keychain_1.AVMKeyChain(this.core.getHRP(), alias);
        }
        else {
            this.keychain = new keychain_1.AVMKeyChain(this.core.getHRP(), blockchainID);
        }
    }
    /**
       * @ignore
       */
    _cleanAddressArray(addresses, caller) {
        const addrs = [];
        const chainid = this.getBlockchainAlias() ? this.getBlockchainAlias() : this.getBlockchainID();
        if (addresses && addresses.length > 0) {
            for (let i = 0; i < addresses.length; i++) {
                if (typeof addresses[i] === 'string') {
                    if (typeof this.parseAddress(addresses[i]) === 'undefined') {
                        /* istanbul ignore next */
                        throw new Error(`Error - AVMAPI.${caller}: Invalid address format ${addresses[i]}`);
                    }
                    addrs.push(addresses[i]);
                }
                else {
                    addrs.push(bintools.addressToString(this.core.getHRP(), chainid, addresses[i]));
                }
            }
        }
        return addrs;
    }
}
exports.default = AVMAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvYXZtL2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0dBR0c7QUFDSCxrREFBdUI7QUFDdkIsb0NBQWlDO0FBRWpDLG9FQUE0QztBQUM1Qyw2Q0FBc0Y7QUFDdEYsbUNBQXdDO0FBQ3hDLG1DQUEwRTtBQUMxRSx5Q0FBeUM7QUFDekMsNkJBQXNDO0FBQ3RDLGlEQUFrRDtBQUNsRCxxQ0FBd0Q7QUFHeEQ7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRXhDOzs7R0FHRztBQUNILE1BQWEsa0JBQWtCO0lBc0I3Qjs7Ozs7Ozs7Ozs7Ozs7O1NBZUs7SUFDTCxZQUFZLElBQVcsRUFBRSxZQUFvQixLQUFLLEVBQUUsU0FBbUI7UUFyQzdELFNBQUksR0FBVSxTQUFTLENBQUM7UUFFeEIsY0FBUyxHQUFXLEtBQUssQ0FBQztRQUUxQixjQUFTLEdBQWEsT0FBTyxDQUFDO1FBRXhDOzthQUVLO1FBQ0wsWUFBTyxHQUFHLEdBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFakM7O2FBRUs7UUFDTCxpQkFBWSxHQUFHLEdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7UUFFNUM7O2FBRUs7UUFDTCxpQkFBWSxHQUFHLEdBQWEsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7UUFtQjVDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQzdCLENBQUM7Q0FDRjtBQTNDRCxnREEyQ0M7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLE1BQU8sU0FBUSxlQUFPO0lBd2pDMUI7Ozs7O1NBS0s7SUFDTCxZQUFZLElB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TyxLQUFLLENBQUM7SUFDZixDQUFDO0NBbUJGO0FBRUQsa0JBQWUsTUFBTSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVZNQVBJXG4gKi9cbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXIvJztcbmltcG9ydCBBdmFsYW5jaGVDb3JlIGZyb20gJy4uLy4uL2F2YWxhbmNoZSc7XG5pbXBvcnQgQmluVG9vbHMgZnJvbSAnLi4vLi4vdXRpbHMvYmludG9vbHMnO1xuaW1wb3J0IHsgSlJQQ0FQSSwgUmVxdWVzdFJlc3BvbnNlRGF0YSwgRGVmYXVsdHMsIE1pbnRlclNldCB9IGZyb20gXCIuLi8uLi91dGlscy90eXBlc1wiO1xuaW1wb3J0IHsgVVRYT1NldCwgVVRYTyB9IGZyb20gJy4vdXR4b3MnO1xuaW1wb3J0IHsgTWVyZ2VSdWxlLCBVbml4Tm93LCBBVk1Db25zdGFudHMsIEluaXRpYWxTdGF0ZXMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEFWTUtleUNoYWluIH0gZnJvbSAnLi9rZXljaGFpbic7XG5pbXBvcnQgeyBUeCwgVW5zaWduZWRUeCB9IGZyb20gJy4vdHgnO1xuaW1wb3J0IHsgUGF5bG9hZEJhc2UgfSBmcm9tICcuLi8uLi91dGlscy9wYXlsb2FkJztcbmltcG9ydCB7IFRyYW5zZmVyYWJsZUlucHV0LCBTZWNwSW5wdXQgfSBmcm9tICcuL2lucHV0cyc7XG5pbXBvcnQgeyBBbW91bnRPdXRwdXQgfSBmcm9tICcuL291dHB1dHMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuXG4vKipcbiAqIEEgY2xhc3MgZm9yIGRlZmluaW5nIHRoZSBwZXJzaXN0YW5jZSBiZWhhdmlvciBvZiB0aGlzIGFuIEFQSSBjYWxsLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBlcnNpc3RhbmNlT3B0aW9ucyB7XG4gIHByb3RlY3RlZCBuYW1lOnN0cmluZyA9IHVuZGVmaW5lZDtcblxuICBwcm90ZWN0ZWQgb3ZlcndyaXRlOmJvb2xlYW4gPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgbWVyZ2VSdWxlOk1lcmdlUnVsZSA9ICd1bmlvbic7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZXNwYWNlIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICBnZXROYW1lID0gKCk6c3RyaW5nID0+IHRoaXMubmFtZTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdmVyd3JpdGUgcnVsZSBvZiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgZ2V0T3ZlcndyaXRlID0gKCk6Ym9vbGVhbiA9PiB0aGlzLm92ZXJ3cml0ZTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBbW01lcmdlUnVsZV1dIG9mIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICBnZXRNZXJnZVJ1bGUgPSAoKTpNZXJnZVJ1bGUgPT4gdGhpcy5tZXJnZVJ1bGU7XG5cbiAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZXNwYWNlIG9mIHRoZSBkYXRhYmFzZSB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgVHJ1ZSBpZiB0aGUgZGF0YSBzaG91bGQgYmUgY29tcGxldGV5IG92ZXJ3cml0dGVuXG4gICAgICogQHBhcmFtIE1lcmdlUnVsZSBUaGUgdHlwZSBvZiBwcm9jZXNzIHVzZWQgdG8gbWVyZ2Ugd2l0aCBleGlzdGluZyBkYXRhOiBcImludGVyc2VjdGlvblwiLCBcImRpZmZlcmVuY2VTZWxmXCIsIFwiZGlmZmVyZW5jZU5ld1wiLCBcInN5bURpZmZlcmVuY2VcIiwgXCJ1bmlvblwiLCBcInVuaW9uTWludXNOZXdcIiwgXCJ1bmlvbk1pbnVzU2VsZlwiXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBtZXJnZSBydWxlcyBhcmUgYXMgZm9sbG93czpcbiAgICAgKiAgICogXCJpbnRlcnNlY3Rpb25cIiAtIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHNldFxuICAgICAqICAgKiBcImRpZmZlcmVuY2VTZWxmXCIgLSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBleGlzdGluZyBkYXRhIGFuZCBuZXcgc2V0XG4gICAgICogICAqIFwiZGlmZmVyZW5jZU5ld1wiIC0gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGRhdGEgYW5kIHRoZSBleGlzdGluZyBzZXRcbiAgICAgKiAgICogXCJzeW1EaWZmZXJlbmNlXCIgLSB0aGUgdW5pb24gb2YgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYm90aCBzZXRzIG9mIGRhdGFcbiAgICAgKiAgICogXCJ1bmlvblwiIC0gdGhlIHVuaXF1ZSBzZXQgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiBib3RoIHNldHNcbiAgICAgKiAgICogXCJ1bmlvbk1pbnVzTmV3XCIgLSB0aGUgdW5pcXVlIHNldCBvZiBhbGwgZWxlbWVudHMgY29udGFpbmVkIGluIGJvdGggc2V0cywgZXhjbHVkaW5nIHZhbHVlcyBvbmx5IGZvdW5kIGluIHRoZSBuZXcgc2V0XG4gICAgICogICAqIFwidW5pb25NaW51c1NlbGZcIiAtIHRoZSB1bmlxdWUgc2V0IG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gYm90aCBzZXRzLCBleGNsdWRpbmcgdmFsdWVzIG9ubHkgZm91bmQgaW4gdGhlIGV4aXN0aW5nIHNldFxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lOnN0cmluZywgb3ZlcndyaXRlOmJvb2xlYW4gPSBmYWxzZSwgbWVyZ2VSdWxlOk1lcmdlUnVsZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG4gICAgdGhpcy5tZXJnZVJ1bGUgPSBtZXJnZVJ1bGU7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIG5vZGUgZW5kcG9pbnQgdGhhdCBpcyB1c2luZyB0aGUgQVZNLlxuICpcbiAqIEBjYXRlZ29yeSBSUENBUElzXG4gKlxuICogQHJlbWFya3MgVGhpcyBleHRlbmRzIHRoZSBbW0pSUENBUEldXSBjbGFzcy4gVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGRpcmVjdGx5IGNhbGxlZC4gSW5zdGVhZCwgdXNlIHRoZSBbW0F2YWxhbmNoZS5hZGRBUEldXSBmdW5jdGlvbiB0byByZWdpc3RlciB0aGlzIGludGVyZmFjZSB3aXRoIEF2YWxhbmNoZS5cbiAqL1xuY2xhc3MgQVZNQVBJIGV4dGVuZHMgSlJQQ0FQSSB7XG4gIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgcHJvdGVjdGVkIGtleWNoYWluOkFWTUtleUNoYWluID0gbmV3IEFWTUtleUNoYWluKCcnLCAnJyk7XG5cbiAgcHJvdGVjdGVkIGJsb2NrY2hhaW5JRDpzdHJpbmcgPSAnJztcblxuICBwcm90ZWN0ZWQgQVZBWEFzc2V0SUQ6QnVmZmVyID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgICAqIEdldHMgdGhlIGFsaWFzIGZvciB0aGUgYmxvY2tjaGFpbklEIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWxpYXMgZm9yIHRoZSBibG9ja2NoYWluSURcbiAgICAgKi9cbiAgZ2V0QmxvY2tjaGFpbkFsaWFzID0gKCk6c3RyaW5nID0+IHtcbiAgICBjb25zdCBuZXRpZDpudW1iZXIgPSB0aGlzLmNvcmUuZ2V0TmV0d29ya0lEKCk7XG4gICAgaWYgKG5ldGlkIGluIERlZmF1bHRzLm5ldHdvcmsgJiYgdGhpcy5ibG9ja2NoYWluSUQgaW4gRGVmYXVsdHMubmV0d29ya1tuZXRpZF0pIHtcbiAgICAgIHJldHVybiBEZWZhdWx0cy5uZXR3b3JrW25ldGlkXVt0aGlzLmJsb2NrY2hhaW5JRF0uYWxpYXM7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBHZXRzIHRoZSBibG9ja2NoYWluSUQgYW5kIHJldHVybnMgaXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYmxvY2tjaGFpbklEXG4gICAgICovXG4gIGdldEJsb2NrY2hhaW5JRCA9ICgpOnN0cmluZyA9PiB0aGlzLmJsb2NrY2hhaW5JRDtcblxuICAvKipcbiAgICAgKiBSZWZyZXNoIGJsb2NrY2hhaW5JRCwgYW5kIGlmIGEgYmxvY2tjaGFpbklEIGlzIHBhc3NlZCBpbiwgdXNlIHRoYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT3B0aW9uYWwuIEJsb2NrY2hhaW5JRCB0byBhc3NpZ24sIGlmIG5vbmUsIHVzZXMgdGhlIGRlZmF1bHQgYmFzZWQgb24gbmV0d29ya0lELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrY2hhaW5JRFxuICAgICAqL1xuICByZWZyZXNoQmxvY2tjaGFpbklEID0gKGJsb2NrY2hhaW5JRDpzdHJpbmcgPSB1bmRlZmluZWQpOmJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IG5ldGlkOm51bWJlciA9IHRoaXMuY29yZS5nZXROZXR3b3JrSUQoKTtcbiAgICBpZiAodHlwZW9mIGJsb2NrY2hhaW5JRCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlZmF1bHRzLm5ldHdvcmtbbmV0aWRdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmJsb2NrY2hhaW5JRCA9IERlZmF1bHRzLm5ldHdvcmtbbmV0aWRdLmF2bS5ibG9ja2NoYWluSUQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGlmICh0eXBlb2YgYmxvY2tjaGFpbklEID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5ibG9ja2NoYWluSUQgPSBibG9ja2NoYWluSUQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFRha2VzIGFuIGFkZHJlc3Mgc3RyaW5nIGFuZCByZXR1cm5zIGl0cyB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBpZiB2YWxpZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBhZGRyZXNzIGlmIHZhbGlkLCB1bmRlZmluZWQgaWYgbm90IHZhbGlkLlxuICAgICAqL1xuICBwYXJzZUFkZHJlc3MgPSAoYWRkcjpzdHJpbmcpOkJ1ZmZlciA9PiB7XG4gICAgY29uc3QgYWxpYXM6c3RyaW5nID0gdGhpcy5nZXRCbG9ja2NoYWluQWxpYXMoKTtcbiAgICBjb25zdCBibG9ja2NoYWluSUQ6c3RyaW5nID0gdGhpcy5nZXRCbG9ja2NoYWluSUQoKTtcbiAgICByZXR1cm4gYmludG9vbHMucGFyc2VBZGRyZXNzKGFkZHIsIGJsb2NrY2hhaW5JRCwgYWxpYXMsIEFWTUNvbnN0YW50cy5BRERSRVNTTEVOR1RIKTtcbiAgfTtcblxuICBhZGRyZXNzRnJvbUJ1ZmZlciA9IChhZGRyZXNzOkJ1ZmZlcik6c3RyaW5nID0+IHtcbiAgICBjb25zdCBjaGFpbmlkOnN0cmluZyA9IHRoaXMuZ2V0QmxvY2tjaGFpbkFsaWFzKCkgPyB0aGlzLmdldEJsb2NrY2hhaW5BbGlhcygpIDogdGhpcy5nZXRCbG9ja2NoYWluSUQoKTtcbiAgICByZXR1cm4gYmludG9vbHMuYWRkcmVzc1RvU3RyaW5nKHRoaXMuY29yZS5nZXRIUlAoKSwgY2hhaW5pZCwgYWRkcmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgQVZBWCBBc3NldElEIGFuZCByZXR1cm5zIGl0IGluIGEgUHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0aGUgcHJvdmlkZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYmxvY2tjaGFpbklEXG4gICAgICovXG4gIGdldEFWQVhBc3NldElEID0gYXN5bmMgKCk6UHJvbWlzZTxCdWZmZXI+ID0+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMuQVZBWEFzc2V0SUQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBhc3NldDp7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgICAgIGFzc2V0SUQ6IEJ1ZmZlcjtcbiAgICAgICAgZGVub21pbmF0aW9uOiBudW1iZXI7XG4gICAgICB9ID0gYXdhaXQgdGhpcy5nZXRBc3NldERlc2NyaXB0aW9uKCdBVkFYJyk7XG4gICAgICAvLyBUT0RPIC0gUmVtb3ZlIGhhcmRjb2RlZCAnQVZBWCdcbiAgICAgIHRoaXMuQVZBWEFzc2V0SUQgPSBhc3NldC5hc3NldElEO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5BVkFYQXNzZXRJRDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBrZXljaGFpbiBmb3IgdGhpcyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnN0YW5jZSBvZiBbW0FWTUtleUNoYWluXV0gZm9yIHRoaXMgY2xhc3NcbiAgICAgKi9cbiAga2V5Q2hhaW4gPSAoKTpBVk1LZXlDaGFpbiA9PiB0aGlzLmtleWNoYWluO1xuXG4gIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgbmV3S2V5Q2hhaW4gPSAoKTpBVk1LZXlDaGFpbiA9PiB7XG4gICAgLy8gd2FybmluZywgb3ZlcndyaXRlcyB0aGUgb2xkIGtleWNoYWluXG4gICAgY29uc3QgYWxpYXMgPSB0aGlzLmdldEJsb2NrY2hhaW5BbGlhcygpO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgdGhpcy5rZXljaGFpbiA9IG5ldyBBVk1LZXlDaGFpbih0aGlzLmNvcmUuZ2V0SFJQKCksIGFsaWFzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXljaGFpbiA9IG5ldyBBVk1LZXlDaGFpbih0aGlzLmNvcmUuZ2V0SFJQKCksIHRoaXMuYmxvY2tjaGFpbklEKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5Y2hhaW47XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGEgdHggaXMgYSBnb29zZSBlZ2cgdHJhbnNhY3Rpb24uIFxuICAgKlxuICAgKiBAcGFyYW0gdXR4IEFuIFVuc2lnbmVkVHhcbiAgICpcbiAgICogQHJldHVybnMgYm9vbGVhbiB0cnVlIGlmIHBhc3NlcyBnb29zZSBlZ2cgdGVzdCBhbmQgZmFsc2UgaWYgZmFpbHMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEEgXCJHb29zZSBFZ2cgVHJhbnNhY3Rpb25cIiBpcyB3aGVuIHRoZSBmZWUgZmFyIGV4Y2VlZHMgYSByZWFzb25hYmxlIGFtb3VudFxuICAgKi9cbiAgY2hlY2tHb29zZUVnZyA9IGFzeW5jICh1dHg6VW5zaWduZWRUeCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IGF2YXhBc3NldElEOkJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2V0QVZBWEFzc2V0SUQoKTtcbiAgICBjb25zdCBvdXRwdXRUb3RhbDpCTiA9IHV0eC5nZXRPdXRwdXRUb3RhbChhdmF4QXNzZXRJRCk7XG4gICAgY29uc3QgZmVlOkJOID0gdXR4LmdldEJ1cm4oYXZheEFzc2V0SUQpO1xuXG4gICAgaWYoZmVlLmx0ZShBVk1Db25zdGFudHMuT05FQVZBWC5tdWwobmV3IEJOKDEwKSkpIHx8IGZlZS5sdGUob3V0cHV0VG90YWwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICAqIEdldHMgdGhlIGJhbGFuY2Ugb2YgYSBwYXJ0aWN1bGFyIGFzc2V0IG9uIGEgYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIHB1bGwgdGhlIGFzc2V0IGJhbGFuY2UgZnJvbVxuICAgICAqIEBwYXJhbSBhc3NldElEIFRoZSBhc3NldElEIHRvIHB1bGwgdGhlIGJhbGFuY2UgZnJvbVxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHRoZSBiYWxhbmNlIG9mIHRoZSBhc3NldElEIGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gb24gdGhlIHByb3ZpZGVkIGFkZHJlc3MgZm9yIHRoZSBibG9ja2NoYWluLlxuICAgICAqL1xuICBnZXRCYWxhbmNlID0gYXN5bmMgKGFkZHJlc3M6c3RyaW5nLCBhc3NldElEOnN0cmluZyk6UHJvbWlzZTxCTj4gPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wYXJzZUFkZHJlc3MoYWRkcmVzcykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAtIEFWTUFQSS5nZXRCYWxhbmNlOiBJbnZhbGlkIGFkZHJlc3MgZm9ybWF0ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBhc3NldElELFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmdldEJhbGFuY2UnLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IG5ldyBCTihyZXNwb25zZS5kYXRhLnJlc3VsdC5iYWxhbmNlLCAxMCkpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWRkcmVzcyAoYW5kIGFzc29jaWF0ZWQgcHJpdmF0ZSBrZXlzKSBvbiBhIHVzZXIgb24gYSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJuYW1lIE5hbWUgb2YgdGhlIHVzZXIgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIHVuZGVyXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHVubG9jayB0aGUgdXNlciBhbmQgZW5jcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgZm9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWRkcmVzcyBjcmVhdGVkIGJ5IHRoZSB2bS5cbiAgICAgKi9cbiAgY3JlYXRlQWRkcmVzcyA9IGFzeW5jICh1c2VybmFtZTpzdHJpbmcsIHBhc3N3b3JkOnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ2F2bS5jcmVhdGVBZGRyZXNzJywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5hZGRyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZml4ZWQtY2FwLCBmdW5naWJsZSBhc3NldC4gQSBxdWFudGl0eSBvZiBpdCBpcyBjcmVhdGVkIGF0IGluaXRpYWxpemF0aW9uIGFuZCB0aGVyZSBubyBtb3JlIGlzIGV2ZXIgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VybmFtZSBUaGUgdXNlciBwYXlpbmcgdGhlIHRyYW5zYWN0aW9uIGZlZSAoaW4gJEFWQVgpIGZvciBhc3NldCBjcmVhdGlvblxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgZm9yIHRoZSB1c2VyIHBheWluZyB0aGUgdHJhbnNhY3Rpb24gZmVlIChpbiAkQVZBWCkgZm9yIGFzc2V0IGNyZWF0aW9uXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBhc3NldFxuICAgICAqIEBwYXJhbSBzeW1ib2wgT3B0aW9uYWwuIFRoZSBzaG9ydGhhbmQgc3ltYm9sIGZvciB0aGUgYXNzZXQuIEJldHdlZW4gMCBhbmQgNCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIGRlbm9taW5hdGlvbiBPcHRpb25hbC4gRGV0ZXJtaW5lcyBob3cgYmFsYW5jZXMgb2YgdGhpcyBhc3NldCBhcmUgZGlzcGxheWVkIGJ5IHVzZXIgaW50ZXJmYWNlcy4gRGVmYXVsdCBpcyAwXG4gICAgICogQHBhcmFtIGluaXRpYWxIb2xkZXJzIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZmllbGQgXCJhZGRyZXNzXCIgYW5kIFwiYW1vdW50XCIgdG8gZXN0YWJsaXNoIHRoZSBnZW5lc2lzIHZhbHVlcyBmb3IgdGhlIG5ldyBhc3NldFxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBFeGFtcGxlIGluaXRpYWxIb2xkZXJzOlxuICAgICAqIFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgICAgXCJhZGRyZXNzXCI6IFwiWC03c2lrM1ByNnIxRmVMcnZLMW9Xd0VDQlM4aUo1VlB1U2hcIixcbiAgICAgKiAgICAgICAgIFwiYW1vdW50XCI6IDEwMDAwXG4gICAgICogICAgIH0sXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICAgIFwiYWRkcmVzc1wiOiBcIlgtN3NpazNQcjZyMUZlTHJ2SzFvV3dFQ0JTOGlKNVZQdVNoXCIsXG4gICAgICogICAgICAgICBcImFtb3VudFwiOiA1MDAwMFxuICAgICAqICAgICB9XG4gICAgICogXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIFByb21pc2U8c3RyaW5nPiBjb250YWluaW5nIHRoZSBiYXNlIDU4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgSUQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYXNzZXQuXG4gICAgICovXG4gIGNyZWF0ZUZpeGVkQ2FwQXNzZXQgPSBhc3luYyAodXNlcm5hbWU6c3RyaW5nLCBwYXNzd29yZDpzdHJpbmcsIG5hbWU6c3RyaW5nLCBzeW1ib2w6c3RyaW5nLCBkZW5vbWluYXRpb246bnVtYmVyLCBpbml0aWFsSG9sZGVyczpBcnJheTxvYmplY3Q+KTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBuYW1lLFxuICAgICAgc3ltYm9sLFxuICAgICAgZGVub21pbmF0aW9uLFxuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGluaXRpYWxIb2xkZXJzLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmNyZWF0ZUZpeGVkQ2FwQXNzZXQnLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LmFzc2V0SUQpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB2YXJpYWJsZS1jYXAsIGZ1bmdpYmxlIGFzc2V0LiBObyB1bml0cyBvZiB0aGUgYXNzZXQgZXhpc3QgYXQgaW5pdGlhbGl6YXRpb24uIE1pbnRlcnMgY2FuIG1pbnQgdW5pdHMgb2YgdGhpcyBhc3NldCB1c2luZyBjcmVhdGVNaW50VHgsIHNpZ25NaW50VHggYW5kIHNlbmRNaW50VHguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgVGhlIHVzZXIgcGF5aW5nIHRoZSB0cmFuc2FjdGlvbiBmZWUgKGluICRBVkFYKSBmb3IgYXNzZXQgY3JlYXRpb25cbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIGZvciB0aGUgdXNlciBwYXlpbmcgdGhlIHRyYW5zYWN0aW9uIGZlZSAoaW4gJEFWQVgpIGZvciBhc3NldCBjcmVhdGlvblxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBodW1hbi1yZWFkYWJsZSBuYW1lIGZvciB0aGUgYXNzZXRcbiAgICAgKiBAcGFyYW0gc3ltYm9sIE9wdGlvbmFsLiBUaGUgc2hvcnRoYW5kIHN5bWJvbCBmb3IgdGhlIGFzc2V0IC0tIGJldHdlZW4gMCBhbmQgNCBjaGFyYWN0ZXJzXG4gICAgICogQHBhcmFtIGRlbm9taW5hdGlvbiBPcHRpb25hbC4gRGV0ZXJtaW5lcyBob3cgYmFsYW5jZXMgb2YgdGhpcyBhc3NldCBhcmUgZGlzcGxheWVkIGJ5IHVzZXIgaW50ZXJmYWNlcy4gRGVmYXVsdCBpcyAwXG4gICAgICogQHBhcmFtIG1pbnRlclNldHMgaXMgYSBsaXN0IHdoZXJlIGVhY2ggZWxlbWVudCBzcGVjaWZpZXMgdGhhdCB0aHJlc2hvbGQgb2YgdGhlIGFkZHJlc3NlcyBpbiBtaW50ZXJzIG1heSB0b2dldGhlciBtaW50IG1vcmUgb2YgdGhlIGFzc2V0IGJ5IHNpZ25pbmcgYSBtaW50aW5nIHRyYW5zYWN0aW9uXG4gICAgICogXG4gICAgICogYGBganNcbiAgICAgKiBFeGFtcGxlIG1pbnRlclNldHM6XG4gICAgICogW1xuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAgIFwibWludGVyc1wiOltcbiAgICAgKiAgICAgICAgICAgICAgXCJYLTRwZUpzRnZoZG43WGpoTkY0SFdBUXk2WWFKdHMyN3M5cVwiXG4gICAgICogICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgICBcInRocmVzaG9sZFwiOiAxXG4gICAgICogICAgICB9LFxuICAgICAqICAgICAge1xuICAgICAqICAgICAgICAgIFwibWludGVyc1wiOiBbXG4gICAgICogICAgICAgICAgICAgIFwiWC1kY0o2ejlkdUxmeVFUZ2JqcTJ3QkNvd2t2Y1BaSFZERlwiLFxuICAgICAqICAgICAgICAgICAgICBcIlgtMmZFNmlpYnFmRVJ6NXdlblhFNnF5dmluc3hEdkZoSFprXCIsXG4gICAgICogICAgICAgICAgICAgIFwiWC03aWVBSmJmckdRYnBOWlJBUUVwWkNDMUdzMXo1Z3o0SFVcIlxuICAgICAqICAgICAgICAgIF0sXG4gICAgICogICAgICAgICAgXCJ0aHJlc2hvbGRcIjogMlxuICAgICAqICAgICAgfVxuICAgICAqIF1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBQcm9taXNlPHN0cmluZz4gY29udGFpbmluZyB0aGUgYmFzZSA1OCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIElEIG9mIHRoZSBuZXdseSBjcmVhdGVkIGFzc2V0LlxuICAgICAqL1xuICBjcmVhdGVWYXJpYWJsZUNhcEFzc2V0ID0gYXN5bmMgKHVzZXJuYW1lOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCBuYW1lOnN0cmluZywgc3ltYm9sOnN0cmluZywgZGVub21pbmF0aW9uOm51bWJlciwgbWludGVyU2V0czpBcnJheTxvYmplY3Q+KTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBuYW1lLFxuICAgICAgc3ltYm9sLFxuICAgICAgZGVub21pbmF0aW9uLFxuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIG1pbnRlclNldHMsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uY3JlYXRlVmFyaWFibGVDYXBBc3NldCcsIHBhcmFtcykudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQuYXNzZXRJRCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogQ3JlYXRlIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIHRvIG1pbnQgbW9yZSBvZiBhbiBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgVGhlIHVuaXRzIG9mIHRoZSBhc3NldCB0byBtaW50XG4gICAgICogQHBhcmFtIGFzc2V0SUQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBtaW50XG4gICAgICogQHBhcmFtIHRvIFRoZSBhZGRyZXNzIHRvIGFzc2lnbiB0aGUgdW5pdHMgb2YgdGhlIG1pbnRlZCBhc3NldFxuICAgICAqIEBwYXJhbSBtaW50ZXJzIEFkZHJlc3NlcyBvZiB0aGUgbWludGVycyByZXNwb25zaWJsZSBmb3Igc2lnbmluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBQcm9taXNlPHN0cmluZz4gY29udGFpbmluZyB0aGUgYmFzZSA1OCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICBjcmVhdGVNaW50VHggPSBhc3luYyAoYW1vdW50Om51bWJlciB8IEJOLCBhc3NldElEOkJ1ZmZlciB8IHN0cmluZywgdG86c3RyaW5nLCBtaW50ZXJzOkFycmF5PHN0cmluZz4pOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgbGV0IGFzc2V0OnN0cmluZztcbiAgICBsZXQgYW1udDpCTjtcbiAgICBpZiAodHlwZW9mIGFzc2V0SUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBhc3NldCA9IGJpbnRvb2xzLmNiNThFbmNvZGUoYXNzZXRJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRJRDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInKSB7XG4gICAgICBhbW50ID0gbmV3IEJOKGFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFtbnQgPSBhbW91bnQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBhbW91bnQ6IGFtbnQudG9TdHJpbmcoMTApLFxuICAgICAgYXNzZXRJRDogYXNzZXQsXG4gICAgICB0byxcbiAgICAgIG1pbnRlcnMsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uY3JlYXRlTWludFR4JywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC50eCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogU2lnbiBhbiB1bnNpZ25lZCBvciBwYXJ0aWFsbHkgc2lnbmVkIG1pbnQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgVGhlIHVzZXIgc2lnbmluZ1xuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgZm9yIHRoZSB1c2VyIHNpZ25pbmdcbiAgICAgKiBAcGFyYW0gdHggVGhlIG91dHB1dCBvZiBjcmVhdGVNaW50VHggb3Igc2lnbk1pbnRUeFxuICAgICAqIEBwYXJhbSBtaW50ZXIgVGhlIG1pbnRlciBzaWduaW5nIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBQcm9taXNlPHN0cmluZz4gY29udGFpbmluZyB0aGUgYmFzZSA1OCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICBzaWduTWludFR4ID0gYXN5bmMgKHVzZXJuYW1lOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCB0eDpzdHJpbmcgfCBCdWZmZXIsIG1pbnRlcjpzdHJpbmcpOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnBhcnNlQWRkcmVzcyhtaW50ZXIpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgLSBBVk1BUEkuc2lnbk1pbnRUeDogSW52YWxpZCBhZGRyZXNzIGZvcm1hdCAke21pbnRlcn1gKTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICB0eCxcbiAgICAgIG1pbnRlcixcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ2F2bS5zaWduTWludFR4JywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC50eCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgcHJpdmF0ZSBrZXkgZm9yIGFuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgVGhlIG5hbWUgb2YgdGhlIHVzZXIgd2l0aCB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHVzZWQgdG8gZGVjcnlwdCB0aGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB3aG9zZSBwcml2YXRlIGtleSBzaG91bGQgYmUgZXhwb3J0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCB0aGUgZGVjcnlwdGVkIHByaXZhdGUga2V5IGFzIHN0b3JlIGluIHRoZSBkYXRhYmFzZVxuICAgICAqL1xuICBleHBvcnRLZXkgPSBhc3luYyAodXNlcm5hbWU6c3RyaW5nLCBwYXNzd29yZDpzdHJpbmcsIGFkZHJlc3M6c3RyaW5nKTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wYXJzZUFkZHJlc3MoYWRkcmVzcykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAtIEFWTUFQSS5leHBvcnRLZXk6IEludmFsaWQgYWRkcmVzcyBmb3JtYXQgJHthZGRyZXNzfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIGFkZHJlc3MsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uZXhwb3J0S2V5JywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5wcml2YXRlS2V5KTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBJbXBvcnRzIGEgcHJpdmF0ZSBrZXkgaW50byB0aGUgbm9kZSdzIGtleXN0b3JlIHVuZGVyIGFuIHVzZXIgYW5kIGZvciBhIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgVGhlIG5hbWUgb2YgdGhlIHVzZXIgdG8gc3RvcmUgdGhlIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0aGF0IHVubG9ja3MgdGhlIHVzZXJcbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHByaXZhdGUga2V5IGluIHRoZSB2bSdzIGZvcm1hdFxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFkZHJlc3MgZm9yIHRoZSBpbXBvcnRlZCBwcml2YXRlIGtleS5cbiAgICAgKi9cbiAgaW1wb3J0S2V5ID0gYXN5bmMgKHVzZXJuYW1lOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCBwcml2YXRlS2V5OnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIHByaXZhdGVLZXksXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uaW1wb3J0S2V5JywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5hZGRyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBTZW5kIEFWQVggZnJvbSB0aGUgWC1DaGFpbiB0byBhbiBhY2NvdW50IG9uIHRoZSBQLUNoYWluLlxuICAgICAqXG4gICAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgeW91IG11c3QgY2FsbCB0aGUgUC1DaGFpbuKAmXMgaW1wb3J0QVZBWCBtZXRob2QgdG8gY29tcGxldGUgdGhlIHRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJuYW1lIFRoZSBLZXlzdG9yZSB1c2VyIHRoYXQgY29udHJvbHMgdGhlIFAtQ2hhaW4gYWNjb3VudCBzcGVjaWZpZWQgaW4gYHRvYFxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgb2YgdGhlIEtleXN0b3JlIHVzZXJcbiAgICAgKiBAcGFyYW0gdG8gVGhlIGFjY291bnQgb24gdGhlIFAtQ2hhaW4gdG8gc2VuZCB0aGUgQVZBWCB0by4gRG8gbm90IGluY2x1ZGUgUC0gaW4gdGhlIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCBvZiBBVkFYIHRvIGV4cG9ydCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0cmFuc2FjdGlvbiBpZFxuICAgICAqL1xuICBleHBvcnRBVkFYID0gYXN5bmMgKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOnN0cmluZywgdG86c3RyaW5nLCBhbW91bnQ6Qk4pOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHRvLFxuICAgICAgYW1vdW50OiBhbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgdXNlcm5hbWUsXG4gICAgICBwYXNzd29yZCxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ2F2bS5leHBvcnRBVkFYJywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC50eElEKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBGaW5hbGl6ZSBhIHRyYW5zZmVyIG9mIEFWQVggZnJvbSB0aGUgUC1DaGFpbiB0byB0aGUgWC1DaGFpbi5cbiAgICAgKlxuICAgICAqIEJlZm9yZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHlvdSBtdXN0IGNhbGwgdGhlIFAtQ2hhaW7igJlzIGBleHBvcnRBVkFYYCBtZXRob2QgdG8gaW5pdGlhdGUgdGhlIHRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIFRoZSBhZGRyZXNzIHRoZSBBVkFYIGlzIHNlbnQgdG8uIFRoaXMgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgdG8gYXJndW1lbnQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FsbCB0byB0aGUgUC1DaGFpbuKAmXMgZXhwb3J0QVZBWCwgZXhjZXB0IHRoYXQgdGhlIHByZXBlbmRlZCBYLSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhpcyBhcmd1bWVudFxuICAgICAqIEBwYXJhbSB1c2VybmFtZSBUaGUgS2V5c3RvcmUgdXNlciB0aGF0IGNvbnRyb2xzIHRoZSBhZGRyZXNzIHNwZWNpZmllZCBpbiBgdG9gXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCBvZiB0aGUgS2V5c3RvcmUgdXNlclxuICAgICAqXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb24gaWRcbiAgICAgKi9cbiAgaW1wb3J0QVZBWCA9IGFzeW5jICh1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDpzdHJpbmcsIHRvOnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdG8sXG4gICAgICB1c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmltcG9ydEFWQVgnLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LnR4SUQpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIExpc3RzIGFsbCB0aGUgYWRkcmVzc2VzIHVuZGVyIGEgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VybmFtZSBUaGUgdXNlciB0byBsaXN0IGFkZHJlc3Nlc1xuICAgICAqIEBwYXJhbSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgb2YgdGhlIHVzZXIgdG8gbGlzdCB0aGUgYWRkcmVzc2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIG9mIGFuIGFycmF5IG9mIGFkZHJlc3Mgc3RyaW5ncyBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZCBieSB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKi9cbiAgbGlzdEFkZHJlc3NlcyA9IGFzeW5jICh1c2VybmFtZTpzdHJpbmcsIHBhc3N3b3JkOnN0cmluZyk6IFByb21pc2U8QXJyYXk8c3RyaW5nPj4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICB1c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmxpc3RBZGRyZXNzZXMnLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LmFkZHJlc3Nlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBhc3NldHMgZm9yIGFuIGFkZHJlc3Mgb24gYSBzZXJ2ZXIgYW5kIHRoZWlyIGFzc29jaWF0ZWQgYmFsYW5jZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBnZXQgYSBsaXN0IG9mIGFzc2V0c1xuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBvZiBhbiBvYmplY3QgbWFwcGluZyBhc3NldElEIHN0cmluZ3Mgd2l0aCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBiYWxhbmNlIGZvciB0aGUgYWRkcmVzcyBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKi9cbiAgZ2V0QWxsQmFsYW5jZXMgPSBhc3luYyAoYWRkcmVzczpzdHJpbmcpOlByb21pc2U8QXJyYXk8b2JqZWN0Pj4gPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wYXJzZUFkZHJlc3MoYWRkcmVzcykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAtIEFWTUFQSS5nZXRBbGxCYWxhbmNlczogSW52YWxpZCBhZGRyZXNzIGZvcm1hdCAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBhZGRyZXNzLFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmdldEFsbEJhbGFuY2VzJywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5iYWxhbmNlcyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0cmlldmVzIGFuIGFzc2V0cyBuYW1lIGFuZCBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJRCBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhbiBiNTggc2VyaWFsaXplZCBzdHJpbmcgZm9yIHRoZSBBc3NldElEIG9yIGl0cyBhbGlhcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBQcm9taXNlPG9iamVjdD4gd2l0aCBrZXlzIFwibmFtZVwiIGFuZCBcInN5bWJvbFwiLlxuICAgICAqL1xuICBnZXRBc3NldERlc2NyaXB0aW9uID0gYXN5bmMgKGFzc2V0SUQ6QnVmZmVyIHwgc3RyaW5nKTpQcm9taXNlPHtuYW1lOnN0cmluZztzeW1ib2w6c3RyaW5nO2Fzc2V0SUQ6QnVmZmVyO2Rlbm9taW5hdGlvbjpudW1iZXJ9PiA9PiB7XG4gICAgbGV0IGFzc2V0OnN0cmluZztcbiAgICBpZiAodHlwZW9mIGFzc2V0SUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBhc3NldCA9IGJpbnRvb2xzLmNiNThFbmNvZGUoYXNzZXRJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRJRDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIGFzc2V0SUQ6IGFzc2V0LFxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmdldEFzc2V0RGVzY3JpcHRpb24nLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+ICh7XG4gICAgICBuYW1lOiByZXNwb25zZS5kYXRhLnJlc3VsdC5uYW1lLFxuICAgICAgc3ltYm9sOiByZXNwb25zZS5kYXRhLnJlc3VsdC5zeW1ib2wsXG4gICAgICBhc3NldElEOiBiaW50b29scy5jYjU4RGVjb2RlKHJlc3BvbnNlLmRhdGEucmVzdWx0LmFzc2V0SUQpLFxuICAgICAgZGVub21pbmF0aW9uOiBwYXJzZUludChyZXNwb25zZS5kYXRhLnJlc3VsdC5kZW5vbWluYXRpb24sIDEwKSxcbiAgICB9KSk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJlYW5zYWN0aW9uIGRhdGEgb2YgYSBwcm92aWRlZCB0cmFuc2FjdGlvbiBJRCBieSBjYWxsaW5nIHRoZSBub2RlJ3MgYGdldFR4YCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhpZCBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbiBJRFxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIFByb21pc2U8c3RyaW5nPiBjb250YWluaW5nIHRoZSBieXRlcyByZXRyaWV2ZWQgZnJvbSB0aGUgbm9kZVxuICAgICAqL1xuICAgIGdldFR4ID0gYXN5bmMgKHR4aWQ6c3RyaW5nKTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgICAgdHhJRDogdHhpZCxcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uZ2V0VHgnLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LnR4KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBhIHByb3ZpZGVkIHRyYW5zYWN0aW9uIElEIGJ5IGNhbGxpbmcgdGhlIG5vZGUncyBgZ2V0VHhTdGF0dXNgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eGlkIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uIElEXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgUHJvbWlzZTxzdHJpbmc+IGNvbnRhaW5pbmcgdGhlIHN0YXR1cyByZXRyaWV2ZWQgZnJvbSB0aGUgbm9kZVxuICAgICAqL1xuICBnZXRUeFN0YXR1cyA9IGFzeW5jICh0eGlkOnN0cmluZyk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdHhJRDogdHhpZCxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ2F2bS5nZXRUeFN0YXR1cycsIHBhcmFtcykudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQuc3RhdHVzKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIFVUWE9zIHJlbGF0ZWQgdG8gdGhlIGFkZHJlc3NlcyBwcm92aWRlZCBmcm9tIHRoZSBub2RlJ3MgYGdldFVUWE9zYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3NlcyBhcyBjYjU4IHN0cmluZ3Mgb3IgYWRkcmVzc2VzIGFzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9c1xuICAgICAqIEBwYXJhbSBwZXJzaXN0T3B0cyBPcHRpb25zIGF2YWlsYWJsZSB0byBwZXJzaXN0IHRoZXNlIFVUWE9zIGluIGxvY2FsIHN0b3JhZ2VcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogcGVyc2lzdE9wdHMgaXMgb3B0aW9uYWwgYW5kIG11c3QgYmUgb2YgdHlwZSBbW1BlcnNpc3RhbmNlT3B0aW9uc11dXG4gICAgICpcbiAgICAgKi9cbiAgZ2V0VVRYT3MgPSBhc3luYyAoYWRkcmVzc2VzOkFycmF5PHN0cmluZz4gfCBBcnJheTxCdWZmZXI+LCBwZXJzaXN0T3B0czpQZXJzaXN0YW5jZU9wdGlvbnMgPSB1bmRlZmluZWQpOlByb21pc2U8VVRYT1NldD4gPT4ge1xuICAgIGNvbnN0IGFkZHJzOkFycmF5PHN0cmluZz4gPSB0aGlzLl9jbGVhbkFkZHJlc3NBcnJheShhZGRyZXNzZXMsICdnZXRVVFhPcycpO1xuXG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIGFkZHJlc3NlczogYWRkcnMsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uZ2V0VVRYT3MnLCBwYXJhbXMpLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHtcbiAgICAgIGNvbnN0IHV0eG9zOlVUWE9TZXQgPSBuZXcgVVRYT1NldCgpO1xuICAgICAgbGV0IGRhdGEgPSByZXNwb25zZS5kYXRhLnJlc3VsdC51dHhvcztcbiAgICAgIGlmIChwZXJzaXN0T3B0cyAmJiB0eXBlb2YgcGVyc2lzdE9wdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICh0aGlzLmRiLmhhcyhwZXJzaXN0T3B0cy5nZXROYW1lKCkpKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZkFycmF5OkFycmF5PHN0cmluZz4gPSB0aGlzLmRiLmdldChwZXJzaXN0T3B0cy5nZXROYW1lKCkpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGZBcnJheSkpIHtcbiAgICAgICAgICAgIHV0eG9zLmFkZEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZjpVVFhPU2V0ID0gbmV3IFVUWE9TZXQoKTtcbiAgICAgICAgICAgIHNlbGYuYWRkQXJyYXkoc2VsZkFycmF5KTtcbiAgICAgICAgICAgIHNlbGYubWVyZ2VCeVJ1bGUodXR4b3MsIHBlcnNpc3RPcHRzLmdldE1lcmdlUnVsZSgpKTtcbiAgICAgICAgICAgIGRhdGEgPSBzZWxmLmdldEFsbFVUWE9TdHJpbmdzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGIuc2V0KHBlcnNpc3RPcHRzLmdldE5hbWUoKSwgZGF0YSwgcGVyc2lzdE9wdHMuZ2V0T3ZlcndyaXRlKCkpO1xuICAgICAgfVxuICAgICAgdXR4b3MuYWRkQXJyYXkoZGF0YSk7XG4gICAgICByZXR1cm4gdXR4b3M7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBVVFhPcyBhYmxlIHRvIGJlIGltcG9ydGVkIGJ5IHRoZSBhZGRyZXNzZXMsIHByb3ZpZGVkIGZyb20gdGhlIG5vZGUncyBgZ2V0QXRvbWljVVRYT3NgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgQW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFzIGNiNTggc3RyaW5ncyBvciBhZGRyZXNzZXMgYXMge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1zXG4gICAgICogQHBhcmFtIHBlcnNpc3RPcHRzIE9wdGlvbnMgYXZhaWxhYmxlIHRvIHBlcnNpc3QgdGhlc2UgVVRYT3MgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBwZXJzaXN0T3B0cyBpcyBvcHRpb25hbCBhbmQgbXVzdCBiZSBvZiB0eXBlIFtbUGVyc2lzdGFuY2VPcHRpb25zXV1cbiAgICAgKlxuICAgICAqL1xuICAgIGdldEF0b21pY1VUWE9zID0gYXN5bmMgKGFkZHJlc3NlczpBcnJheTxzdHJpbmc+IHwgQXJyYXk8QnVmZmVyPiwgcGVyc2lzdE9wdHM6UGVyc2lzdGFuY2VPcHRpb25zID0gdW5kZWZpbmVkKTpQcm9taXNlPFVUWE9TZXQ+ID0+IHtcbiAgICAgIGNvbnN0IGFkZHJzOkFycmF5PHN0cmluZz4gPSB0aGlzLl9jbGVhbkFkZHJlc3NBcnJheShhZGRyZXNzZXMsICdnZXRBdG9taWNVVFhPcycpO1xuICBcbiAgICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICAgIGFkZHJlc3NlczogYWRkcnMsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbE1ldGhvZCgnYXZtLmdldEF0b21pY1VUWE9zJywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHV0eG9zOlVUWE9TZXQgPSBuZXcgVVRYT1NldCgpO1xuICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlLmRhdGEucmVzdWx0LnV0eG9zO1xuICAgICAgICBpZiAocGVyc2lzdE9wdHMgJiYgdHlwZW9mIHBlcnNpc3RPcHRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICh0aGlzLmRiLmhhcyhwZXJzaXN0T3B0cy5nZXROYW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmQXJyYXk6QXJyYXk8c3RyaW5nPiA9IHRoaXMuZGIuZ2V0KHBlcnNpc3RPcHRzLmdldE5hbWUoKSk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxmQXJyYXkpKSB7XG4gICAgICAgICAgICAgIHV0eG9zLmFkZEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICBjb25zdCBzZWxmOlVUWE9TZXQgPSBuZXcgVVRYT1NldCgpO1xuICAgICAgICAgICAgICBzZWxmLmFkZEFycmF5KHNlbGZBcnJheSk7XG4gICAgICAgICAgICAgIHNlbGYubWVyZ2VCeVJ1bGUodXR4b3MsIHBlcnNpc3RPcHRzLmdldE1lcmdlUnVsZSgpKTtcbiAgICAgICAgICAgICAgZGF0YSA9IHNlbGYuZ2V0QWxsVVRYT1N0cmluZ3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kYi5zZXQocGVyc2lzdE9wdHMuZ2V0TmFtZSgpLCBkYXRhLCBwZXJzaXN0T3B0cy5nZXRPdmVyd3JpdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXR4b3MuYWRkQXJyYXkoZGF0YSk7XG4gICAgICAgIHJldHVybiB1dHhvcztcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb24uIEZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wsIHlvdSBtYXkgY3JlYXRlIHlvdXIgb3duXG4gICAgICogW1tVbnNpZ25lZFR4XV0gbWFudWFsbHkgKHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBbW1RyYW5zZmVyYWJsZUlucHV0XV1zLCBbW1RyYW5zZmVyYWJsZU91dHB1dF1dcywgYW5kIFtbVHJhbnNmZXJPcGVyYXRpb25dXXMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9zZXQgQSBzZXQgb2YgVVRYT3MgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgYnVpbHQgb25cbiAgICAgKiBAcGFyYW0gYW1vdW50IFRoZSBhbW91bnQgb2YgQVZBWCB0byBiZSBzcGVudCBpbiAkbkFWQVhcbiAgICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBmdW5kc1xuICAgICAqIEBwYXJhbSBmcm9tQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgYmVpbmcgdXNlZCB0byBzZW5kIHRoZSBmdW5kcyBmcm9tIHRoZSBVVFhPcyBwcm92aWRlZFxuICAgICAqIEBwYXJhbSBjaGFuZ2VBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0aGF0IGNhbiBzcGVuZCB0aGUgY2hhbmdlIHJlbWFpbmluZyBmcm9tIHRoZSBzcGVudCBVVFhPc1xuICAgICAqIEBwYXJhbSBhc3NldElEIFRoZSBhc3NldElEIG9mIHRoZSB2YWx1ZSBiZWluZyBzZW50XG4gICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICAgKiBAcGFyYW0gYXNPZiBPcHRpb25hbC4gVGhlIHRpbWVzdGFtcCB0byB2ZXJpZnkgdGhlIHRyYW5zYWN0aW9uIGFnYWluc3QgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfVxuICAgICAqIEBwYXJhbSBsb2NrdGltZSBPcHRpb25hbC4gVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyBvdXRwdXRzXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IFVUWE9cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIChbW1Vuc2lnbmVkVHhdXSkgd2hpY2ggY29udGFpbnMgYSBbW0Jhc2VUeF1dLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGhlbHBlciBleGlzdHMgYmVjYXVzZSB0aGUgZW5kcG9pbnQgQVBJIHNob3VsZCBiZSB0aGUgcHJpbWFyeSBwb2ludCBvZiBlbnRyeSBmb3IgbW9zdCBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICBidWlsZEJhc2VUeCA9IGFzeW5jIChcbiAgICB1dHhvc2V0OlVUWE9TZXQsIGFtb3VudDpCTiwgdG9BZGRyZXNzZXM6QXJyYXk8c3RyaW5nPiwgZnJvbUFkZHJlc3NlczpBcnJheTxzdHJpbmc+LFxuICAgIGNoYW5nZUFkZHJlc3NlczpBcnJheTxzdHJpbmc+LCBhc3NldElEOkJ1ZmZlciB8IHN0cmluZyA9IHVuZGVmaW5lZCwgbWVtbzpQYXlsb2FkQmFzZXxCdWZmZXIgPSB1bmRlZmluZWQsIGFzT2Y6Qk4gPSBVbml4Tm93KCksXG4gICAgbG9ja3RpbWU6Qk4gPSBuZXcgQk4oMCksIHRocmVzaG9sZDpudW1iZXIgPSAxXG4gICk6UHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgY29uc3QgdG86QXJyYXk8QnVmZmVyPiA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KHRvQWRkcmVzc2VzLCAnYnVpbGRCYXNlVHgnKS5tYXAoKGEpID0+IGJpbnRvb2xzLnN0cmluZ1RvQWRkcmVzcyhhKSk7XG4gICAgY29uc3QgZnJvbTpBcnJheTxCdWZmZXI+ID0gdGhpcy5fY2xlYW5BZGRyZXNzQXJyYXkoZnJvbUFkZHJlc3NlcywgJ2J1aWxkQmFzZVR4JykubWFwKChhKSA9PiBiaW50b29scy5zdHJpbmdUb0FkZHJlc3MoYSkpO1xuICAgIGNvbnN0IGNoYW5nZTpBcnJheTxCdWZmZXI+ID0gdGhpcy5fY2xlYW5BZGRyZXNzQXJyYXkoY2hhbmdlQWRkcmVzc2VzLCAnYnVpbGRCYXNlVHgnKS5tYXAoKGEpID0+IGJpbnRvb2xzLnN0cmluZ1RvQWRkcmVzcyhhKSk7XG5cbiAgICBpZiAodHlwZW9mIGFzc2V0SUQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhc3NldElEID0gYmludG9vbHMuY2I1OERlY29kZShhc3NldElEKTtcbiAgICB9XG5cbiAgICBpZiggbWVtbyBpbnN0YW5jZW9mIFBheWxvYWRCYXNlKSB7XG4gICAgICBtZW1vID0gbWVtby5nZXRQYXlsb2FkKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVpbHRVbnNpZ25lZFR4OlVuc2lnbmVkVHggPSB1dHhvc2V0LmJ1aWxkQmFzZVR4KFxuICAgICAgdGhpcy5jb3JlLmdldE5ldHdvcmtJRCgpLCBiaW50b29scy5jYjU4RGVjb2RlKHRoaXMuYmxvY2tjaGFpbklEKSxcbiAgICAgIGFtb3VudCwgdG8sIGZyb20sIGNoYW5nZSxcbiAgICAgIGFzc2V0SUQsIG1lbW8sIGFzT2YsIGxvY2t0aW1lLCB0aHJlc2hvbGQsXG4gICAgKTtcblxuICAgIGlmKCEgYXdhaXQgdGhpcy5jaGVja0dvb3NlRWdnKGJ1aWx0VW5zaWduZWRUeCkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgR29vc2UgRWdnIENoZWNrXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsdFVuc2lnbmVkVHg7XG4gIH07XG5cbiAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYW4gdW5zaWduZWQgTkZUIFRyYW5zZmVyLiBGb3IgbW9yZSBncmFudWxhciBjb250cm9sLCB5b3UgbWF5IGNyZWF0ZSB5b3VyIG93blxuICAgICAqIFtbVW5zaWduZWRUeF1dIG1hbnVhbGx5ICh3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgW1tUcmFuc2ZlcmFibGVJbnB1dF1dcywgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXMsIGFuZCBbW1RyYW5zZmVyT3BlcmF0aW9uXV1zKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvc2V0ICBBIHNldCBvZiBVVFhPcyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBidWlsdCBvblxuICAgICAqIEBwYXJhbSB1dHhvaWQgQSBiYXNlNTggdXR4b0lEIG9yIGFuIGFycmF5IG9mIGJhc2U1OCB1dHhvSURzIGZvciB0aGUgbmZ0cyB0aGlzIHRyYW5zYWN0aW9uIGlzIHNlbmRpbmdcbiAgICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBORlRcbiAgICAgKiBAcGFyYW0gZnJvbUFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCB0aGUgTkZUIGZyb20gdGhlIHV0eG9JRCBwcm92aWRlZFxuICAgICAqIEBwYXJhbSBmZWVBbW91bnQgVGhlIGFtb3VudCBvZiBmZWVzIGJlaW5nIHBhaWQgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gZmVlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBoYXZlIHRoZSBBVkFYIGZ1bmRzIHRvIHBheSBmb3IgZmVlcyBvZiB0aGUgVVRYT1xuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKiBAcGFyYW0gbG9ja3RpbWUgT3B0aW9uYWwuIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgb3V0cHV0c1xuICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBVVFhPXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiAoW1tVbnNpZ25lZFR4XV0pIHdoaWNoIGNvbnRhaW5zIGEgW1tORlRUcmFuc2ZlclR4XV0uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgaGVscGVyIGV4aXN0cyBiZWNhdXNlIHRoZSBlbmRwb2ludCBBUEkgc2hvdWxkIGJlIHRoZSBwcmltYXJ5IHBvaW50IG9mIGVudHJ5IGZvciBtb3N0IGZ1bmN0aW9uYWxpdHkuXG4gICAgICovXG4gIGJ1aWxkTkZUVHJhbnNmZXJUeCA9IGFzeW5jIChcbiAgICB1dHhvc2V0OlVUWE9TZXQsIHV0eG9pZDpzdHJpbmcgfCBBcnJheTxzdHJpbmc+LCB0b0FkZHJlc3NlczpBcnJheTxzdHJpbmc+LCBmcm9tQWRkcmVzc2VzOkFycmF5PHN0cmluZz4sIGZlZUFtb3VudDpCTixcbiAgICBmZWVBZGRyZXNzZXM6QXJyYXk8c3RyaW5nPiwgbWVtbzpQYXlsb2FkQmFzZXxCdWZmZXIgPSB1bmRlZmluZWQsIGFzT2Y6Qk4gPSBVbml4Tm93KCksIGxvY2t0aW1lOkJOID0gbmV3IEJOKDApLCB0aHJlc2hvbGQ6bnVtYmVyID0gMSxcbiAgKTpQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBjb25zdCB0bzpBcnJheTxCdWZmZXI+ID0gdGhpcy5fY2xlYW5BZGRyZXNzQXJyYXkodG9BZGRyZXNzZXMsICdidWlsZE5GVFRyYW5zZmVyVHgnKS5tYXAoKGEpID0+IGJpbnRvb2xzLnN0cmluZ1RvQWRkcmVzcyhhKSk7XG4gICAgY29uc3QgZnJvbTpBcnJheTxCdWZmZXI+ID0gdGhpcy5fY2xlYW5BZGRyZXNzQXJyYXkoZnJvbUFkZHJlc3NlcywgJ2J1aWxkTkZUVHJhbnNmZXJUeCcpLm1hcCgoYSkgPT4gYmludG9vbHMuc3RyaW5nVG9BZGRyZXNzKGEpKTtcbiAgICBjb25zdCBmZWVBZGRyczpBcnJheTxCdWZmZXI+ID0gdGhpcy5fY2xlYW5BZGRyZXNzQXJyYXkoZmVlQWRkcmVzc2VzLCAnYnVpbGRORlRUcmFuc2ZlclR4JykubWFwKChhKSA9PiBiaW50b29scy5zdHJpbmdUb0FkZHJlc3MoYSkpO1xuXG4gICAgaWYoIG1lbW8gaW5zdGFuY2VvZiBQYXlsb2FkQmFzZSkge1xuICAgICAgbWVtbyA9IG1lbW8uZ2V0UGF5bG9hZCgpO1xuICAgIH1cbiAgICBjb25zdCBhdmF4QXNzZXRJRDpCdWZmZXIgPSBhd2FpdCB0aGlzLmdldEFWQVhBc3NldElEKCk7XG5cbiAgICBsZXQgdXR4b2lkQXJyYXk6QXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgIGlmICh0eXBlb2YgdXR4b2lkID09PSAnc3RyaW5nJykge1xuICAgICAgdXR4b2lkQXJyYXkgPSBbdXR4b2lkXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodXR4b2lkKSkge1xuICAgICAgdXR4b2lkQXJyYXkgPSB1dHhvaWQ7XG4gICAgfVxuXG4gICAgY29uc3QgYnVpbHRVbnNpZ25lZFR4OlVuc2lnbmVkVHggPSB1dHhvc2V0LmJ1aWxkTkZUVHJhbnNmZXJUeChcbiAgICAgIHRoaXMuY29yZS5nZXROZXR3b3JrSUQoKSwgYmludG9vbHMuY2I1OERlY29kZSh0aGlzLmJsb2NrY2hhaW5JRCksIGF2YXhBc3NldElELFxuICAgICAgZmVlQW1vdW50LCBmZWVBZGRycywgdG8sIGZyb20sIHV0eG9pZEFycmF5LCBtZW1vLCBhc09mLCBsb2NrdGltZSwgdGhyZXNob2xkLFxuICAgICk7XG5cbiAgICBpZighIGF3YWl0IHRoaXMuY2hlY2tHb29zZUVnZyhidWlsdFVuc2lnbmVkVHgpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIEdvb3NlIEVnZyBDaGVja1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVpbHRVbnNpZ25lZFR4O1xuICB9O1xuXG4gICAgLyoqXG4gICAgICogSW4tRGV2ZWxvcG1lbnQsIGRvIG5vdCB1c2U6IEhlbHBlciBmdW5jdGlvbiB3aGljaCBjcmVhdGVzIGFuIHVuc2lnbmVkIEltcG9ydCBUeC4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAgKiBbW1Vuc2lnbmVkVHhdXSBtYW51YWxseSAod2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMsIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zLCBhbmQgW1tUcmFuc2Zlck9wZXJhdGlvbl1dcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCAgQSBzZXQgb2YgVVRYT3MgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgYnVpbHQgb25cbiAgICAgKiBAcGFyYW0gb3duZXJBZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyBiZWluZyB1c2VkIHRvIGltcG9ydFxuICAgICAqIEBwYXJhbSBmZWVBbW91bnQgVGhlIGFtb3VudCBvZiBmZWVzIGJlaW5nIHBhaWQgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gZmVlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBoYXZlIHRoZSBBVkFYIGZ1bmRzIHRvIHBheSBmb3IgZmVlcyBvZiB0aGUgVVRYT1xuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKiBAcGFyYW0gbG9ja3RpbWUgT3B0aW9uYWwuIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgb3V0cHV0c1xuICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgT3B0aW9uYWwuIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgZnVuZHMgaW4gdGhlIHJlc3VsdGFudCBVVFhPXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiAoW1tVbnNpZ25lZFR4XV0pIHdoaWNoIGNvbnRhaW5zIGEgW1tJbXBvcnRUeF1dLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGhlbHBlciBleGlzdHMgYmVjYXVzZSB0aGUgZW5kcG9pbnQgQVBJIHNob3VsZCBiZSB0aGUgcHJpbWFyeSBwb2ludCBvZiBlbnRyeSBmb3IgbW9zdCBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIGJ1aWxkSW1wb3J0VHggPSBhc3luYyAoXG4gICAgICB1dHhvc2V0OlVUWE9TZXQsIG93bmVyQWRkcmVzc2VzOkFycmF5PHN0cmluZz4sIGZlZUFtb3VudDpCTiwgXG4gICAgICBmZWVBZGRyZXNzZXM6QXJyYXk8c3RyaW5nPiwgbWVtbzpQYXlsb2FkQmFzZXxCdWZmZXIgPSB1bmRlZmluZWQsIGFzT2Y6Qk4gPSBVbml4Tm93KCksIFxuICAgICk6UHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgICBjb25zdCBvd25lcnM6QXJyYXk8QnVmZmVyPiA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KG93bmVyQWRkcmVzc2VzLCAnYnVpbGRJbXBvcnRUeCcpLm1hcCgoYSkgPT4gYmludG9vbHMuc3RyaW5nVG9BZGRyZXNzKGEpKTtcbiAgICAgIGNvbnN0IGZlZUFkZHJzOkFycmF5PEJ1ZmZlcj4gPSB0aGlzLl9jbGVhbkFkZHJlc3NBcnJheShmZWVBZGRyZXNzZXMsICdidWlsZEltcG9ydFR4JykubWFwKChhKSA9PiBiaW50b29scy5zdHJpbmdUb0FkZHJlc3MoYSkpO1xuXG4gICAgICBjb25zdCBhdG9taWNVVFhPczpVVFhPU2V0ID0gYXdhaXQgdGhpcy5nZXRBdG9taWNVVFhPcyhvd25lcnMpO1xuICAgICAgY29uc3QgYXZheEFzc2V0SUQ6QnVmZmVyID0gYXdhaXQgdGhpcy5nZXRBVkFYQXNzZXRJRCgpO1xuICAgICAgY29uc3QgYXZheEFzc2V0SURTdHI6c3RyaW5nID0gYXZheEFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIik7XG5cblxuICAgICAgaWYoIG1lbW8gaW5zdGFuY2VvZiBQYXlsb2FkQmFzZSkge1xuICAgICAgICBtZW1vID0gbWVtby5nZXRQYXlsb2FkKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGF0b21pY3MgPSBhdG9taWNVVFhPcy5nZXRBbGxVVFhPcygpO1xuICAgICAgY29uc3QgaW1wb3J0SW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IFtdO1xuICAgICAgZm9yKGxldCBpOm51bWJlciA9IDA7IGkgPCBhdG9taWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHV0eG86VVRYTyA9IGF0b21pY3NbaV07XG4gICAgICAgIGNvbnN0IGFzc2V0SUQ6QnVmZmVyID0gdXR4by5nZXRBc3NldElEKCk7XG4gICAgICAgIGlmKGFzc2V0SUQudG9TdHJpbmcoXCJoZXhcIikgPT09IGF2YXhBc3NldElEU3RyKSB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0OkFtb3VudE91dHB1dCA9IHV0eG8uZ2V0T3V0cHV0KCkgYXMgQW1vdW50T3V0cHV0O1xuICAgICAgICAgIGNvbnN0IGFtdDpCTiA9IG91dHB1dC5nZXRBbW91bnQoKS5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IHR4aWQ6QnVmZmVyID0gdXR4by5nZXRUeElEKCk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0aWR4OkJ1ZmZlciA9IHV0eG8uZ2V0T3V0cHV0SWR4KCk7XG4gICAgICAgICAgY29uc3QgaW5wdXQ6U2VjcElucHV0ID0gbmV3IFNlY3BJbnB1dChhbXQpO1xuICAgICAgICAgIGNvbnN0IHhmZXJpbjpUcmFuc2ZlcmFibGVJbnB1dCA9IG5ldyBUcmFuc2ZlcmFibGVJbnB1dCh0eGlkLCBvdXRwdXRpZHgsIGFzc2V0SUQsIGlucHV0KTtcbiAgICAgICAgICBjb25zdCBmcm9tQWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4gPSBvdXRwdXQuZ2V0QWRkcmVzc2VzKCk7IC8vIFZlcmlmeSBjb3JyZWN0IGFwcHJvYWNoXG4gICAgICAgICAgY29uc3Qgc3BlbmRlcnM6QXJyYXk8QnVmZmVyPiA9IG91dHB1dC5nZXRTcGVuZGVycyhmcm9tQWRkcmVzc2VzLCBhc09mKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwZW5kZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBpZHg6bnVtYmVyID0gb3V0cHV0LmdldEFkZHJlc3NJZHgoc3BlbmRlcnNbal0pO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciAtIFVUWE9TZXQuYnVpbGRCYXNlVHg6IG5vIHN1Y2ggJ1xuICAgICAgICAgICAgICArIGBhZGRyZXNzIGluIG91dHB1dDogJHtzcGVuZGVyc1tqXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhmZXJpbi5nZXRJbnB1dCgpLmFkZFNpZ25hdHVyZUlkeChpZHgsIHNwZW5kZXJzW2pdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW1wb3J0SW5zLnB1c2goeGZlcmluKTtcbiAgICAgICAgfVxuICAgICAgfVxuICBcbiAgICAgIGNvbnN0IGJ1aWx0VW5zaWduZWRUeDpVbnNpZ25lZFR4ID0gdXR4b3NldC5idWlsZEltcG9ydFR4KFxuICAgICAgICB0aGlzLmNvcmUuZ2V0TmV0d29ya0lEKCksIGJpbnRvb2xzLmNiNThEZWNvZGUodGhpcy5ibG9ja2NoYWluSUQpLCBhdmF4QXNzZXRJRCxcbiAgICAgICAgZmVlQW1vdW50LCBmZWVBZGRycywgaW1wb3J0SW5zLCBtZW1vLCBhc09mXG4gICAgICApO1xuICBcbiAgICAgIGlmKCEgYXdhaXQgdGhpcy5jaGVja0dvb3NlRWdnKGJ1aWx0VW5zaWduZWRUeCkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIEdvb3NlIEVnZyBDaGVja1wiKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gYnVpbHRVbnNpZ25lZFR4O1xuICAgIH07XG5cbiAgLyoqXG4gICAgICogSW4tRGV2ZWxvcG1lbnQsIGRvIG5vdCB1c2U6IEhlbHBlciBmdW5jdGlvbiB3aGljaCBjcmVhdGVzIGFuIHVuc2lnbmVkIEV4cG9ydCBUeC4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAgKiBbW1Vuc2lnbmVkVHhdXSBtYW51YWxseSAod2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMsIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zLCBhbmQgW1tUcmFuc2Zlck9wZXJhdGlvbl1dcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBBIHNldCBvZiBVVFhPcyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBidWlsdCBvblxuICAgICAqIEBwYXJhbSB1dHhvaWQgQSBiYXNlNTggdXR4b0lEIG9yIGFuIGFycmF5IG9mIGJhc2U1OCB1dHhvSURzIGZvciB0aGUgQVZBWCB0aGlzIHRyYW5zYWN0aW9uIGlzIGV4cG9ydGluZ1xuICAgICAqIEBwYXJhbSBmZWVBbW91bnQgVGhlIGFtb3VudCBvZiBmZWVzIGJlaW5nIHBhaWQgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gZmVlQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdGhhdCBoYXZlIHRoZSBBVkFYIGZ1bmRzIHRvIHBheSBmb3IgZmVlcyBvZiB0aGUgVVRYT1xuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIChbW1Vuc2lnbmVkVHhdXSkgd2hpY2ggY29udGFpbnMgYW4gW1tFeHBvcnRUeF1dLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGhlbHBlciBleGlzdHMgYmVjYXVzZSB0aGUgZW5kcG9pbnQgQVBJIHNob3VsZCBiZSB0aGUgcHJpbWFyeSBwb2ludCBvZiBlbnRyeSBmb3IgbW9zdCBmdW5jdGlvbmFsaXR5LlxuICAgICAqL1xuICAgIGJ1aWxkRXhwb3J0VHggPSBhc3luYyAoXG4gICAgICB1dHhvc2V0OlVUWE9TZXQsIHV0eG9pZDpzdHJpbmcgfCBBcnJheTxzdHJpbmc+LCBmZWVBbW91bnQ6Qk4sXG4gICAgICBmZWVBZGRyZXNzZXM6QXJyYXk8c3RyaW5nPiwgbWVtbzpQYXlsb2FkQmFzZXxCdWZmZXIgPSB1bmRlZmluZWQsIGFzT2Y6Qk4gPSBVbml4Tm93KClcbiAgICApOlByb21pc2U8VW5zaWduZWRUeD4gPT4ge1xuICAgICAgY29uc3QgZmVlQWRkcnM6QXJyYXk8QnVmZmVyPiA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KGZlZUFkZHJlc3NlcywgJ2J1aWxkRXhwb3J0VHgnKS5tYXAoKGEpID0+IGJpbnRvb2xzLnN0cmluZ1RvQWRkcmVzcyhhKSk7XG4gIFxuICAgICAgaWYoIG1lbW8gaW5zdGFuY2VvZiBQYXlsb2FkQmFzZSkge1xuICAgICAgICBtZW1vID0gbWVtby5nZXRQYXlsb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF2YXhBc3NldElEOkJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2V0QVZBWEFzc2V0SUQoKTtcbiAgXG4gICAgICBsZXQgdXR4b2lkQXJyYXk6QXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiB1dHhvaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHV0eG9pZEFycmF5ID0gW3V0eG9pZF07XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodXR4b2lkKSkge1xuICAgICAgICB1dHhvaWRBcnJheSA9IHV0eG9pZDtcbiAgICAgIH1cbiAgXG4gICAgICBjb25zdCBidWlsdFVuc2lnbmVkVHg6VW5zaWduZWRUeCA9IHV0eG9zZXQuYnVpbGRFeHBvcnRUeChcbiAgICAgICAgdGhpcy5jb3JlLmdldE5ldHdvcmtJRCgpLCBiaW50b29scy5jYjU4RGVjb2RlKHRoaXMuYmxvY2tjaGFpbklEKSwgYXZheEFzc2V0SUQsXG4gICAgICAgIGZlZUFtb3VudCwgZmVlQWRkcnMsIHV0eG9pZEFycmF5LCBtZW1vLCBhc09mXG4gICAgICApO1xuICBcbiAgICAgIGlmKCEgYXdhaXQgdGhpcy5jaGVja0dvb3NlRWdnKGJ1aWx0VW5zaWduZWRUeCkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIEdvb3NlIEVnZyBDaGVja1wiKTtcbiAgICAgIH1cbiAgXG4gICAgICByZXR1cm4gYnVpbHRVbnNpZ25lZFR4O1xuICAgIH07XG5cbiAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbi4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAgKiBbW1Vuc2lnbmVkVHhdXSBtYW51YWxseSAod2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMsIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zLCBhbmQgW1tUcmFuc2Zlck9wZXJhdGlvbl1dcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBBIHNldCBvZiBVVFhPcyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBidWlsdCBvblxuICAgICAqIEBwYXJhbSBmZWUgVGhlIGFtb3VudCBvZiBBVkFYIHRvIGJlIHBhaWQgZm9yIGZlZXMsIGluICRuQVZBWFxuICAgICAqIEBwYXJhbSBjcmVhdG9yQWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdG8gc2VuZCB0aGUgZmVlc1xuICAgICAqIEBwYXJhbSBpbml0aWFsU3RhdGVzIFRoZSBbW0luaXRpYWxTdGF0ZXNdXSB0aGF0IHJlcHJlc2VudCB0aGUgaW50aWFsIHN0YXRlIG9mIGEgY3JlYXRlZCBhc3NldFxuICAgICAqIEBwYXJhbSBuYW1lIFN0cmluZyBmb3IgdGhlIGRlc2NyaXB0aXZlIG5hbWUgb2YgdGhlIGFzc2V0XG4gICAgICogQHBhcmFtIHN5bWJvbCBTdHJpbmcgZm9yIHRoZSB0aWNrZXIgc3ltYm9sIG9mIHRoZSBhc3NldFxuICAgICAqIEBwYXJhbSBkZW5vbWluYXRpb24gT3B0aW9uYWwgbnVtYmVyIGZvciB0aGUgZGVub21pbmF0aW9uIHdoaWNoIGlzIDEwXkQuIEQgbXVzdCBiZSA+PSAwIGFuZCA8PSAzMi4gRXg6ICQxIEFWQVggPSAxMF45ICRuQVZBWFxuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcywgdXAgdG8gMjU2IGJ5dGVzXG4gICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIChbW1Vuc2lnbmVkVHhdXSkgd2hpY2ggY29udGFpbnMgYSBbW0NyZWF0ZUFzc2V0VHhdXS5cbiAgICAgKiBcbiAgICAgKi9cbiAgYnVpbGRDcmVhdGVBc3NldFR4ID0gYXN5bmMgKFxuICAgICAgdXR4b3NldDpVVFhPU2V0LCBmZWU6Qk4sIGNyZWF0b3JBZGRyZXNzZXM6QXJyYXk8c3RyaW5nPiB8IEFycmF5PEJ1ZmZlcj4sIFxuICAgICAgaW5pdGlhbFN0YXRlczpJbml0aWFsU3RhdGVzLCBuYW1lOnN0cmluZywgXG4gICAgICBzeW1ib2w6c3RyaW5nLCBkZW5vbWluYXRpb246bnVtYmVyLCBtZW1vOlBheWxvYWRCYXNlfEJ1ZmZlciA9IHVuZGVmaW5lZCwgYXNPZjpCTiA9IFVuaXhOb3coKSxcbiAgICAgIGxvY2t0aW1lOkJOID0gdW5kZWZpbmVkXG4gICk6UHJvbWlzZTxVbnNpZ25lZFR4PiA9PiB7XG4gICAgICBsZXQgY3JlYXRvcnM6QXJyYXk8QnVmZmVyPiA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KGNyZWF0b3JBZGRyZXNzZXMsIFwiYnVpbGRDcmVhdGVBc3NldFR4XCIpLm1hcChhID0+IGJpbnRvb2xzLnN0cmluZ1RvQWRkcmVzcyhhKSk7XG5cbiAgICAgIGlmKCBtZW1vIGluc3RhbmNlb2YgUGF5bG9hZEJhc2UpIHtcbiAgICAgICAgbWVtbyA9IG1lbW8uZ2V0UGF5bG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYoc3ltYm9sLmxlbmd0aCA+IEFWTUNvbnN0YW50cy5TWU1CT0xNQVhMRU4pe1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgLSBBVk1BUEkuYnVpbGRDcmVhdGVBc3NldFR4OiBTeW1ib2xzIG1heSBub3QgZXhjZWVkIGxlbmd0aCBvZiBcIiArIEFWTUNvbnN0YW50cy5TWU1CT0xNQVhMRU4pO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmKG5hbWUubGVuZ3RoID4gQVZNQ29uc3RhbnRzLkFTU0VUTkFNRUxFTikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciAtIEFWTUFQSS5idWlsZENyZWF0ZUFzc2V0VHg6IE5hbWVzIG1heSBub3QgZXhjZWVkIGxlbmd0aCBvZiBcIiArIEFWTUNvbnN0YW50cy5BU1NFVE5BTUVMRU4pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdmF4QXNzZXRJRDpCdWZmZXIgPSBhd2FpdCB0aGlzLmdldEFWQVhBc3NldElEKCk7XG4gICAgICBjb25zdCBidWlsdFVuc2lnbmVkVHg6VW5zaWduZWRUeCA9IHV0eG9zZXQuYnVpbGRDcmVhdGVBc3NldFR4KFxuICAgICAgICB0aGlzLmNvcmUuZ2V0TmV0d29ya0lEKCksIGJpbnRvb2xzLmNiNThEZWNvZGUodGhpcy5ibG9ja2NoYWluSUQpLCBhdmF4QXNzZXRJRCxcbiAgICAgICAgZmVlLCBjcmVhdG9ycywgaW5pdGlhbFN0YXRlcywgbmFtZSwgc3ltYm9sLCBkZW5vbWluYXRpb24sIG1lbW8sIGFzT2ZcbiAgICAgICk7XG4gIFxuICAgICAgaWYoISBhd2FpdCB0aGlzLmNoZWNrR29vc2VFZ2coYnVpbHRVbnNpZ25lZFR4KSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgR29vc2UgRWdnIENoZWNrXCIpO1xuICAgICAgfVxuICBcbiAgICAgIHJldHVybiBidWlsdFVuc2lnbmVkVHg7XG4gICAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbi4gRm9yIG1vcmUgZ3JhbnVsYXIgY29udHJvbCwgeW91IG1heSBjcmVhdGUgeW91ciBvd25cbiAgICAqIFtbVW5zaWduZWRUeF1dIG1hbnVhbGx5ICh3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmcgW1tUcmFuc2ZlcmFibGVJbnB1dF1dcywgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXMsIGFuZCBbW1RyYW5zZmVyT3BlcmF0aW9uXV1zKS5cbiAgICAqIFxuICAgICogQHBhcmFtIHV0eG9zZXQgQSBzZXQgb2YgVVRYT3MgdGhhdCB0aGUgdHJhbnNhY3Rpb24gaXMgYnVpbHQgb25cbiAgICAqIEBwYXJhbSBmZWUgVGhlIGFtb3VudCBvZiBBVkFYIHRvIGJlIHBhaWQgZm9yIGZlZXMsIGluICRuQVZBWFxuICAgICogQHBhcmFtIGZlZVBheWluZ0FkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRvIHBheSB0aGUgZmVlc1xuICAgICogQHBhcmFtIG5hbWUgU3RyaW5nIGZvciB0aGUgZGVzY3JpcHRpdmUgbmFtZSBvZiB0aGUgYXNzZXRcbiAgICAqIEBwYXJhbSBzeW1ib2wgU3RyaW5nIGZvciB0aGUgdGlja2VyIHN5bWJvbCBvZiB0aGUgYXNzZXRcbiAgICAqIEBwYXJhbSBtaW50ZXJTZXRzIGlzIGEgbGlzdCB3aGVyZSBlYWNoIGVsZW1lbnQgc3BlY2lmaWVzIHRoYXQgdGhyZXNob2xkIG9mIHRoZSBhZGRyZXNzZXMgaW4gbWludGVycyBtYXkgdG9nZXRoZXIgbWludCBtb3JlIG9mIHRoZSBhc3NldCBieSBzaWduaW5nIGEgbWludGluZyB0cmFuc2FjdGlvblxuICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwgY29udGFpbnMgYXJiaXRyYXJ5IGJ5dGVzLCB1cCB0byAyNTYgYnl0ZXNcbiAgICAqIEBwYXJhbSBhc09mIE9wdGlvbmFsLiBUaGUgdGltZXN0YW1wIHRvIHZlcmlmeSB0aGUgdHJhbnNhY3Rpb24gYWdhaW5zdCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59XG4gICAgKiBAcGFyYW0gbG9ja3RpbWUgT3B0aW9uYWwuIFRoZSBsb2NrdGltZSBmaWVsZCBjcmVhdGVkIGluIHRoZSByZXN1bHRpbmcgbWludCBvdXRwdXRcbiAgICAqIFxuICAgICogYGBganNcbiAgICAqIEV4YW1wbGUgbWludGVyU2V0czpcbiAgICAqIFtcbiAgICAqICAgICAge1xuICAgICogICAgICAgICAgXCJtaW50ZXJzXCI6W1xuICAgICogICAgICAgICAgICAgIFwiWC00cGVKc0Z2aGRuN1hqaE5GNEhXQVF5NllhSnRzMjdzOXFcIlxuICAgICogICAgICAgICAgXSxcbiAgICAqICAgICAgICAgIFwidGhyZXNob2xkXCI6IDFcbiAgICAqICAgICAgfSxcbiAgICAqICAgICAge1xuICAgICogICAgICAgICAgXCJtaW50ZXJzXCI6IFtcbiAgICAqICAgICAgICAgICAgICBcIlgtZGNKNno5ZHVMZnlRVGdianEyd0JDb3drdmNQWkhWREZcIixcbiAgICAqICAgICAgICAgICAgICBcIlgtMmZFNmlpYnFmRVJ6NXdlblhFNnF5dmluc3hEdkZoSFprXCIsXG4gICAgKiAgICAgICAgICAgICAgXCJYLTdpZUFKYmZyR1FicE5aUkFRRXBaQ0MxR3MxejVnejRIVVwiXG4gICAgKiAgICAgICAgICBdLFxuICAgICogICAgICAgICAgXCJ0aHJlc2hvbGRcIjogMlxuICAgICogICAgICB9XG4gICAgKiBdXG4gICAgKiBgYGBcbiAgICAqIFxuICAgICogQHJldHVybnMgQW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gKFtbVW5zaWduZWRUeF1dKSB3aGljaCBjb250YWlucyBhIFtbQ3JlYXRlQXNzZXRUeF1dLlxuICAgICogXG4gICAgKi9cbiAgIGJ1aWxkQ3JlYXRlTkZUQXNzZXRUeCA9IGFzeW5jIChcbiAgICB1dHhvc2V0OlVUWE9TZXQsIGZlZTpCTiwgZmVlUGF5aW5nQWRkcmVzc2VzOkFycmF5PHN0cmluZz4gfCBBcnJheTxCdWZmZXI+LCBcbiAgICBuYW1lOnN0cmluZywgc3ltYm9sOnN0cmluZywgbWludGVyU2V0czpNaW50ZXJTZXRbXSwgbWVtbzpQYXlsb2FkQmFzZXxCdWZmZXIgPSB1bmRlZmluZWQsIGFzT2Y6Qk4gPSBVbml4Tm93KCksIGxvY2t0aW1lOkJOID0gbmV3IEJOKDApXG4gICAgICApOiBQcm9taXNlPFVuc2lnbmVkVHg+ID0+IHtcbiAgICBsZXQgZmVlQWRkcnM6QXJyYXk8QnVmZmVyPiA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KGZlZVBheWluZ0FkZHJlc3NlcywgXCJidWlsZENyZWF0ZU5GVEFzc2V0VHhcIikubWFwKGEgPT4gYmludG9vbHMuc3RyaW5nVG9BZGRyZXNzKGEpKTtcbiAgICBcbiAgICBpZiggbWVtbyBpbnN0YW5jZW9mIFBheWxvYWRCYXNlKSB7XG4gICAgICBtZW1vID0gbWVtby5nZXRQYXlsb2FkKCk7XG4gICAgfVxuXG4gICAgaWYobmFtZS5sZW5ndGggPiBBVk1Db25zdGFudHMuQVNTRVROQU1FTEVOKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciAtIEFWTUFQSS5idWlsZENyZWF0ZU5GVEFzc2V0VHg6IE5hbWVzIG1heSBub3QgZXhjZWVkIGxlbmd0aCBvZiBcIiArIEFWTUNvbnN0YW50cy5BU1NFVE5BTUVMRU4pO1xuICAgIH1cbiAgICBpZihzeW1ib2wubGVuZ3RoID4gQVZNQ29uc3RhbnRzLlNZTUJPTE1BWExFTil7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciAtIEFWTUFQSS5idWlsZENyZWF0ZU5GVEFzc2V0VHg6IFN5bWJvbHMgbWF5IG5vdCBleGNlZWQgbGVuZ3RoIG9mIFwiICsgQVZNQ29uc3RhbnRzLlNZTUJPTE1BWExFTik7XG4gICAgfVxuICAgIGxldCBhdmF4QXNzZXRJRDpCdWZmZXIgPSBhd2FpdCB0aGlzLmdldEFWQVhBc3NldElEKCk7XG4gICAgY29uc3QgYnVpbHRVbnNpZ25lZFR4OlVuc2lnbmVkVHggPSB1dHhvc2V0LmJ1aWxkQ3JlYXRlTkZUQXNzZXRUeChcbiAgICAgICAgdGhpcy5jb3JlLmdldE5ldHdvcmtJRCgpLCBiaW50b29scy5jYjU4RGVjb2RlKHRoaXMuYmxvY2tjaGFpbklEKSwgYXZheEFzc2V0SUQsXG4gICAgICAgIGZlZSwgZmVlQWRkcnMsIG1pbnRlclNldHMsIG5hbWUsIHN5bWJvbCwgbWVtbywgYXNPZiwgbG9ja3RpbWVcbiAgICApO1xuICAgIGlmKCEgYXdhaXQgdGhpcy5jaGVja0dvb3NlRWdnKGJ1aWx0VW5zaWduZWRUeCkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgR29vc2UgRWdnIENoZWNrXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHRVbnNpZ25lZFR4O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb24uIEZvciBtb3JlIGdyYW51bGFyIGNvbnRyb2wsIHlvdSBtYXkgY3JlYXRlIHlvdXIgb3duXG4gICAgKiBbW1Vuc2lnbmVkVHhdXSBtYW51YWxseSAod2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMsIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zLCBhbmQgW1tUcmFuc2Zlck9wZXJhdGlvbl1dcykuXG4gICAgKiBcbiAgICAqIEBwYXJhbSB1dHhvc2V0ICBBIHNldCBvZiBVVFhPcyB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBidWlsdCBvblxuICAgICogQHBhcmFtIHV0eG9pZCBBIGJhc2U1OCB1dHhvSUQgb3IgYW4gYXJyYXkgb2YgYmFzZTU4IHV0eG9JRHMgZm9yIHRoZSBuZnQgbWludCBvdXRwdXQgdGhpcyB0cmFuc2FjdGlvbiBpcyBzZW5kaW5nXG4gICAgKiBAcGFyYW0gdG9BZGRyZXNzZXMgVGhlIGFkZHJlc3NlcyB0byBzZW5kIHRoZSBuZnQgb3V0cHV0XG4gICAgKiBAcGFyYW0gZnJvbUFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIGJlaW5nIHVzZWQgdG8gc2VuZCB0aGUgTkZUIGZyb20gdGhlIHV0eG9JRCBwcm92aWRlZFxuICAgICogQHBhcmFtIGZlZSBUaGUgYW1vdW50IG9mIGZlZXMgYmVpbmcgcGFpZCBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgICogQHBhcmFtIGZlZUFkZHJlc3NlcyBUaGUgYWRkcmVzc2VzIHRoYXQgaGF2ZSB0aGUgQVZBWCBmdW5kcyB0byBwYXkgZm9yIGZlZXMgb2YgdGhlIFVUWE9cbiAgICAqIEBwYXJhbSBncm91cElEIE9wdGlvbmFsLiBUaGUgZ3JvdXAgdGhpcyBORlQgaXMgaXNzdWVkIHRvLlxuICAgICogQHBhcmFtIHBheWxvYWQgT3B0aW9uYWwuIERhdGEgZm9yIE5GVCBQYXlsb2FkIGFzIGVpdGhlciBhIFtbUGF5bG9hZEJhc2VdXSBvciBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbCBjb250YWlucyBhcmJpdHJhcnkgYnl0ZXMsIHVwIHRvIDI1NiBieXRlc1xuICAgICogQHBhcmFtIGFzT2YgT3B0aW9uYWwuIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAqIEBwYXJhbSBsb2NrdGltZSBPcHRpb25hbC4gVGhlIGxvY2t0aW1lIGZpZWxkIGNyZWF0ZWQgaW4gdGhlIHJlc3VsdGluZyBtaW50IG91dHB1dFxuICAgICogQHBhcmFtIHRocmVzaG9sZCBPcHRpb25hbC4gVGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIHNwZW5kIHRoZSBmdW5kcyBpbiB0aGUgcmVzdWx0YW50IFVUWE9cbiAgICAqIFxuICAgICogXG4gICAgKiBAcmV0dXJucyBBbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiAoW1tVbnNpZ25lZFR4XV0pIHdoaWNoIGNvbnRhaW5zIGFuIFtbT3BlcmF0aW9uVHhdXS5cbiAgICAqIFxuICAgICovXG4gIGJ1aWxkQ3JlYXRlTkZUTWludFR4ID0gYXN5bmMgKFxuICAgICAgdXR4b3NldDpVVFhPU2V0LCB1dHhvaWQ6c3RyaW5nfEFycmF5PHN0cmluZz4sIHRvQWRkcmVzc2VzOkFycmF5PHN0cmluZz58QXJyYXk8QnVmZmVyPiwgXG4gICAgICBmcm9tQWRkcmVzc2VzOkFycmF5PHN0cmluZz58QXJyYXk8QnVmZmVyPiwgZmVlOkJOLFxuICAgICAgZmVlQWRkcmVzc2VzOkFycmF5PHN0cmluZz58QXJyYXk8QnVmZmVyPiwgZ3JvdXBJRDpudW1iZXIgPSAwLCBwYXlsb2FkOlBheWxvYWRCYXNlfEJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICBtZW1vOlBheWxvYWRCYXNlfEJ1ZmZlciA9IHVuZGVmaW5lZCwgYXNPZjpCTiA9IFVuaXhOb3coKSwgbG9ja3RpbWU6Qk4gPSBuZXcgQk4oMCksIHRocmVzaG9sZDpudW1iZXIgPSAxXG4gICk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICBsZXQgdG86QXJyYXk8QnVmZmVyPiA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KHRvQWRkcmVzc2VzLCBcImJ1aWxkQ3JlYXRlTkZUTWludFR4XCIpLm1hcChhID0+IGJpbnRvb2xzLnN0cmluZ1RvQWRkcmVzcyhhKSk7XG4gICAgICBsZXQgZnJvbTpBcnJheTxCdWZmZXI+ID0gdGhpcy5fY2xlYW5BZGRyZXNzQXJyYXkoZnJvbUFkZHJlc3NlcywgXCJidWlsZENyZWF0ZU5GVE1pbnRUeFwiKS5tYXAoYSA9PiBiaW50b29scy5zdHJpbmdUb0FkZHJlc3MoYSkpO1xuICAgICAgbGV0IGZlZUFkZHJzOkFycmF5PEJ1ZmZlcj4gPSB0aGlzLl9jbGVhbkFkZHJlc3NBcnJheShmZWVBZGRyZXNzZXMsIFwiYnVpbGRDcmVhdGVORlRNaW50VHhcIikubWFwKGEgPT4gYmludG9vbHMuc3RyaW5nVG9BZGRyZXNzKGEpKTtcbiAgICAgIFxuICAgICAgaWYoIG1lbW8gaW5zdGFuY2VvZiBQYXlsb2FkQmFzZSkge1xuICAgICAgICBtZW1vID0gbWVtby5nZXRQYXlsb2FkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKHBheWxvYWQgaW5zdGFuY2VvZiBQYXlsb2FkQmFzZSl7XG4gICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmdldFBheWxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYodHlwZW9mIHV0eG9pZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB1dHhvaWQgPSBbdXR4b2lkXTtcbiAgICAgIH1cblxuICAgICAgbGV0IGF2YXhBc3NldElEOkJ1ZmZlciA9IGF3YWl0IHRoaXMuZ2V0QVZBWEFzc2V0SUQoKTtcblxuICAgICAgY29uc3QgYnVpbHRVbnNpZ25lZFR4OlVuc2lnbmVkVHggPSB1dHhvc2V0LmJ1aWxkQ3JlYXRlTkZUTWludFR4KFxuICAgICAgICAgIHRoaXMuY29yZS5nZXROZXR3b3JrSUQoKSxcbiAgICAgICAgICBiaW50b29scy5jYjU4RGVjb2RlKHRoaXMuYmxvY2tjaGFpbklEKSxcbiAgICAgICAgICBhdmF4QXNzZXRJRCxcbiAgICAgICAgICBmZWUsXG4gICAgICAgICAgZmVlQWRkcnMsXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB1dHhvaWQsXG4gICAgICAgICAgZ3JvdXBJRCxcbiAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgIG1lbW8sIFxuICAgICAgICAgIGFzT2YsXG4gICAgICAgICAgbG9ja3RpbWUsXG4gICAgICAgICAgdGhyZXNob2xkXG4gICAgICApO1xuICAgICAgaWYoISBhd2FpdCB0aGlzLmNoZWNrR29vc2VFZ2coYnVpbHRVbnNpZ25lZFR4KSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgR29vc2UgRWdnIENoZWNrXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWx0VW5zaWduZWRUeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb24gYW5kIHNpZ25zIGl0LCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyBbW1R4XV0uXG4gICAgKlxuICAgICogQHBhcmFtIHV0eCBUaGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gb2YgdHlwZSBbW1Vuc2lnbmVkVHhdXVxuICAgICpcbiAgICAqIEByZXR1cm5zIEEgc2lnbmVkIHRyYW5zYWN0aW9uIG9mIHR5cGUgW1tUeF1dXG4gICAgKi9cbiAgc2lnblR4ID0gKHV0eDpVbnNpZ25lZFR4KTpUeCA9PiB0aGlzLmtleWNoYWluLnNpZ25UeCh1dHgpO1xuXG4gIC8qKlxuICAgICAqIENhbGxzIHRoZSBub2RlJ3MgaXNzdWVUeCBtZXRob2QgZnJvbSB0aGUgQVBJIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdHJhbnNhY3Rpb24gSUQgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHggQSBzdHJpbmcsIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LCBvciBbW1R4XV0gcmVwcmVzZW50aW5nIGEgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZTxzdHJpbmc+IHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb24gSUQgb2YgdGhlIHBvc3RlZCB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgaXNzdWVUeCA9IGFzeW5jICh0eDpzdHJpbmcgfCBCdWZmZXIgfCBUeCk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBsZXQgVHJhbnNhY3Rpb24gPSAnJztcbiAgICBpZiAodHlwZW9mIHR4ID09PSAnc3RyaW5nJykge1xuICAgICAgVHJhbnNhY3Rpb24gPSB0eDtcbiAgICB9IGVsc2UgaWYgKHR4IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICBjb25zdCB0eG9iajpUeCA9IG5ldyBUeCgpO1xuICAgICAgdHhvYmouZnJvbUJ1ZmZlcih0eCk7XG4gICAgICBUcmFuc2FjdGlvbiA9IHR4b2JqLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIGlmICh0eCBpbnN0YW5jZW9mIFR4KSB7XG4gICAgICBUcmFuc2FjdGlvbiA9IHR4LnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gYXZtLmlzc3VlVHg6IHByb3ZpZGVkIHR4IGlzIG5vdCBleHBlY3RlZCB0eXBlIG9mIHN0cmluZywgQnVmZmVyLCBvciBUeCcpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgdHg6IFRyYW5zYWN0aW9uLnRvU3RyaW5nKCksXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uaXNzdWVUeCcsIHBhcmFtcykudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudHhJRCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogU2VuZHMgYW4gYW1vdW50IG9mIGFzc2V0SUQgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzIGZyb20gYSBsaXN0IG9mIG93bmVkIG9mIGFkZHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VybmFtZSBUaGUgdXNlciB0aGF0IG93bnMgdGhlIHByaXZhdGUga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhlIGBmcm9tYCBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHVubG9ja2luZyB0aGUgdXNlclxuICAgICAqIEBwYXJhbSBhc3NldElEIFRoZSBhc3NldElEIG9mIHRoZSBhc3NldCB0byBzZW5kXG4gICAgICogQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBiZSBzZW50XG4gICAgICogQHBhcmFtIHRvIFRoZSBhZGRyZXNzIG9mIHRoZSByZWNpcGllbnRcbiAgICAgKiBAcGFyYW0gZnJvbSBBbiBhcnJheSBvZiBhZGRyZXNzZXMgbWFuYWdlZCBieSB0aGUgbm9kZSdzIGtleXN0b3JlIGZvciB0aGlzIGJsb2NrY2hhaW4gd2hpY2ggd2lsbCBmdW5kIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgZm9yIHRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0cmFuc2FjdGlvbidzIElELlxuICAgICAqL1xuICBzZW5kID0gYXN5bmMgKHVzZXJuYW1lOnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCBhc3NldElEOnN0cmluZyB8IEJ1ZmZlciwgYW1vdW50Om51bWJlciB8IEJOLCB0bzpzdHJpbmcsIGZyb206QXJyYXk8c3RyaW5nPiB8IEFycmF5PEJ1ZmZlcj4pOlByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgbGV0IGFzc2V0OnN0cmluZztcbiAgICBsZXQgYW1udDpCTjtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5wYXJzZUFkZHJlc3ModG8pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgLSBBVk1BUEkuc2VuOiBJbnZhbGlkIGFkZHJlc3MgZm9ybWF0ICR7dG99YCk7XG4gICAgfVxuXG4gICAgZnJvbSA9IHRoaXMuX2NsZWFuQWRkcmVzc0FycmF5KGZyb20sICdzZW5kJyk7XG5cbiAgICBpZiAodHlwZW9mIGFzc2V0SUQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBhc3NldCA9IGJpbnRvb2xzLmNiNThFbmNvZGUoYXNzZXRJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2V0ID0gYXNzZXRJRDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInKSB7XG4gICAgICBhbW50ID0gbmV3IEJOKGFtb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFtbnQgPSBhbW91bnQ7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHtcbiAgICAgIHVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQsXG4gICAgICBhc3NldElEOiBhc3NldCxcbiAgICAgIGFtb3VudDogYW1udC50b1N0cmluZygxMCksXG4gICAgICB0byxcbiAgICAgIGZyb20sXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uc2VuZCcsIHBhcmFtcykudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudHhJRCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogR2l2ZW4gYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgVmlydHVhbCBNYWNoaW5l4oCZcyBnZW5lc2lzIHN0YXRlLCBjcmVhdGUgdGhlIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgdGhhdCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBnZW5lc2lzRGF0YSBUaGUgYmxvY2tjaGFpbidzIGdlbmVzaXMgZGF0YSBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugb2YgYSBzdHJpbmcgb2YgYnl0ZXNcbiAgICAgKi9cbiAgYnVpbGRHZW5lc2lzID0gYXN5bmMgKGdlbmVzaXNEYXRhOm9iamVjdCk6UHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCBwYXJhbXM6YW55ID0ge1xuICAgICAgZ2VuZXNpc0RhdGEsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdhdm0uYnVpbGRHZW5lc2lzJywgcGFyYW1zKS50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiB7XG4gICAgICBjb25zdCByID0gcmVzcG9uc2UuZGF0YS5yZXN1bHQuYnl0ZXM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gIHByb3RlY3RlZCBfY2xlYW5BZGRyZXNzQXJyYXkoYWRkcmVzc2VzOkFycmF5PHN0cmluZz4gfCBBcnJheTxCdWZmZXI+LCBjYWxsZXI6c3RyaW5nKTpBcnJheTxzdHJpbmc+IHtcbiAgICBjb25zdCBhZGRyczpBcnJheTxzdHJpbmc+ID0gW107XG4gICAgY29uc3QgY2hhaW5pZDpzdHJpbmcgPSB0aGlzLmdldEJsb2NrY2hhaW5BbGlhcygpID8gdGhpcy5nZXRCbG9ja2NoYWluQWxpYXMoKSA6IHRoaXMuZ2V0QmxvY2tjaGFpbklEKCk7XG4gICAgaWYgKGFkZHJlc3NlcyAmJiBhZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzZXNbaV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcnNlQWRkcmVzcyhhZGRyZXNzZXNbaV0gYXMgc3RyaW5nKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIC0gQVZNQVBJLiR7Y2FsbGVyfTogSW52YWxpZCBhZGRyZXNzIGZvcm1hdCAke2FkZHJlc3Nlc1tpXX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkcnMucHVzaChhZGRyZXNzZXNbaV0gYXMgc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRycy5wdXNoKGJpbnRvb2xzLmFkZHJlc3NUb1N0cmluZyh0aGlzLmNvcmUuZ2V0SFJQKCksIGNoYWluaWQsIGFkZHJlc3Nlc1tpXSBhcyBCdWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWRkcnM7XG4gIH1cblxuICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSB0aGUgW1tBdmFsYW5jaGUuYWRkQVBJXV0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvcmUgQSByZWZlcmVuY2UgdG8gdGhlIEF2YWxhbmNoZSBjbGFzc1xuICAgICAqIEBwYXJhbSBiYXNldXJsIERlZmF1bHRzIHRvIHRoZSBzdHJpbmcgXCIvZXh0L2JjL2F2bVwiIGFzIHRoZSBwYXRoIHRvIGJsb2NrY2hhaW4ncyBiYXNldXJsXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKGNvcmU6QXZhbGFuY2hlQ29yZSwgYmFzZXVybDpzdHJpbmcgPSAnL2V4dC9iYy9hdm0nLCBibG9ja2NoYWluSUQ6c3RyaW5nID0gJycpIHtcbiAgICBzdXBlcihjb3JlLCBiYXNldXJsKTtcbiAgICB0aGlzLmJsb2NrY2hhaW5JRCA9IGJsb2NrY2hhaW5JRDtcbiAgICBjb25zdCBuZXRpZDpudW1iZXIgPSBjb3JlLmdldE5ldHdvcmtJRCgpO1xuICAgIGlmIChuZXRpZCBpbiBEZWZhdWx0cy5uZXR3b3JrICYmIGJsb2NrY2hhaW5JRCBpbiBEZWZhdWx0cy5uZXR3b3JrW25ldGlkXSkge1xuICAgICAgY29uc3QgeyBhbGlhcyB9ID0gRGVmYXVsdHMubmV0d29ya1tuZXRpZF1bYmxvY2tjaGFpbklEXTtcbiAgICAgIHRoaXMua2V5Y2hhaW4gPSBuZXcgQVZNS2V5Q2hhaW4odGhpcy5jb3JlLmdldEhSUCgpLCBhbGlhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5Y2hhaW4gPSBuZXcgQVZNS2V5Q2hhaW4odGhpcy5jb3JlLmdldEhSUCgpLCBibG9ja2NoYWluSUQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBVk1BUEk7XG4iXX0=