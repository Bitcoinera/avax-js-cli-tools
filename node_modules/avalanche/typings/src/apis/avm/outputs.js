"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTTransferOutput = exports.NFTMintOutput = exports.NFTOutBase = exports.SecpOutput = exports.AmountOutput = exports.TransferableOutput = exports.Output = exports.OutputOwners = exports.SelectOutputClass = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI-Outputs
 */
const buffer_1 = require("buffer/");
const bn_js_1 = __importDefault(require("bn.js"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("./types");
const bintools = bintools_1.default.getInstance();
/**
 * Takes a buffer representing the output and returns the proper Output instance.
 *
 * @param outputid A number representing the inputID parsed prior to the bytes passed in
 *
 * @returns An instance of an [[Output]]-extended class.
 */
exports.SelectOutputClass = (outputid, ...args) => {
    if (outputid == types_1.AVMConstants.SECPOUTPUTID) {
        let secpout = new SecpOutput(...args);
        return secpout;
    }
    else if (outputid == types_1.AVMConstants.NFTMINTOUTPUTID) {
        let nftout = new NFTMintOutput(...args);
        return nftout;
    }
    else if (outputid == types_1.AVMConstants.NFTXFEROUTPUTID) {
        let nftout = new NFTTransferOutput(...args);
        return nftout;
    }
    throw new Error("Error - SelectOutputClass: unknown outputid " + outputid);
};
class OutputOwners {
    /**
       * An [[Output]] class which contains addresses, locktimes, and thresholds.
       *
       * @param addresses An array of {@link https://github.com/feross/buffer|Buffer}s representing output owner's addresses
       * @param locktime A {@link https://github.com/indutny/bn.js/|BN} representing the locktime
       * @param threshold A number representing the the threshold number of signers required to sign the transaction
       */
    constructor(addresses = undefined, locktime = undefined, threshold = undefined) {
        this.locktime = buffer_1.Buffer.alloc(8);
        this.threshold = buffer_1.Buffer.alloc(4);
        this.numaddrs = buffer_1.Buffer.alloc(4);
        this.addresses = [];
        /**
         * Returns the threshold of signers required to spend this output.
         */
        this.getThreshold = () => this.threshold.readUInt32BE(0);
        /**
           * Returns the a {@link https://github.com/indutny/bn.js/|BN} repersenting the UNIX Timestamp when the lock is made available.
           */
        this.getLocktime = () => bintools.fromBufferToBN(this.locktime);
        /**
           * Returns an array of {@link https://github.com/feross/buffer|Buffer}s for the addresses.
           */
        this.getAddresses = () => {
            const result = [];
            for (let i = 0; i < this.addresses.length; i++) {
                result.push(this.addresses[i].toBuffer());
            }
            return result;
        };
        /**
           * Returns the index of the address.
           *
           * @param address A {@link https://github.com/feross/buffer|Buffer} of the address to look up to return its index.
           *
           * @returns The index of the address.
           */
        this.getAddressIdx = (address) => {
            for (let i = 0; i < this.addresses.length; i++) {
                if (this.addresses[i].toBuffer().toString('hex') === address.toString('hex')) {
                    return i;
                }
            }
            /* istanbul ignore next */
            return -1;
        };
        /**
           * Returns the address from the index provided.
           *
           * @param idx The index of the address.
           *
           * @returns Returns the string representing the address.
           */
        this.getAddress = (idx) => {
            if (idx < this.addresses.length) {
                return this.addresses[idx].toBuffer();
            }
            throw new Error('Error - Output.getAddress: idx out of range');
        };
        /**
           * Given an array of address {@link https://github.com/feross/buffer|Buffer}s and an optional timestamp, returns true if the addresses meet the threshold required to spend the output.
           */
        this.meetsThreshold = (addresses, asOf = undefined) => {
            let now;
            if (typeof asOf === 'undefined') {
                now = types_1.UnixNow();
            }
            else {
                now = asOf;
            }
            const qualified = this.getSpenders(addresses, now);
            const threshold = this.threshold.readUInt32BE(0);
            if (qualified.length >= threshold) {
                return true;
            }
            return false;
        };
        /**
           * Given an array of addresses and an optional timestamp, select an array of address {@link https://github.com/feross/buffer|Buffer}s of qualified spenders for the output.
           */
        this.getSpenders = (addresses, asOf = undefined) => {
            const qualified = [];
            let now;
            if (typeof asOf === 'undefined') {
                now = types_1.UnixNow();
            }
            else {
                now = asOf;
            }
            const locktime = bintools.fromBufferToBN(this.locktime);
            if (now.lte(locktime)) { // not unlocked, not spendable
                return qualified;
            }
            const threshold = this.threshold.readUInt32BE(0);
            for (let i = 0; i < this.addresses.length && qualified.length < threshold; i++) {
                for (let j = 0; j < addresses.length && qualified.length < threshold; j++) {
                    if (addresses[j].toString('hex') === this.addresses[i].toBuffer().toString('hex')) {
                        qualified.push(addresses[j]);
                    }
                }
            }
            return qualified;
        };
        if (addresses) {
            const addrs = [];
            for (let i = 0; i < addresses.length; i++) {
                addrs[i] = new types_1.Address();
                addrs[i].fromBuffer(addresses[i]);
            }
            this.addresses = addrs;
            this.addresses.sort(types_1.Address.comparator());
            this.numaddrs.writeUInt32BE(this.addresses.length, 0);
            this.threshold.writeUInt32BE((threshold || 1), 0);
            if (!(locktime)) {
                /* istanbul ignore next */
                locktime = new bn_js_1.default(0);
            }
            this.locktime = bintools.fromBNToBuffer(locktime, 8);
        }
    }
    /**
       * Returns a base-58 string representing the [[Output]].
       */
    fromBuffer(bytes, offset = 0) {
        this.locktime = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        this.threshold = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.numaddrs = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const numaddrs = this.numaddrs.readUInt32BE(0);
        this.addresses = [];
        for (let i = 0; i < numaddrs; i++) {
            const addr = new types_1.Address();
            offset = addr.fromBuffer(bytes, offset);
            this.addresses.push(addr);
        }
        this.addresses.sort(types_1.Address.comparator());
        return offset;
    }
    /**
       * Returns the buffer representing the [[Output]] instance.
       */
    toBuffer() {
        this.addresses.sort(types_1.Address.comparator());
        this.numaddrs.writeUInt32BE(this.addresses.length, 0);
        let bsize = this.locktime.length + this.threshold.length + this.numaddrs.length;
        const barr = [this.locktime, this.threshold, this.numaddrs];
        for (let i = 0; i < this.addresses.length; i++) {
            const b = this.addresses[i].toBuffer();
            barr.push(b);
            bsize += b.length;
        }
        return buffer_1.Buffer.concat(barr, bsize);
    }
    /**
       * Returns a base-58 string representing the [[Output]].
       */
    toString() {
        return bintools.bufferToB58(this.toBuffer());
    }
}
exports.OutputOwners = OutputOwners;
OutputOwners.comparator = () => (a, b) => {
    const aoutid = buffer_1.Buffer.alloc(4);
    aoutid.writeUInt32BE(a.getOutputID(), 0);
    const abuff = a.toBuffer();
    const boutid = buffer_1.Buffer.alloc(4);
    boutid.writeUInt32BE(b.getOutputID(), 0);
    const bbuff = b.toBuffer();
    const asort = buffer_1.Buffer.concat([aoutid, abuff], aoutid.length + abuff.length);
    const bsort = buffer_1.Buffer.concat([boutid, bbuff], boutid.length + bbuff.length);
    return buffer_1.Buffer.compare(asort, bsort);
};
class Output extends OutputOwners {
    /**
     *
     * @param assetID An assetID which is wrapped around the Buffer of the Output
     */
    makeTransferable(assetID) {
        return new TransferableOutput(assetID, this);
    }
}
exports.Output = Output;
class TransferableOutput {
    /**
       * Class representing an [[TransferableOutput]] for a transaction.
       *
       * @param assetID A {@link https://github.com/feross/buffer|Buffer} representing the assetID of the [[Output]]
       * @param output A number representing the InputID of the [[TransferableOutput]]
       */
    constructor(assetID = undefined, output = undefined) {
        this.assetID = buffer_1.Buffer.alloc(types_1.AVMConstants.ASSETIDLEN);
        this.getAssetID = () => this.assetID;
        this.getOutput = () => this.output;
        if (typeof assetID !== 'undefined' && output instanceof Output) {
            this.assetID = assetID;
            this.output = output;
        }
    }
    fromBuffer(bytes, offset = 0) {
        this.assetID = bintools.copyFrom(bytes, offset, offset + types_1.AVMConstants.ASSETIDLEN);
        offset += types_1.AVMConstants.ASSETIDLEN;
        const outputid = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
        offset += 4;
        this.output = exports.SelectOutputClass(outputid);
        return this.output.fromBuffer(bytes, offset);
    }
    toBuffer() {
        const outbuff = this.output.toBuffer();
        const outid = buffer_1.Buffer.alloc(4);
        outid.writeUInt32BE(this.output.getOutputID(), 0);
        const barr = [this.assetID, outid, outbuff];
        return buffer_1.Buffer.concat(barr, this.assetID.length + outid.length + outbuff.length);
    }
}
exports.TransferableOutput = TransferableOutput;
/**
   * Returns a function used to sort an array of [[TransferableOutput]]s
   */
TransferableOutput.comparator = () => (a, b) => {
    const sorta = a.toBuffer();
    const sortb = b.toBuffer();
    return buffer_1.Buffer.compare(sorta, sortb);
};
/**
 * An [[Output]] class which specifies a token amount .
 */
class AmountOutput extends Output {
    /**
       * An [[AmountOutput]] class which issues a payment on an assetID.
       *
       * @param amount A {@link https://github.com/indutny/bn.js/|BN} representing the amount in the output
       * @param addresses An array of {@link https://github.com/feross/buffer|Buffer}s representing addresses
       * @param locktime A {@link https://github.com/indutny/bn.js/|BN} representing the locktime
       * @param threshold A number representing the the threshold number of signers required to sign the transaction
  
       */
    constructor(amount = undefined, addresses = undefined, locktime = undefined, threshold = undefined) {
        super(addresses, locktime, threshold);
        this.amount = buffer_1.Buffer.alloc(8);
        this.amountValue = new bn_js_1.default(0);
        /**
           * Returns the amount as a {@link https://github.com/indutny/bn.js/|BN}.
           */
        this.getAmount = () => this.amountValue.clone();
        if (amount) {
            this.amountValue = amount.clone();
            this.amount = bintools.fromBNToBuffer(amount, 8);
        }
    }
    /**
       * Popuates the instance from a {@link https://github.com/feross/buffer|Buffer} representing the [[AmountOutput]] and returns the size of the output.
       */
    fromBuffer(outbuff, offset = 0) {
        this.amount = bintools.copyFrom(outbuff, offset, offset + 8);
        this.amountValue = bintools.fromBufferToBN(this.amount);
        offset += 8;
        return super.fromBuffer(outbuff, offset);
    }
    /**
       * Returns the buffer representing the [[AmountInput]] instance.
       */
    toBuffer() {
        const superbuff = super.toBuffer();
        const bsize = this.amount.length + superbuff.length;
        this.numaddrs.writeUInt32BE(this.addresses.length, 0);
        const barr = [this.amount, superbuff];
        return buffer_1.Buffer.concat(barr, bsize);
    }
}
exports.AmountOutput = AmountOutput;
/**
 * An [[Output]] class which specifies an Output that carries an ammount for an assetID and uses secp256k1 signature scheme.
 */
class SecpOutput extends AmountOutput {
    /**
       * Returns the outputID for this output
       */
    getOutputID() {
        return types_1.AVMConstants.SECPOUTPUTID;
    }
}
exports.SecpOutput = SecpOutput;
/**
 * An [[Output]] class which specifies an NFT.
 */
class NFTOutBase extends Output {
    constructor() {
        super(...arguments);
        this.groupID = buffer_1.Buffer.alloc(4);
        /**
           * Returns the groupID as a number.
           */
        this.getGroupID = () => {
            return this.groupID.readUInt32BE(0);
        };
    }
}
exports.NFTOutBase = NFTOutBase;
/**
 * An [[Output]] class which specifies an Output that carries an NFT Mint and uses secp256k1 signature scheme.
 */
class NFTMintOutput extends NFTOutBase {
    /**
     * Returns the outputID for this output
     */
    getOutputID() {
        return types_1.AVMConstants.NFTMINTOUTPUTID;
    }
    /**
     * Popuates the instance from a {@link https://github.com/feross/buffer|Buffer} representing the [[NFTMintOutput]] and returns the size of the output.
     */
    fromBuffer(utxobuff, offset = 0) {
        this.groupID = bintools.copyFrom(utxobuff, offset, offset + 4);
        offset += 4;
        return super.fromBuffer(utxobuff, offset);
    }
    /**
     * Returns the buffer representing the [[NFTMintOutput]] instance.
     */
    toBuffer() {
        let superbuff = super.toBuffer();
        let bsize = this.groupID.length + superbuff.length;
        let barr = [this.groupID, superbuff];
        return buffer_1.Buffer.concat(barr, bsize);
    }
    /**
     * An [[Output]] class which contains an NFT mint for an assetID.
     *
     * @param groupID A number specifies the group this NFT is issued to
     * @param locktime A {@link https://github.com/indutny/bn.js/|BN} representing the locktime
     * @param threshold A number representing the the threshold number of signers required to sign the transaction
     * @param addresses An array of {@link https://github.com/feross/buffer|Buffer}s representing addresses
     */
    constructor(groupID = undefined, addresses = undefined, locktime = undefined, threshold = undefined) {
        super(addresses, locktime, threshold);
        if (typeof groupID !== 'undefined') {
            this.groupID.writeUInt32BE(groupID, 0);
        }
    }
}
exports.NFTMintOutput = NFTMintOutput;
/**
 * An [[Output]] class which specifies an Output that carries an NFT and uses secp256k1 signature scheme.
 */
class NFTTransferOutput extends NFTOutBase {
    /**
       * An [[Output]] class which contains an NFT on an assetID.
       *
       * @param groupID A number representing the amount in the output
       * @param payload A {@link https://github.com/feross/buffer|Buffer} of max length 1024
       * @param addresses An array of {@link https://github.com/feross/buffer|Buffer}s representing addresses
       * @param locktime A {@link https://github.com/indutny/bn.js/|BN} representing the locktime
       * @param threshold A number representing the the threshold number of signers required to sign the transaction
  
       */
    constructor(groupID = undefined, payload = undefined, addresses = undefined, locktime = undefined, threshold = undefined) {
        super(addresses, locktime, threshold);
        this.sizePayload = buffer_1.Buffer.alloc(4);
        /**
           * Returns the payload as a {@link https://github.com/feross/buffer|Buffer}
           */
        this.getPayload = () => bintools.copyFrom(this.payload);
        if (typeof groupID !== 'undefined' && typeof payload !== 'undefined') {
            this.groupID.writeUInt32BE(groupID, 0);
            this.sizePayload.writeUInt32BE(payload.length, 0);
            this.payload = bintools.copyFrom(payload, 0, payload.length);
        }
    }
    /**
     * Returns the outputID for this output
     */
    getOutputID() {
        return types_1.AVMConstants.NFTXFEROUTPUTID;
    }
    /**
     * Popuates the instance from a {@link https://github.com/feross/buffer|Buffer} representing the [[NFTTransferOutput]] and returns the size of the output.
     */
    fromBuffer(utxobuff, offset = 0) {
        this.groupID = bintools.copyFrom(utxobuff, offset, offset + 4);
        offset += 4;
        this.sizePayload = bintools.copyFrom(utxobuff, offset, offset + 4);
        let psize = this.sizePayload.readUInt32BE(0);
        offset += 4;
        this.payload = bintools.copyFrom(utxobuff, offset, offset + psize);
        offset = offset + psize;
        return super.fromBuffer(utxobuff, offset);
    }
    /**
     * Returns the buffer representing the [[NFTTransferOutput]] instance.
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        const bsize = this.groupID.length + this.sizePayload.length + this.payload.length + superbuff.length;
        this.sizePayload.writeUInt32BE(this.payload.length, 0);
        const barr = [this.groupID, this.sizePayload, this.payload, superbuff];
        return buffer_1.Buffer.concat(barr, bsize);
    }
}
exports.NFTTransferOutput = NFTTransferOutput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0cHV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hcGlzL2F2bS9vdXRwdXRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7R0FHRztBQUNILG9DQUFpQztBQUNqQyxrREFBdUI7QUFDdkIsb0VBQTRDO0FBQzVDLG1DQUF5RDtBQUV6RCxNQUFNLFFBQVEsR0FBRyxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRXhDOzs7Ozs7R0FNRztBQUNVLFFBQUEsaUJBQWlCLEdBQUcsQ0FBQyxRQUFlLEVBQUUsR0FBRyxJQUFlLEVBQVMsRUFBRTtJQUM1RSxJQUFHLFFBQVEsSUFBSSxvQkFBWSxDQUFDLFlBQVksRUFBQztRQUNyQyxJQUFJLE9BQU8sR0FBYyxJQUFJLFVBQVUsQ0FBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ2xELE9BQU8sT0FBTyxDQUFDO0tBQ2xCO1NBQU0sSUFBRyxRQUFRLElBQUksb0JBQVksQ0FBQyxlQUFlLEVBQUM7UUFDL0MsSUFBSSxNQUFNLEdBQWlCLElBQUksYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7UUFDdEQsT0FBTyxNQUFNLENBQUM7S0FDakI7U0FBTSxJQUFHLFFBQVEsSUFBSSxvQkFBWSxDQUFDLGVBQWUsRUFBQztRQUMvQyxJQUFJLE1BQU0sR0FBcUIsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQzlELE9BQU8sTUFBTSxDQUFDO0tBQ2pCO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyw4Q0FBOEMsR0FBRyxRQUFRLENBQUMsQ0FBQztBQUMvRSxDQUFDLENBQUE7QUFHRCxNQUFhLFlBQVk7SUFvS3ZCOzs7Ozs7U0FNSztJQUNMLFlBQVksWUFBMEIsU0FBUyxFQUFFLFdBQWMsU0FBUyxFQUFFLFlBQW1CLFNBQVM7UUExSzFGLGFBQVEsR0FBVSxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLGNB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Q04sTUFBTSxTQUFTLEdBQVUsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzFDLE1BQU0sS0FBSyxHQUFVLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDNUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkQsTUFBTSxJQUFJLEdBQWlCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDckYsT0FBTyxlQUFNLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwQyxDQUFDO0NBb0JGO0FBM0RELDhDQTJEQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEFWTUFQSS1PdXRwdXRzXG4gKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlci8nO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBCaW5Ub29scyBmcm9tICcuLi8uLi91dGlscy9iaW50b29scyc7XG5pbXBvcnQgeyBBZGRyZXNzLCBVbml4Tm93LCBBVk1Db25zdGFudHMgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgYmludG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuXG4vKipcbiAqIFRha2VzIGEgYnVmZmVyIHJlcHJlc2VudGluZyB0aGUgb3V0cHV0IGFuZCByZXR1cm5zIHRoZSBwcm9wZXIgT3V0cHV0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBvdXRwdXRpZCBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGlucHV0SUQgcGFyc2VkIHByaW9yIHRvIHRoZSBieXRlcyBwYXNzZWQgaW5cbiAqXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBhbiBbW091dHB1dF1dLWV4dGVuZGVkIGNsYXNzLlxuICovXG5leHBvcnQgY29uc3QgU2VsZWN0T3V0cHV0Q2xhc3MgPSAob3V0cHV0aWQ6bnVtYmVyLCAuLi5hcmdzOkFycmF5PGFueT4pOk91dHB1dCA9PiB7XG4gICAgaWYob3V0cHV0aWQgPT0gQVZNQ29uc3RhbnRzLlNFQ1BPVVRQVVRJRCl7XG4gICAgICAgIGxldCBzZWNwb3V0OlNlY3BPdXRwdXQgPSBuZXcgU2VjcE91dHB1dCggLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBzZWNwb3V0O1xuICAgIH0gZWxzZSBpZihvdXRwdXRpZCA9PSBBVk1Db25zdGFudHMuTkZUTUlOVE9VVFBVVElEKXtcbiAgICAgICAgbGV0IG5mdG91dDpORlRNaW50T3V0cHV0ID0gbmV3IE5GVE1pbnRPdXRwdXQoLi4uYXJncyk7XG4gICAgICAgIHJldHVybiBuZnRvdXQ7XG4gICAgfSBlbHNlIGlmKG91dHB1dGlkID09IEFWTUNvbnN0YW50cy5ORlRYRkVST1VUUFVUSUQpe1xuICAgICAgICBsZXQgbmZ0b3V0Ok5GVFRyYW5zZmVyT3V0cHV0ID0gbmV3IE5GVFRyYW5zZmVyT3V0cHV0KC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gbmZ0b3V0O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciAtIFNlbGVjdE91dHB1dENsYXNzOiB1bmtub3duIG91dHB1dGlkIFwiICsgb3V0cHV0aWQpO1xufVxuXG5cbmV4cG9ydCBjbGFzcyBPdXRwdXRPd25lcnMge1xuICAgIHByb3RlY3RlZCBsb2NrdGltZTpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgcHJvdGVjdGVkIHRocmVzaG9sZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgcHJvdGVjdGVkIG51bWFkZHJzOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICBwcm90ZWN0ZWQgYWRkcmVzc2VzOkFycmF5PEFkZHJlc3M+ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0aHJlc2hvbGQgb2Ygc2lnbmVycyByZXF1aXJlZCB0byBzcGVuZCB0aGlzIG91dHB1dC5cbiAgICAgKi9cbiAgZ2V0VGhyZXNob2xkID0gKCk6bnVtYmVyID0+IHRoaXMudGhyZXNob2xkLnJlYWRVSW50MzJCRSgwKTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59IHJlcGVyc2VudGluZyB0aGUgVU5JWCBUaW1lc3RhbXAgd2hlbiB0aGUgbG9jayBpcyBtYWRlIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgZ2V0TG9ja3RpbWUgPSAoKTpCTiA9PiBiaW50b29scy5mcm9tQnVmZmVyVG9CTih0aGlzLmxvY2t0aW1lKTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9cyBmb3IgdGhlIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgZ2V0QWRkcmVzc2VzID0gKCk6QXJyYXk8QnVmZmVyPiA9PiB7XG4gICAgY29uc3QgcmVzdWx0OkFycmF5PEJ1ZmZlcj4gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaCh0aGlzLmFkZHJlc3Nlc1tpXS50b0J1ZmZlcigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgdGhlIGFkZHJlc3MgdG8gbG9vayB1cCB0byByZXR1cm4gaXRzIGluZGV4LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBhZGRyZXNzLlxuICAgICAqL1xuICBnZXRBZGRyZXNzSWR4ID0gKGFkZHJlc3M6QnVmZmVyKTpudW1iZXIgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmFkZHJlc3Nlc1tpXS50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKSA9PT0gYWRkcmVzcy50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFkZHJlc3MgZnJvbSB0aGUgaW5kZXggcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWR4IFRoZSBpbmRleCBvZiB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGFkZHJlc3MuXG4gICAgICovXG4gIGdldEFkZHJlc3MgPSAoaWR4Om51bWJlcik6QnVmZmVyID0+IHtcbiAgICBpZiAoaWR4IDwgdGhpcy5hZGRyZXNzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRyZXNzZXNbaWR4XS50b0J1ZmZlcigpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIC0gT3V0cHV0LmdldEFkZHJlc3M6IGlkeCBvdXQgb2YgcmFuZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBhZGRyZXNzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9cyBhbmQgYW4gb3B0aW9uYWwgdGltZXN0YW1wLCByZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3NlcyBtZWV0IHRoZSB0aHJlc2hvbGQgcmVxdWlyZWQgdG8gc3BlbmQgdGhlIG91dHB1dC5cbiAgICAgKi9cbiAgbWVldHNUaHJlc2hvbGQgPSAoYWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4sIGFzT2Y6Qk4gPSB1bmRlZmluZWQpOmJvb2xlYW4gPT4ge1xuICAgIGxldCBub3c6Qk47XG4gICAgaWYgKHR5cGVvZiBhc09mID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbm93ID0gVW5peE5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3cgPSBhc09mO1xuICAgIH1cbiAgICBjb25zdCBxdWFsaWZpZWQ6QXJyYXk8QnVmZmVyPiA9IHRoaXMuZ2V0U3BlbmRlcnMoYWRkcmVzc2VzLCBub3cpO1xuICAgIGNvbnN0IHRocmVzaG9sZDpudW1iZXIgPSB0aGlzLnRocmVzaG9sZC5yZWFkVUludDMyQkUoMCk7XG4gICAgaWYgKHF1YWxpZmllZC5sZW5ndGggPj0gdGhyZXNob2xkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAgICogR2l2ZW4gYW4gYXJyYXkgb2YgYWRkcmVzc2VzIGFuZCBhbiBvcHRpb25hbCB0aW1lc3RhbXAsIHNlbGVjdCBhbiBhcnJheSBvZiBhZGRyZXNzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9cyBvZiBxdWFsaWZpZWQgc3BlbmRlcnMgZm9yIHRoZSBvdXRwdXQuXG4gICAgICovXG4gIGdldFNwZW5kZXJzID0gKGFkZHJlc3NlczpBcnJheTxCdWZmZXI+LCBhc09mOkJOID0gdW5kZWZpbmVkKTpBcnJheTxCdWZmZXI+ID0+IHtcbiAgICBjb25zdCBxdWFsaWZpZWQ6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgIGxldCBub3c6Qk47XG4gICAgaWYgKHR5cGVvZiBhc09mID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbm93ID0gVW5peE5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3cgPSBhc09mO1xuICAgIH1cbiAgICBjb25zdCBsb2NrdGltZTpCTiA9IGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMubG9ja3RpbWUpO1xuICAgIGlmIChub3cubHRlKGxvY2t0aW1lKSkgeyAvLyBub3QgdW5sb2NrZWQsIG5vdCBzcGVuZGFibGVcbiAgICAgIHJldHVybiBxdWFsaWZpZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkOm51bWJlciA9IHRoaXMudGhyZXNob2xkLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZGRyZXNzZXMubGVuZ3RoICYmIHF1YWxpZmllZC5sZW5ndGggPCB0aHJlc2hvbGQ7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhZGRyZXNzZXMubGVuZ3RoICYmIHF1YWxpZmllZC5sZW5ndGggPCB0aHJlc2hvbGQ7IGorKykge1xuICAgICAgICBpZiAoYWRkcmVzc2VzW2pdLnRvU3RyaW5nKCdoZXgnKSA9PT0gdGhpcy5hZGRyZXNzZXNbaV0udG9CdWZmZXIoKS50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgICBxdWFsaWZpZWQucHVzaChhZGRyZXNzZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1YWxpZmllZDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYmFzZS01OCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBbW091dHB1dF1dLlxuICAgICAqL1xuICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgdGhpcy5sb2NrdGltZSA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDgpO1xuICAgIG9mZnNldCArPSA4O1xuICAgIHRoaXMudGhyZXNob2xkID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGhpcy5udW1hZGRycyA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIGNvbnN0IG51bWFkZHJzOm51bWJlciA9IHRoaXMubnVtYWRkcnMucmVhZFVJbnQzMkJFKDApO1xuICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1hZGRyczsgaSsrKSB7XG4gICAgICBjb25zdCBhZGRyOkFkZHJlc3MgPSBuZXcgQWRkcmVzcygpO1xuICAgICAgb2Zmc2V0ID0gYWRkci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgdGhpcy5hZGRyZXNzZXMucHVzaChhZGRyKTtcbiAgICB9XG4gICAgdGhpcy5hZGRyZXNzZXMuc29ydChBZGRyZXNzLmNvbXBhcmF0b3IoKSk7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJ1ZmZlciByZXByZXNlbnRpbmcgdGhlIFtbT3V0cHV0XV0gaW5zdGFuY2UuXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICB0aGlzLmFkZHJlc3Nlcy5zb3J0KEFkZHJlc3MuY29tcGFyYXRvcigpKTtcbiAgICB0aGlzLm51bWFkZHJzLndyaXRlVUludDMyQkUodGhpcy5hZGRyZXNzZXMubGVuZ3RoLCAwKTtcbiAgICBsZXQgYnNpemU6bnVtYmVyID0gdGhpcy5sb2NrdGltZS5sZW5ndGggKyB0aGlzLnRocmVzaG9sZC5sZW5ndGggKyB0aGlzLm51bWFkZHJzLmxlbmd0aDtcbiAgICBjb25zdCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbdGhpcy5sb2NrdGltZSwgdGhpcy50aHJlc2hvbGQsIHRoaXMubnVtYWRkcnNdO1xuICAgIGZvciAobGV0IGk6bnVtYmVyID0gMDsgaSA8IHRoaXMuYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiOiBCdWZmZXIgPSB0aGlzLmFkZHJlc3Nlc1tpXS50b0J1ZmZlcigpO1xuICAgICAgYmFyci5wdXNoKGIpO1xuICAgICAgYnNpemUgKz0gYi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJhcnIsIGJzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSBiYXNlLTU4IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIFtbT3V0cHV0XV0uXG4gICAgICovXG4gIHRvU3RyaW5nKCk6c3RyaW5nIHtcbiAgICByZXR1cm4gYmludG9vbHMuYnVmZmVyVG9CNTgodGhpcy50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIHN0YXRpYyBjb21wYXJhdG9yID0gKCk6KGE6T3V0cHV0LCBiOk91dHB1dCkgPT4gKDF8LTF8MCkgPT4gKGE6T3V0cHV0LCBiOk91dHB1dCk6KDF8LTF8MCkgPT4ge1xuICAgIGNvbnN0IGFvdXRpZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgYW91dGlkLndyaXRlVUludDMyQkUoYS5nZXRPdXRwdXRJRCgpLCAwKTtcbiAgICBjb25zdCBhYnVmZjpCdWZmZXIgPSBhLnRvQnVmZmVyKCk7XG5cbiAgICBjb25zdCBib3V0aWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGJvdXRpZC53cml0ZVVJbnQzMkJFKGIuZ2V0T3V0cHV0SUQoKSwgMCk7XG4gICAgY29uc3QgYmJ1ZmY6QnVmZmVyID0gYi50b0J1ZmZlcigpO1xuXG4gICAgY29uc3QgYXNvcnQ6QnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYW91dGlkLCBhYnVmZl0sIGFvdXRpZC5sZW5ndGggKyBhYnVmZi5sZW5ndGgpO1xuICAgIGNvbnN0IGJzb3J0OkJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2JvdXRpZCwgYmJ1ZmZdLCBib3V0aWQubGVuZ3RoICsgYmJ1ZmYubGVuZ3RoKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbXBhcmUoYXNvcnQsIGJzb3J0KSBhcyAoMXwtMXwwKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBBbiBbW091dHB1dF1dIGNsYXNzIHdoaWNoIGNvbnRhaW5zIGFkZHJlc3NlcywgbG9ja3RpbWVzLCBhbmQgdGhyZXNob2xkcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgQW4gYXJyYXkgb2Yge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1zIHJlcHJlc2VudGluZyBvdXRwdXQgb3duZXIncyBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0gbG9ja3RpbWUgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSByZXByZXNlbnRpbmcgdGhlIGxvY2t0aW1lXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHRoZSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNpZ25lcnMgcmVxdWlyZWQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4gPSB1bmRlZmluZWQsIGxvY2t0aW1lOkJOID0gdW5kZWZpbmVkLCB0aHJlc2hvbGQ6bnVtYmVyID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFkZHJlc3Nlcykge1xuICAgICAgY29uc3QgYWRkcnM6QXJyYXk8QWRkcmVzcz4gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFkZHJzW2ldID0gbmV3IEFkZHJlc3MoKTtcbiAgICAgICAgYWRkcnNbaV0uZnJvbUJ1ZmZlcihhZGRyZXNzZXNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRyZXNzZXMgPSBhZGRycztcbiAgICAgIHRoaXMuYWRkcmVzc2VzLnNvcnQoQWRkcmVzcy5jb21wYXJhdG9yKCkpO1xuICAgICAgdGhpcy5udW1hZGRycy53cml0ZVVJbnQzMkJFKHRoaXMuYWRkcmVzc2VzLmxlbmd0aCwgMCk7XG4gICAgICB0aGlzLnRocmVzaG9sZC53cml0ZVVJbnQzMkJFKCh0aHJlc2hvbGQgfHwgMSksIDApO1xuICAgICAgaWYgKCEobG9ja3RpbWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGxvY2t0aW1lID0gbmV3IEJOKDApO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NrdGltZSA9IGJpbnRvb2xzLmZyb21CTlRvQnVmZmVyKGxvY2t0aW1lLCA4KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE91dHB1dCBleHRlbmRzIE91dHB1dE93bmVycyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3V0cHV0SUQgZm9yIHRoZSBvdXRwdXQgd2hpY2ggdGVsbHMgcGFyc2VycyB3aGF0IHR5cGUgaXQgaXNcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZXRPdXRwdXRJRCgpOm51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBhc3NldElEIEFuIGFzc2V0SUQgd2hpY2ggaXMgd3JhcHBlZCBhcm91bmQgdGhlIEJ1ZmZlciBvZiB0aGUgT3V0cHV0XG4gICAgICovXG4gICAgbWFrZVRyYW5zZmVyYWJsZShhc3NldElEOkJ1ZmZlcik6VHJhbnNmZXJhYmxlT3V0cHV0IHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2ZlcmFibGVPdXRwdXQoYXNzZXRJRCwgdGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJhYmxlT3V0cHV0IHtcbiAgcHJvdGVjdGVkIGFzc2V0SUQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKEFWTUNvbnN0YW50cy5BU1NFVElETEVOKTtcblxuICBwcm90ZWN0ZWQgb3V0cHV0Ok91dHB1dDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdXNlZCB0byBzb3J0IGFuIGFycmF5IG9mIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICovXG4gIHN0YXRpYyBjb21wYXJhdG9yID0gKCk6KGE6VHJhbnNmZXJhYmxlT3V0cHV0LCBiOlRyYW5zZmVyYWJsZU91dHB1dCkgPT4gKDF8LTF8MCkgPT4gKGE6VHJhbnNmZXJhYmxlT3V0cHV0LCBiOlRyYW5zZmVyYWJsZU91dHB1dCk6KDF8LTF8MCkgPT4ge1xuICAgIGNvbnN0IHNvcnRhID0gYS50b0J1ZmZlcigpO1xuICAgIGNvbnN0IHNvcnRiID0gYi50b0J1ZmZlcigpO1xuICAgIHJldHVybiBCdWZmZXIuY29tcGFyZShzb3J0YSwgc29ydGIpIGFzICgxfC0xfDApO1xuICB9O1xuXG4gIGdldEFzc2V0SUQgPSAoKTpCdWZmZXIgPT4gdGhpcy5hc3NldElEO1xuXG4gIGdldE91dHB1dCA9ICgpOk91dHB1dCA9PiB0aGlzLm91dHB1dDtcblxuICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgdGhpcy5hc3NldElEID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgQVZNQ29uc3RhbnRzLkFTU0VUSURMRU4pO1xuICAgIG9mZnNldCArPSBBVk1Db25zdGFudHMuQVNTRVRJRExFTjtcbiAgICBjb25zdCBvdXRwdXRpZDpudW1iZXIgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KS5yZWFkVUludDMyQkUoMCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGhpcy5vdXRwdXQgPSBTZWxlY3RPdXRwdXRDbGFzcyhvdXRwdXRpZCk7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0LmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gIH1cblxuICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgY29uc3Qgb3V0YnVmZjpCdWZmZXIgPSB0aGlzLm91dHB1dC50b0J1ZmZlcigpO1xuICAgIGNvbnN0IG91dGlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICBvdXRpZC53cml0ZVVJbnQzMkJFKHRoaXMub3V0cHV0LmdldE91dHB1dElEKCksIDApO1xuICAgIGNvbnN0IGJhcnI6QXJyYXk8QnVmZmVyPiA9IFt0aGlzLmFzc2V0SUQsIG91dGlkLCBvdXRidWZmXTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChiYXJyLCB0aGlzLmFzc2V0SUQubGVuZ3RoICsgb3V0aWQubGVuZ3RoICsgb3V0YnVmZi5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV0gZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJRCBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgYXNzZXRJRCBvZiB0aGUgW1tPdXRwdXRdXVxuICAgICAqIEBwYXJhbSBvdXRwdXQgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBJbnB1dElEIG9mIHRoZSBbW1RyYW5zZmVyYWJsZU91dHB1dF1dXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKGFzc2V0SUQ6QnVmZmVyID0gdW5kZWZpbmVkLCBvdXRwdXQ6T3V0cHV0ID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBhc3NldElEICE9PSAndW5kZWZpbmVkJyAmJiBvdXRwdXQgaW5zdGFuY2VvZiBPdXRwdXQpIHtcbiAgICAgIHRoaXMuYXNzZXRJRCA9IGFzc2V0SUQ7XG4gICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBbW091dHB1dF1dIGNsYXNzIHdoaWNoIHNwZWNpZmllcyBhIHRva2VuIGFtb3VudCAuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBbW91bnRPdXRwdXQgZXh0ZW5kcyBPdXRwdXQge1xuICBwcm90ZWN0ZWQgYW1vdW50OkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcblxuICBwcm90ZWN0ZWQgYW1vdW50VmFsdWU6Qk4gPSBuZXcgQk4oMCk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0uXG4gICAgICovXG4gIGdldEFtb3VudCA9ICgpOkJOID0+IHRoaXMuYW1vdW50VmFsdWUuY2xvbmUoKTtcblxuICAvKipcbiAgICAgKiBQb3B1YXRlcyB0aGUgaW5zdGFuY2UgZnJvbSBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgW1tBbW91bnRPdXRwdXRdXSBhbmQgcmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgb3V0cHV0LlxuICAgICAqL1xuICBmcm9tQnVmZmVyKG91dGJ1ZmY6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0aGlzLmFtb3VudCA9IGJpbnRvb2xzLmNvcHlGcm9tKG91dGJ1ZmYsIG9mZnNldCwgb2Zmc2V0ICsgOCk7XG4gICAgdGhpcy5hbW91bnRWYWx1ZSA9IGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMuYW1vdW50KTtcbiAgICBvZmZzZXQgKz0gODtcbiAgICByZXR1cm4gc3VwZXIuZnJvbUJ1ZmZlcihvdXRidWZmLCBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYnVmZmVyIHJlcHJlc2VudGluZyB0aGUgW1tBbW91bnRJbnB1dF1dIGluc3RhbmNlLlxuICAgICAqL1xuICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgY29uc3Qgc3VwZXJidWZmOkJ1ZmZlciA9IHN1cGVyLnRvQnVmZmVyKCk7XG4gICAgY29uc3QgYnNpemU6bnVtYmVyID0gdGhpcy5hbW91bnQubGVuZ3RoICsgc3VwZXJidWZmLmxlbmd0aDtcbiAgICB0aGlzLm51bWFkZHJzLndyaXRlVUludDMyQkUodGhpcy5hZGRyZXNzZXMubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbdGhpcy5hbW91bnQsIHN1cGVyYnVmZl07XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmFyciwgYnNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQW4gW1tBbW91bnRPdXRwdXRdXSBjbGFzcyB3aGljaCBpc3N1ZXMgYSBwYXltZW50IG9uIGFuIGFzc2V0SUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gcmVwcmVzZW50aW5nIHRoZSBhbW91bnQgaW4gdGhlIG91dHB1dFxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgQW4gYXJyYXkgb2Yge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1zIHJlcHJlc2VudGluZyBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0gbG9ja3RpbWUgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSByZXByZXNlbnRpbmcgdGhlIGxvY2t0aW1lXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHRoZSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNpZ25lcnMgcmVxdWlyZWQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cblxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihhbW91bnQ6Qk4gPSB1bmRlZmluZWQsIGFkZHJlc3NlczpBcnJheTxCdWZmZXI+ID0gdW5kZWZpbmVkLCBsb2NrdGltZTpCTiA9IHVuZGVmaW5lZCwgdGhyZXNob2xkOm51bWJlciA9IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKGFkZHJlc3NlcywgbG9ja3RpbWUsIHRocmVzaG9sZCk7XG4gICAgaWYgKGFtb3VudCkge1xuICAgICAgdGhpcy5hbW91bnRWYWx1ZSA9IGFtb3VudC5jbG9uZSgpO1xuICAgICAgdGhpcy5hbW91bnQgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcihhbW91bnQsIDgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIFtbT3V0cHV0XV0gY2xhc3Mgd2hpY2ggc3BlY2lmaWVzIGFuIE91dHB1dCB0aGF0IGNhcnJpZXMgYW4gYW1tb3VudCBmb3IgYW4gYXNzZXRJRCBhbmQgdXNlcyBzZWNwMjU2azEgc2lnbmF0dXJlIHNjaGVtZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlY3BPdXRwdXQgZXh0ZW5kcyBBbW91bnRPdXRwdXQge1xuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdXRwdXRJRCBmb3IgdGhpcyBvdXRwdXRcbiAgICAgKi9cbiAgZ2V0T3V0cHV0SUQoKTpudW1iZXIge1xuICAgIHJldHVybiBBVk1Db25zdGFudHMuU0VDUE9VVFBVVElEO1xuICB9XG59XG5cbi8qKlxuICogQW4gW1tPdXRwdXRdXSBjbGFzcyB3aGljaCBzcGVjaWZpZXMgYW4gTkZULlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTkZUT3V0QmFzZSBleHRlbmRzIE91dHB1dCB7XG4gICAgcHJvdGVjdGVkIGdyb3VwSUQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyb3VwSUQgYXMgYSBudW1iZXIuXG4gICAgICovXG4gICAgZ2V0R3JvdXBJRCA9ICgpOm51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwSUQucmVhZFVJbnQzMkJFKDApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbiBbW091dHB1dF1dIGNsYXNzIHdoaWNoIHNwZWNpZmllcyBhbiBPdXRwdXQgdGhhdCBjYXJyaWVzIGFuIE5GVCBNaW50IGFuZCB1c2VzIHNlY3AyNTZrMSBzaWduYXR1cmUgc2NoZW1lLlxuICovXG5leHBvcnQgY2xhc3MgTkZUTWludE91dHB1dCBleHRlbmRzIE5GVE91dEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG91dHB1dElEIGZvciB0aGlzIG91dHB1dFxuICAgICAqL1xuICAgIGdldE91dHB1dElEKCk6bnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIEFWTUNvbnN0YW50cy5ORlRNSU5UT1VUUFVUSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9wdWF0ZXMgdGhlIGluc3RhbmNlIGZyb20gYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIFtbTkZUTWludE91dHB1dF1dIGFuZCByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgZnJvbUJ1ZmZlcih1dHhvYnVmZjpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICB0aGlzLmdyb3VwSUQgPSBiaW50b29scy5jb3B5RnJvbSh1dHhvYnVmZiwgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiBzdXBlci5mcm9tQnVmZmVyKHV0eG9idWZmLCBvZmZzZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJ1ZmZlciByZXByZXNlbnRpbmcgdGhlIFtbTkZUTWludE91dHB1dF1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgbGV0IHN1cGVyYnVmZjpCdWZmZXIgPSBzdXBlci50b0J1ZmZlcigpO1xuICAgICAgICBsZXQgYnNpemU6bnVtYmVyID0gdGhpcy5ncm91cElELmxlbmd0aCArIHN1cGVyYnVmZi5sZW5ndGg7XG4gICAgICAgIGxldCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbdGhpcy5ncm91cElELCBzdXBlcmJ1ZmZdO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChiYXJyLGJzaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBbW091dHB1dF1dIGNsYXNzIHdoaWNoIGNvbnRhaW5zIGFuIE5GVCBtaW50IGZvciBhbiBhc3NldElELlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBncm91cElEIEEgbnVtYmVyIHNwZWNpZmllcyB0aGUgZ3JvdXAgdGhpcyBORlQgaXMgaXNzdWVkIHRvXG4gICAgICogQHBhcmFtIGxvY2t0aW1lIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gcmVwcmVzZW50aW5nIHRoZSBsb2NrdGltZVxuICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSB0aGUgdGhyZXNob2xkIG51bWJlciBvZiBzaWduZXJzIHJlcXVpcmVkIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyBBbiBhcnJheSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfXMgcmVwcmVzZW50aW5nIGFkZHJlc3Nlc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGdyb3VwSUQ6bnVtYmVyID0gdW5kZWZpbmVkLCBhZGRyZXNzZXM6QXJyYXk8QnVmZmVyPiA9IHVuZGVmaW5lZCwgbG9ja3RpbWU6Qk4gPSB1bmRlZmluZWQsIHRocmVzaG9sZDpudW1iZXIgPSB1bmRlZmluZWQpe1xuICAgICAgICBzdXBlcihhZGRyZXNzZXMsIGxvY2t0aW1lLCB0aHJlc2hvbGQpO1xuICAgICAgICBpZih0eXBlb2YgZ3JvdXBJRCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBJRC53cml0ZVVJbnQzMkJFKGdyb3VwSUQsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIFtbT3V0cHV0XV0gY2xhc3Mgd2hpY2ggc3BlY2lmaWVzIGFuIE91dHB1dCB0aGF0IGNhcnJpZXMgYW4gTkZUIGFuZCB1c2VzIHNlY3AyNTZrMSBzaWduYXR1cmUgc2NoZW1lLlxuICovXG5leHBvcnQgY2xhc3MgTkZUVHJhbnNmZXJPdXRwdXQgZXh0ZW5kcyBORlRPdXRCYXNlIHtcbiAgICBwcm90ZWN0ZWQgc2l6ZVBheWxvYWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIHByb3RlY3RlZCBwYXlsb2FkOkJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG91dHB1dElEIGZvciB0aGlzIG91dHB1dFxuICAgICAqL1xuICAgIGdldE91dHB1dElEKCk6bnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIEFWTUNvbnN0YW50cy5ORlRYRkVST1VUUFVUSUQ7XG4gICAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBheWxvYWQgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgICAqL1xuICBnZXRQYXlsb2FkID0gKCk6QnVmZmVyID0+IGJpbnRvb2xzLmNvcHlGcm9tKHRoaXMucGF5bG9hZCk7XG5cbiAgICAvKipcbiAgICAgKiBQb3B1YXRlcyB0aGUgaW5zdGFuY2UgZnJvbSBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgW1tORlRUcmFuc2Zlck91dHB1dF1dIGFuZCByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgZnJvbUJ1ZmZlcih1dHhvYnVmZjpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICB0aGlzLmdyb3VwSUQgPSBiaW50b29scy5jb3B5RnJvbSh1dHhvYnVmZiwgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHRoaXMuc2l6ZVBheWxvYWQgPSBiaW50b29scy5jb3B5RnJvbSh1dHhvYnVmZiwgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICAgICAgbGV0IHBzaXplOm51bWJlciA9IHRoaXMuc2l6ZVBheWxvYWQucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gYmludG9vbHMuY29weUZyb20odXR4b2J1ZmYsIG9mZnNldCwgb2Zmc2V0ICsgcHNpemUpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBwc2l6ZTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmZyb21CdWZmZXIodXR4b2J1ZmYsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYnVmZmVyIHJlcHJlc2VudGluZyB0aGUgW1tORlRUcmFuc2Zlck91dHB1dF1dIGluc3RhbmNlLlxuICAgICAqL1xuICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgY29uc3Qgc3VwZXJidWZmOkJ1ZmZlciA9IHN1cGVyLnRvQnVmZmVyKCk7XG4gICAgY29uc3QgYnNpemU6bnVtYmVyID0gdGhpcy5ncm91cElELmxlbmd0aCArIHRoaXMuc2l6ZVBheWxvYWQubGVuZ3RoICsgdGhpcy5wYXlsb2FkLmxlbmd0aCArIHN1cGVyYnVmZi5sZW5ndGg7XG4gICAgdGhpcy5zaXplUGF5bG9hZC53cml0ZVVJbnQzMkJFKHRoaXMucGF5bG9hZC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IGJhcnI6QXJyYXk8QnVmZmVyPiA9IFt0aGlzLmdyb3VwSUQsIHRoaXMuc2l6ZVBheWxvYWQsIHRoaXMucGF5bG9hZCwgc3VwZXJidWZmXTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChiYXJyLCBic2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBBbiBbW091dHB1dF1dIGNsYXNzIHdoaWNoIGNvbnRhaW5zIGFuIE5GVCBvbiBhbiBhc3NldElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyb3VwSUQgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBhbW91bnQgaW4gdGhlIG91dHB1dFxuICAgICAqIEBwYXJhbSBwYXlsb2FkIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgbWF4IGxlbmd0aCAxMDI0IFxuICAgICAqIEBwYXJhbSBhZGRyZXNzZXMgQW4gYXJyYXkgb2Yge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1zIHJlcHJlc2VudGluZyBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0gbG9ja3RpbWUgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSByZXByZXNlbnRpbmcgdGhlIGxvY2t0aW1lXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHRoZSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNpZ25lcnMgcmVxdWlyZWQgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cblxuICAgICAqL1xuICBjb25zdHJ1Y3Rvcihncm91cElEOm51bWJlciA9IHVuZGVmaW5lZCwgcGF5bG9hZDpCdWZmZXIgPSB1bmRlZmluZWQsIGFkZHJlc3NlczpBcnJheTxCdWZmZXI+ID0gdW5kZWZpbmVkLCBsb2NrdGltZTpCTiA9IHVuZGVmaW5lZCwgdGhyZXNob2xkOm51bWJlciA9IHVuZGVmaW5lZCwgKSB7XG4gICAgc3VwZXIoYWRkcmVzc2VzLCBsb2NrdGltZSwgdGhyZXNob2xkKTtcbiAgICBpZiAodHlwZW9mIGdyb3VwSUQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXlsb2FkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5ncm91cElELndyaXRlVUludDMyQkUoZ3JvdXBJRCwgMCk7XG4gICAgICB0aGlzLnNpemVQYXlsb2FkLndyaXRlVUludDMyQkUocGF5bG9hZC5sZW5ndGgsIDApO1xuICAgICAgdGhpcy5wYXlsb2FkID0gYmludG9vbHMuY29weUZyb20ocGF5bG9hZCwgMCwgcGF5bG9hZC5sZW5ndGgpO1xuICAgIH1cbiAgfVxufVxuIl19