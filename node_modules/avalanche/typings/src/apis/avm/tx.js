"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SelectTxClass = exports.Tx = exports.UnsignedTx = exports.ExportTx = exports.ImportTx = exports.OperationTx = exports.CreateAssetTx = exports.BaseTx = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI-Transactions
 */
const buffer_1 = require("buffer/");
const create_hash_1 = __importDefault(require("create-hash"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("./types");
const outputs_1 = require("./outputs");
const inputs_1 = require("./inputs");
const ops_1 = require("./ops");
const credentials_1 = require("./credentials");
const bn_js_1 = __importDefault(require("bn.js"));
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Class representing a base for all transactions.
 */
class BaseTx {
    /**
       * Class representing a BaseTx which is the foundation for all transactions.
       *
       * @param networkid Optional networkid, default 3
       * @param blockchainid Optional blockchainid, default Buffer.alloc(32, 16)
       * @param outs Optional array of the [[TransferableOutput]]s
       * @param ins Optional array of the [[TransferableInput]]s
       * @param memo Optional {@link https://github.com/feross/buffer|Buffer} for the memo field
       */
    constructor(networkid = 3, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined) {
        this.networkid = buffer_1.Buffer.alloc(4);
        this.blockchainid = buffer_1.Buffer.alloc(32);
        this.numouts = buffer_1.Buffer.alloc(4);
        this.numins = buffer_1.Buffer.alloc(4);
        this.memo = buffer_1.Buffer.alloc(4);
        /**
           * Returns the NetworkID as a number
           */
        this.getNetworkID = () => this.networkid.readUInt32BE(0);
        /**
           * Returns the Buffer representation of the BlockchainID
           */
        this.getBlockchainID = () => this.blockchainid;
        /**
           * Returns the array of [[TransferableInput]]s
           */
        this.getIns = () => this.ins;
        /**
           * Returns the array of [[TransferableOutput]]s
           */
        this.getOuts = () => this.outs;
        /**
         * Returns the {@link https://github.com/feross/buffer|Buffer} representation of the memo
         */
        this.getMemo = () => this.memo;
        this.networkid.writeUInt32BE(networkid, 0);
        this.blockchainid = blockchainid;
        if (typeof memo === "undefined") {
            this.memo = buffer_1.Buffer.alloc(4);
            this.memo.writeUInt32BE(0, 0);
        }
        else {
            let memolen = buffer_1.Buffer.alloc(4);
            memolen.writeUInt32BE(memo.length, 0);
            this.memo = memo;
        }
        if (typeof ins !== 'undefined' && typeof outs !== 'undefined') {
            this.numouts.writeUInt32BE(outs.length, 0);
            this.outs = outs.sort(outputs_1.TransferableOutput.comparator());
            this.numins.writeUInt32BE(ins.length, 0);
            this.ins = ins.sort(inputs_1.TransferableInput.comparator());
        }
    }
    /**
       * Returns the id of the [[BaseTx]]
       */
    getTxType() {
        return types_1.AVMConstants.BASETX;
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[BaseTx]], parses it, populates the class, and returns the length of the BaseTx in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[BaseTx]]
       *
       * @returns The length of the raw [[BaseTx]]
       *
       * @remarks assume not-checksummed
       */
    fromBuffer(bytes, offset = 0) {
        this.networkid = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.blockchainid = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        this.numouts = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const outcount = this.numouts.readUInt32BE(0);
        this.outs = [];
        for (let i = 0; i < outcount; i++) {
            const xferout = new outputs_1.TransferableOutput();
            offset = xferout.fromBuffer(bytes, offset);
            this.outs.push(xferout);
        }
        this.numins = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const incount = this.numins.readUInt32BE(0);
        this.ins = [];
        for (let i = 0; i < incount; i++) {
            const xferin = new inputs_1.TransferableInput();
            offset = xferin.fromBuffer(bytes, offset);
            this.ins.push(xferin);
        }
        let memolen = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
        offset += 4;
        this.memo = bintools.copyFrom(bytes, offset, offset + memolen);
        offset += memolen;
        return offset;
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[BaseTx]].
       */
    toBuffer() {
        this.outs.sort(outputs_1.TransferableOutput.comparator());
        this.ins.sort(inputs_1.TransferableInput.comparator());
        this.numouts.writeUInt32BE(this.outs.length, 0);
        this.numins.writeUInt32BE(this.ins.length, 0);
        let bsize = this.networkid.length + this.blockchainid.length + this.numouts.length;
        const barr = [this.networkid, this.blockchainid, this.numouts];
        for (let i = 0; i < this.outs.length; i++) {
            const b = this.outs[i].toBuffer();
            barr.push(b);
            bsize += b.length;
        }
        barr.push(this.numins);
        bsize += this.numins.length;
        for (let i = 0; i < this.ins.length; i++) {
            const b = this.ins[i].toBuffer();
            barr.push(b);
            bsize += b.length;
        }
        let memolen = buffer_1.Buffer.alloc(4);
        memolen.writeUInt32BE(this.memo.length, 0);
        barr.push(memolen);
        bsize += 4;
        barr.push(this.memo);
        bsize += this.memo.length;
        const buff = buffer_1.Buffer.concat(barr, bsize);
        return buff;
    }
    /**
       * Returns a base-58 representation of the [[BaseTx]].
       */
    toString() {
        return bintools.bufferToB58(this.toBuffer());
    }
    /**
       * Takes the bytes of an [[UnsignedTx]] and returns an array of [[Credential]]s
       *
       * @param msg A Buffer for the [[UnsignedTx]]
       * @param kc An [[AVMKeyChain]] used in signing
       *
       * @returns An array of [[Credential]]s
       */
    sign(msg, kc) {
        const sigs = [];
        for (let i = 0; i < this.ins.length; i++) {
            const cred = credentials_1.SelectCredentialClass(this.ins[i].getInput().getCredentialID());
            const sigidxs = this.ins[i].getInput().getSigIdxs();
            for (let j = 0; j < sigidxs.length; j++) {
                const keypair = kc.getKey(sigidxs[j].getSource());
                const signval = keypair.sign(msg);
                const sig = new types_1.Signature();
                sig.fromBuffer(signval);
                cred.addSignature(sig);
            }
            sigs.push(cred);
        }
        return sigs;
    }
}
exports.BaseTx = BaseTx;
class CreateAssetTx extends BaseTx {
    /**
       * Class representing an unsigned Create Asset transaction.
       *
       * @param networkid Optional networkid, default 3
       * @param blockchainid Optional blockchainid, default Buffer.alloc(32, 16)
       * @param outs Optional array of the [[TransferableOutput]]s
       * @param ins Optional array of the [[TransferableInput]]s
       * @param memo Optional {@link https://github.com/feross/buffer|Buffer} for the memo field
       * @param name String for the descriptive name of the asset
       * @param symbol String for the ticker symbol of the asset
       * @param denomination Optional number for the denomination which is 10^D. D must be >= 0 and <= 32. Ex: $1 AVAX = 10^9 $nAVAX
       * @param initialstate Optional [[InitialStates]] that represent the intial state of a created asset
       */
    constructor(networkid = 3, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, name = undefined, symbol = undefined, denomination = undefined, initialstate = undefined) {
        super(networkid, blockchainid, outs, ins, memo);
        this.name = '';
        this.symbol = '';
        this.denomination = buffer_1.Buffer.alloc(1);
        this.initialstate = new types_1.InitialStates();
        /**
           * Returns the array of array of [[Output]]s for the initial state
           */
        this.getInitialStates = () => this.initialstate;
        /**
           * Returns the string representation of the name
           */
        this.getName = () => this.name;
        /**
           * Returns the string representation of the symbol
           */
        this.getSymbol = () => this.symbol;
        /**
           * Returns the numeric representation of the denomination
           */
        this.getDenomination = () => this.denomination.readUInt8(0);
        /**
         * Returns the {@link https://github.com/feross/buffer|Buffer} representation of the denomination
         */
        this.getDenominationBuffer = () => {
            return this.denomination;
        };
        if (typeof name === 'string' && typeof symbol === 'string' && typeof denomination === 'number'
            && denomination >= 0 && denomination <= 32 && typeof initialstate !== 'undefined') {
            this.initialstate = initialstate;
            this.name = name;
            this.symbol = symbol;
            this.denomination.writeUInt8(denomination, 0);
        }
    }
    /**
       * Returns the id of the [[CreateAssetTx]]
       */
    getTxType() {
        return types_1.AVMConstants.CREATEASSETTX;
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[CreateAssetTx]], parses it, populates the class, and returns the length of the [[CreateAssetTx]] in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[CreateAssetTx]]
       *
       * @returns The length of the raw [[CreateAssetTx]]
       *
       * @remarks assume not-checksummed
       */
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        const namesize = bintools.copyFrom(bytes, offset, offset + 2).readUInt16BE(0);
        offset += 2;
        this.name = bintools.copyFrom(bytes, offset, offset + namesize).toString('utf8');
        offset += namesize;
        const symsize = bintools.copyFrom(bytes, offset, offset + 2).readUInt16BE(0);
        offset += 2;
        this.symbol = bintools.copyFrom(bytes, offset, offset + symsize).toString('utf8');
        offset += symsize;
        this.denomination = bintools.copyFrom(bytes, offset, offset + 1);
        offset += 1;
        const inits = new types_1.InitialStates();
        offset = inits.fromBuffer(bytes, offset);
        this.initialstate = inits;
        return offset;
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[CreateAssetTx]].
       */
    toBuffer() {
        const superbuff = super.toBuffer();
        const initstatebuff = this.initialstate.toBuffer();
        const namebuff = buffer_1.Buffer.alloc(this.name.length);
        namebuff.write(this.name, 0, this.name.length, 'utf8');
        const namesize = buffer_1.Buffer.alloc(2);
        namesize.writeUInt16BE(this.name.length, 0);
        const symbuff = buffer_1.Buffer.alloc(this.symbol.length);
        symbuff.write(this.symbol, 0, this.symbol.length, 'utf8');
        const symsize = buffer_1.Buffer.alloc(2);
        symsize.writeUInt16BE(this.symbol.length, 0);
        const bsize = superbuff.length + namesize.length + namebuff.length + symsize.length + symbuff.length + this.denomination.length + initstatebuff.length;
        const barr = [superbuff, namesize, namebuff, symsize, symbuff, this.denomination, initstatebuff];
        return buffer_1.Buffer.concat(barr, bsize);
    }
}
exports.CreateAssetTx = CreateAssetTx;
/**
 * Class representing an unsigned Operation transaction.
 */
class OperationTx extends BaseTx {
    /**
       * Class representing an unsigned Operation transaction.
       *
       * @param networkid Optional networkid, default 3
       * @param blockchainid Optional blockchainid, default Buffer.alloc(32, 16)
       * @param outs Optional array of the [[TransferableOutput]]s
       * @param ins Optional array of the [[TransferableInput]]s
       * @param memo Optional {@link https://github.com/feross/buffer|Buffer} for the memo field
       * @param ops Array of [[Operation]]s used in the transaction
       */
    constructor(networkid = 3, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, ops = undefined) {
        super(networkid, blockchainid, outs, ins, memo);
        this.numOps = buffer_1.Buffer.alloc(4);
        this.ops = [];
        if (typeof ops !== 'undefined' && Array.isArray(ops)) {
            for (let i = 0; i < ops.length; i++) {
                if (!(ops[i] instanceof ops_1.TransferableOperation)) {
                    throw new Error("Error - OperationTx.constructor: invalid op in array parameter 'ops'");
                }
            }
            this.ops = ops;
        }
    }
    /**
       * Returns the id of the [[OperationTx]]
       */
    getTxType() {
        return types_1.AVMConstants.OPERATIONTX;
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[OperationTx]], parses it, populates the class, and returns the length of the [[OperationTx]] in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[OperationTx]]
       *
       * @returns The length of the raw [[OperationTx]]
       *
       * @remarks assume not-checksummed
       */
    fromBuffer(bytes, offset = 0, codecid = types_1.AVMConstants.LATESTCODEC) {
        offset = super.fromBuffer(bytes, offset);
        this.numOps = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const numOps = this.numOps.readUInt32BE(0);
        for (let i = 0; i < numOps; i++) {
            const op = new ops_1.TransferableOperation();
            offset = op.fromBuffer(bytes, offset);
            this.ops.push(op);
        }
        return offset;
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[OperationTx]].
       */
    toBuffer() {
        this.numOps.writeUInt32BE(this.ops.length, 0);
        let barr = [super.toBuffer(), this.numOps];
        this.ops = this.ops.sort(ops_1.TransferableOperation.comparator());
        for (let i = 0; i < this.ops.length; i++) {
            barr.push(this.ops[i].toBuffer());
        }
        return buffer_1.Buffer.concat(barr);
    }
    /**
       * Returns an array of [[TransferableOperation]]s in this transaction.
       */
    getOperations() {
        return this.ops;
    }
    /**
       * Takes the bytes of an [[UnsignedTx]] and returns an array of [[Credential]]s
       *
       * @param msg A Buffer for the [[UnsignedTx]]
       * @param kc An [[AVMKeyChain]] used in signing
       *
       * @returns An array of [[Credential]]s
       */
    sign(msg, kc) {
        const sigs = super.sign(msg, kc);
        for (let i = 0; i < this.ops.length; i++) {
            const cred = credentials_1.SelectCredentialClass(this.ops[i].getOperation().getCredentialID());
            const sigidxs = this.ops[i].getOperation().getSigIdxs();
            for (let j = 0; j < sigidxs.length; j++) {
                const keypair = kc.getKey(sigidxs[j].getSource());
                const signval = keypair.sign(msg);
                const sig = new types_1.Signature();
                sig.fromBuffer(signval);
                cred.addSignature(sig);
            }
            sigs.push(cred);
        }
        return sigs;
    }
}
exports.OperationTx = OperationTx;
/**
 * Class representing an unsigned Import transaction.
 */
class ImportTx extends BaseTx {
    /**
       * Class representing an unsigned Import transaction.
       *
       * @param networkid Optional networkid, default 3
       * @param blockchainid Optional blockchainid, default Buffer.alloc(32, 16)
       * @param outs Optional array of the [[TransferableOutput]]s
       * @param ins Optional array of the [[TransferableInput]]s
       * @param memo Optional {@link https://github.com/feross/buffer|Buffer} for the memo field
       * @param importIns Array of [[TransferableInput]]s used in the transaction
       */
    constructor(networkid = 3, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, importIns = undefined) {
        super(networkid, blockchainid, outs, ins, memo);
        this.numIns = buffer_1.Buffer.alloc(4);
        this.importIns = [];
        if (typeof importIns !== 'undefined' && Array.isArray(importIns)) {
            for (let i = 0; i < importIns.length; i++) {
                if (!(importIns[i] instanceof inputs_1.TransferableInput)) {
                    throw new Error("Error - ImportTx.constructor: invalid TransferableInput in array parameter 'importIns'");
                }
            }
            this.importIns = importIns;
        }
    }
    /**
       * Returns the id of the [[ImportTx]]
       */
    getTxType() {
        return types_1.AVMConstants.IMPORTTX;
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[ImportTx]], parses it, populates the class, and returns the length of the [[ImportTx]] in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[ImportTx]]
       *
       * @returns The length of the raw [[ImportTx]]
       *
       * @remarks assume not-checksummed
       */
    fromBuffer(bytes, offset = 0, codecid = types_1.AVMConstants.LATESTCODEC) {
        offset = super.fromBuffer(bytes, offset);
        this.numIns = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const numIns = this.numIns.readUInt32BE(0);
        for (let i = 0; i < numIns; i++) {
            const anIn = new inputs_1.TransferableInput();
            offset = anIn.fromBuffer(bytes, offset);
            this.importIns.push(anIn);
        }
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[ImportTx]].
     */
    toBuffer() {
        this.numIns.writeUInt32BE(this.importIns.length, 0);
        let barr = [super.toBuffer(), this.numIns];
        this.importIns = this.importIns.sort(inputs_1.TransferableInput.comparator());
        for (let i = 0; i < this.importIns.length; i++) {
            barr.push(this.importIns[i].toBuffer());
        }
        return buffer_1.Buffer.concat(barr);
    }
    /**
       * Returns an array of [[TransferableInput]]s in this transaction.
       */
    getImportInputs() {
        return this.importIns;
    }
    /**
       * Takes the bytes of an [[UnsignedTx]] and returns an array of [[Credential]]s
       *
       * @param msg A Buffer for the [[UnsignedTx]]
       * @param kc An [[AVMKeyChain]] used in signing
       *
       * @returns An array of [[Credential]]s
       */
    sign(msg, kc) {
        const sigs = super.sign(msg, kc);
        for (let i = 0; i < this.importIns.length; i++) {
            const cred = credentials_1.SelectCredentialClass(this.importIns[i].getInput().getCredentialID());
            const sigidxs = this.importIns[i].getInput().getSigIdxs();
            for (let j = 0; j < sigidxs.length; j++) {
                const keypair = kc.getKey(sigidxs[j].getSource());
                const signval = keypair.sign(msg);
                const sig = new types_1.Signature();
                sig.fromBuffer(signval);
                cred.addSignature(sig);
            }
            sigs.push(cred);
        }
        return sigs;
    }
}
exports.ImportTx = ImportTx;
/**
 * Class representing an unsigned Export transaction.
 */
class ExportTx extends BaseTx {
    /**
       * Class representing an unsigned Export transaction.
       *
       * @param networkid Optional networkid, default 3
       * @param blockchainid Optional blockchainid, default Buffer.alloc(32, 16)
       * @param outs Optional array of the [[TransferableOutput]]s
       * @param ins Optional array of the [[TransferableInput]]s
       * @param exportOuts Array of [[TransferableOutputs]]s used in the transaction
       */
    constructor(networkid = 3, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, exportOuts = undefined) {
        super(networkid, blockchainid, outs, ins, memo);
        this.numOuts = buffer_1.Buffer.alloc(4);
        this.exportOuts = [];
        if (typeof exportOuts !== 'undefined' && Array.isArray(exportOuts)) {
            for (let i = 0; i < exportOuts.length; i++) {
                if (!(exportOuts[i] instanceof outputs_1.TransferableOutput)) {
                    throw new Error("Error - ExportTx.constructor: invalid TransferableOutput in array parameter 'exportOuts'");
                }
            }
            this.exportOuts = exportOuts;
        }
    }
    /**
       * Returns the id of the [[ExportTx]]
       */
    getTxType() {
        return types_1.AVMConstants.EXPORTTX;
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[ExportTx]], parses it, populates the class, and returns the length of the [[ExportTx]] in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[ExportTx]]
       *
       * @returns The length of the raw [[ExportTx]]
       *
       * @remarks assume not-checksummed
       */
    fromBuffer(bytes, offset = 0) {
        // this.codecid.writeUInt8(offset, 0);
        // offset += 6;
        offset = super.fromBuffer(bytes, offset);
        this.numOuts = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const numOuts = this.numOuts.readUInt32BE(0);
        for (let i = 0; i < numOuts; i++) {
            const anOut = new outputs_1.TransferableOutput();
            offset = anOut.fromBuffer(bytes, offset);
            this.exportOuts.push(anOut);
        }
        return offset;
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[ExportTx]].
       */
    toBuffer() {
        this.numOuts.writeUInt32BE(this.exportOuts.length, 0);
        let barr = [super.toBuffer(), this.numOuts];
        this.exportOuts = this.exportOuts.sort(outputs_1.TransferableOutput.comparator());
        for (let i = 0; i < this.exportOuts.length; i++) {
            barr.push(this.exportOuts[i].toBuffer());
        }
        return buffer_1.Buffer.concat(barr);
    }
    /**
       * Returns an array of [[TransferableOutput]]s in this transaction.
       */
    getExportOutputs() {
        return this.exportOuts;
    }
}
exports.ExportTx = ExportTx;
/**
 * Class representing an unsigned transaction.
 */
class UnsignedTx {
    constructor(transaction = undefined, codecid = types_1.AVMConstants.LATESTCODEC) {
        this.codecid = types_1.AVMConstants.LATESTCODEC;
        /**
           * Returns the CodecID as a number
           */
        this.getCodecID = () => this.codecid;
        /**
         * Returns the {@link https://github.com/feross/buffer|Buffer} representation of the CodecID
          */
        this.getCodecIDBuffer = () => {
            let codecBuf = buffer_1.Buffer.alloc(2);
            codecBuf.writeUInt16BE(this.codecid, 0);
            return codecBuf;
        };
        /**
           * Returns the inputTotal as a BN
           */
        this.getInputTotal = (assetID) => {
            const ins = this.getTransaction().getIns();
            const aIDHex = assetID.toString('hex');
            let total = new bn_js_1.default(0);
            for (let i = 0; i < ins.length; i++) {
                const input = ins[i].getInput();
                // only check secpinputs
                if (input.getInputID() === types_1.AVMConstants.SECPINPUTID && aIDHex === ins[i].getAssetID().toString('hex')) {
                    total = total.add(input.getAmount());
                }
            }
            return total;
        };
        /**
           * Returns the outputTotal as a BN
           */
        this.getOutputTotal = (assetID) => {
            const outs = this.getTransaction().getOuts();
            const aIDHex = assetID.toString('hex');
            let total = new bn_js_1.default(0);
            for (let i = 0; i < outs.length; i++) {
                const output = outs[i].getOutput();
                // only check secpoutputs
                if (output.getOutputID() === types_1.AVMConstants.SECPOUTPUTID && aIDHex === outs[i].getAssetID().toString('hex')) {
                    total = total.add(output.getAmount());
                }
            }
            return total;
        };
        /**
           * Returns the number of burned tokens as a BN
           */
        this.getBurn = (assetID) => {
            return this.getInputTotal(assetID).sub(this.getOutputTotal(assetID));
        };
        /**
           * Returns the Transaction
           */
        this.getTransaction = () => this.transaction;
        this.transaction = transaction;
    }
    fromBuffer(bytes, offset = 0) {
        this.codecid = bintools.copyFrom(bytes, offset, offset + 2).readUInt16BE(0);
        offset += 2;
        const txtype = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
        offset += 4;
        this.transaction = exports.SelectTxClass(txtype);
        return this.transaction.fromBuffer(bytes, offset);
    }
    toBuffer() {
        const codecid = this.getCodecIDBuffer();
        const txtype = buffer_1.Buffer.alloc(4);
        txtype.writeUInt32BE(this.transaction.getTxType(), 0);
        const basebuff = this.transaction.toBuffer();
        return buffer_1.Buffer.concat([codecid, txtype, basebuff], codecid.length + txtype.length + basebuff.length);
    }
    /**
       * Signs this [[UnsignedTx]] and returns signed [[Tx]]
       *
       * @param kc An [[AVMKeyChain]] used in signing
       *
       * @returns A signed [[Tx]]
       */
    sign(kc) {
        const txbuff = this.toBuffer();
        const msg = buffer_1.Buffer.from(create_hash_1.default('sha256').update(txbuff).digest());
        const sigs = this.transaction.sign(msg, kc);
        return new Tx(this, sigs);
    }
}
exports.UnsignedTx = UnsignedTx;
/**
 * Class representing a signed transaction.
 */
class Tx {
    /**
       * Class representing a signed transaction.
       *
       * @param unsignedTx Optional [[UnsignedTx]]
       * @param signatures Optional array of [[Credential]]s
       */
    constructor(unsignedTx = undefined, credentials = undefined) {
        this.unsignedTx = new UnsignedTx();
        this.credentials = [];
        /**
           * Returns the [[UnsignedTx]]
           */
        this.getUnsignedTx = () => {
            return this.unsignedTx;
        };
        if (typeof unsignedTx !== 'undefined') {
            this.unsignedTx = unsignedTx;
            if (typeof credentials !== 'undefined') {
                this.credentials = credentials;
            }
        }
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[Tx]], parses it, populates the class, and returns the length of the Tx in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[Tx]]
       * @param offset A number representing the starting point of the bytes to begin parsing
       *
       * @returns The length of the raw [[Tx]]
       */
    fromBuffer(bytes, offset = 0) {
        this.unsignedTx = new UnsignedTx();
        offset = this.unsignedTx.fromBuffer(bytes, offset);
        const numcreds = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
        offset += 4;
        this.credentials = [];
        for (let i = 0; i < numcreds; i++) {
            const credid = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
            offset += 4;
            const cred = credentials_1.SelectCredentialClass(credid);
            offset = cred.fromBuffer(bytes, offset);
            this.credentials.push(cred);
        }
        return offset;
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[Tx]].
       */
    toBuffer() {
        const txbuff = this.unsignedTx.toBuffer();
        let bsize = txbuff.length;
        const credlen = buffer_1.Buffer.alloc(4);
        credlen.writeUInt32BE(this.credentials.length, 0);
        const barr = [txbuff, credlen];
        bsize += credlen.length;
        for (let i = 0; i < this.credentials.length; i++) {
            const credid = buffer_1.Buffer.alloc(4);
            credid.writeUInt32BE(this.credentials[i].getCredentialID(), 0);
            barr.push(credid);
            bsize += credid.length;
            const credbuff = this.credentials[i].toBuffer();
            bsize += credbuff.length;
            barr.push(credbuff);
        }
        const buff = buffer_1.Buffer.concat(barr, bsize);
        return buff;
    }
    /**
       * Takes a base-58 string containing an [[Tx]], parses it, populates the class, and returns the length of the Tx in bytes.
       *
       * @param serialized A base-58 string containing a raw [[Tx]]
       *
       * @returns The length of the raw [[Tx]]
       *
       * @remarks
       * unlike most fromStrings, it expects the string to be serialized in cb58 format
       */
    fromString(serialized) {
        return this.fromBuffer(bintools.cb58Decode(serialized));
    }
    /**
       * Returns a base-58 AVAX-serialized representation of the [[Tx]].
       *
       * @remarks
       * unlike most toStrings, this returns in cb58 serialization format
       */
    toString() {
        return bintools.cb58Encode(this.toBuffer());
    }
}
exports.Tx = Tx;
/**
 * Takes a buffer representing the output and returns the proper [[BaseTx]] instance.
 *
 * @param txtype The id of the transaction type
 *
 * @returns An instance of an [[BaseTx]]-extended class.
 */
exports.SelectTxClass = (txtype, ...args) => {
    if (txtype === types_1.AVMConstants.BASETX) {
        const tx = new BaseTx(...args);
        return tx;
    }
    else if (txtype === types_1.AVMConstants.CREATEASSETTX) {
        const tx = new CreateAssetTx(...args);
        return tx;
    }
    else if (txtype === types_1.AVMConstants.OPERATIONTX) {
        const tx = new OperationTx(...args);
        return tx;
    }
    else if (txtype === types_1.AVMConstants.IMPORTTX) {
        const tx = new ImportTx(...args);
        return tx;
    }
    else if (txtype === types_1.AVMConstants.EXPORTTX) {
        const tx = new ExportTx(...args);
        return tx;
    }
    /* istanbul ignore next */
    throw new Error(`Error - SelectTxClass: unknown txtype ${txtype}`);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpcy9hdm0vdHgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztHQUdHO0FBQ0gsb0NBQWlDO0FBQ2pDLDhEQUFxQztBQUNyQyxvRUFBNEM7QUFDNUMsbUNBRWlCO0FBQ2pCLHVDQUE2RDtBQUM3RCxxQ0FBMEQ7QUFDMUQsK0JBQThDO0FBQzlDLCtDQUFrRTtBQUVsRSxrREFBdUI7QUFFdkI7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRXhDOztHQUVHO0FBQ0gsTUFBYSxNQUFNO0lBaUpqQjs7Ozs7Ozs7U0FRSztJQUNMLFlBQVksWUFBbUIsQ0FBQyxFQUFFLGVBQXNCLGVBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLE9BQWlDLFNBQVMsRUFBRSxNQUErQixTQUFTLEVBQUUsT0FBYyxTQUFTO1FBekpqTCxjQUFTLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxpQkFBWSxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkMsWUFBTyxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFakMsV0FBTSxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFaEMsU0FBSSxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFTeEM7O2FBRUs7UUFDTCxpQkFBWSxHQUFHLEdBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTNEOzthQUVLO1FBQ0wsb0JBQWUsR0FBRyxHQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO1FBRWpEOzthQUVLO1FBQ0wsV0FBTSxH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QUFDckUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVZNQVBJLVRyYW5zYWN0aW9uc1xuICovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXIvJztcbmltcG9ydCBjcmVhdGVIYXNoIGZyb20gJ2NyZWF0ZS1oYXNoJztcbmltcG9ydCBCaW5Ub29scyBmcm9tICcuLi8uLi91dGlscy9iaW50b29scyc7XG5pbXBvcnQge1xuICBBVk1Db25zdGFudHMsIEluaXRpYWxTdGF0ZXMsIFNpZ25hdHVyZSwgU2lnSWR4LFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFRyYW5zZmVyYWJsZU91dHB1dCwgQW1vdW50T3V0cHV0IH0gZnJvbSAnLi9vdXRwdXRzJztcbmltcG9ydCB7IFRyYW5zZmVyYWJsZUlucHV0LCBBbW91bnRJbnB1dCB9IGZyb20gJy4vaW5wdXRzJztcbmltcG9ydCB7IFRyYW5zZmVyYWJsZU9wZXJhdGlvbiB9IGZyb20gJy4vb3BzJztcbmltcG9ydCB7IENyZWRlbnRpYWwsIFNlbGVjdENyZWRlbnRpYWxDbGFzcyB9IGZyb20gJy4vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQVZNS2V5Q2hhaW4sIEFWTUtleVBhaXIgfSBmcm9tICcuL2tleWNoYWluJztcbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29scyA9IEJpblRvb2xzLmdldEluc3RhbmNlKCk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgYmFzZSBmb3IgYWxsIHRyYW5zYWN0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VUeCB7XG4gIHByb3RlY3RlZCBuZXR3b3JraWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICBwcm90ZWN0ZWQgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMik7XG4gIHByb3RlY3RlZCBudW1vdXRzOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgcHJvdGVjdGVkIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PjtcbiAgcHJvdGVjdGVkIG51bWluczpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gIHByb3RlY3RlZCBpbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+O1xuICBwcm90ZWN0ZWQgbWVtbzpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIFtbQmFzZVR4XV1cbiAgICAgKi9cbiAgZ2V0VHhUeXBlKCk6bnVtYmVyIHtcbiAgICByZXR1cm4gQVZNQ29uc3RhbnRzLkJBU0VUWDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmtJRCBhcyBhIG51bWJlclxuICAgICAqL1xuICBnZXROZXR3b3JrSUQgPSAoKTpudW1iZXIgPT4gdGhpcy5uZXR3b3JraWQucmVhZFVJbnQzMkJFKDApO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgQmxvY2tjaGFpbklEXG4gICAgICovXG4gIGdldEJsb2NrY2hhaW5JRCA9ICgpOkJ1ZmZlciA9PiB0aGlzLmJsb2NrY2hhaW5pZDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBbW1RyYW5zZmVyYWJsZUlucHV0XV1zXG4gICAgICovXG4gIGdldElucyA9ICgpOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9PiB0aGlzLmlucztcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBbW1RyYW5zZmVyYWJsZU91dHB1dF1dc1xuICAgICAqL1xuICBnZXRPdXRzID0gKCk6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9PiB0aGlzLm91dHM7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZW1vIFxuICAgKi9cbiAgZ2V0TWVtbyA9ICgpOkJ1ZmZlciA9PiB0aGlzLm1lbW87XG5cbiAgLyoqXG4gICAgICogVGFrZXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIGFuIFtbQmFzZVR4XV0sIHBhcnNlcyBpdCwgcG9wdWxhdGVzIHRoZSBjbGFzcywgYW5kIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgQmFzZVR4IGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhIHJhdyBbW0Jhc2VUeF1dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSByYXcgW1tCYXNlVHhdXVxuICAgICAqXG4gICAgICogQHJlbWFya3MgYXNzdW1lIG5vdC1jaGVja3N1bW1lZFxuICAgICAqL1xuICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgdGhpcy5uZXR3b3JraWQgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aGlzLmJsb2NrY2hhaW5pZCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDMyKTtcbiAgICBvZmZzZXQgKz0gMzI7XG4gICAgdGhpcy5udW1vdXRzID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3Qgb3V0Y291bnQ6bnVtYmVyID0gdGhpcy5udW1vdXRzLnJlYWRVSW50MzJCRSgwKTtcbiAgICB0aGlzLm91dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHhmZXJvdXQ6VHJhbnNmZXJhYmxlT3V0cHV0ID0gbmV3IFRyYW5zZmVyYWJsZU91dHB1dCgpO1xuICAgICAgb2Zmc2V0ID0geGZlcm91dC5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgdGhpcy5vdXRzLnB1c2goeGZlcm91dCk7XG4gICAgfVxuXG4gICAgdGhpcy5udW1pbnMgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBjb25zdCBpbmNvdW50Om51bWJlciA9IHRoaXMubnVtaW5zLnJlYWRVSW50MzJCRSgwKTtcbiAgICB0aGlzLmlucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5jb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB4ZmVyaW46VHJhbnNmZXJhYmxlSW5wdXQgPSBuZXcgVHJhbnNmZXJhYmxlSW5wdXQoKTtcbiAgICAgIG9mZnNldCA9IHhmZXJpbi5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgdGhpcy5pbnMucHVzaCh4ZmVyaW4pO1xuICAgIH1cbiAgICBsZXQgbWVtb2xlbjpudW1iZXIgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KS5yZWFkVUludDMyQkUoMCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGhpcy5tZW1vID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgbWVtb2xlbik7XG4gICAgb2Zmc2V0ICs9IG1lbW9sZW47XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tCYXNlVHhdXS5cbiAgICAgKi9cbiAgdG9CdWZmZXIoKTpCdWZmZXIge1xuICAgIHRoaXMub3V0cy5zb3J0KFRyYW5zZmVyYWJsZU91dHB1dC5jb21wYXJhdG9yKCkpO1xuICAgIHRoaXMuaW5zLnNvcnQoVHJhbnNmZXJhYmxlSW5wdXQuY29tcGFyYXRvcigpKTtcbiAgICB0aGlzLm51bW91dHMud3JpdGVVSW50MzJCRSh0aGlzLm91dHMubGVuZ3RoLCAwKTtcbiAgICB0aGlzLm51bWlucy53cml0ZVVJbnQzMkJFKHRoaXMuaW5zLmxlbmd0aCwgMCk7XG4gICAgbGV0IGJzaXplOm51bWJlciA9IHRoaXMubmV0d29ya2lkLmxlbmd0aCArIHRoaXMuYmxvY2tjaGFpbmlkLmxlbmd0aCArIHRoaXMubnVtb3V0cy5sZW5ndGg7XG4gICAgY29uc3QgYmFycjpBcnJheTxCdWZmZXI+ID0gW3RoaXMubmV0d29ya2lkLCB0aGlzLmJsb2NrY2hhaW5pZCwgdGhpcy5udW1vdXRzXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYjpCdWZmZXIgPSB0aGlzLm91dHNbaV0udG9CdWZmZXIoKTtcbiAgICAgIGJhcnIucHVzaChiKTtcbiAgICAgIGJzaXplICs9IGIubGVuZ3RoO1xuICAgIH1cbiAgICBiYXJyLnB1c2godGhpcy5udW1pbnMpO1xuICAgIGJzaXplICs9IHRoaXMubnVtaW5zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBiOkJ1ZmZlciA9IHRoaXMuaW5zW2ldLnRvQnVmZmVyKCk7XG4gICAgICBiYXJyLnB1c2goYik7XG4gICAgICBic2l6ZSArPSBiLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG1lbW9sZW46QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIG1lbW9sZW4ud3JpdGVVSW50MzJCRSh0aGlzLm1lbW8ubGVuZ3RoLCAwKTtcbiAgICBiYXJyLnB1c2gobWVtb2xlbik7XG4gICAgYnNpemUgKz0gNDtcbiAgICBiYXJyLnB1c2godGhpcy5tZW1vKTtcbiAgICBic2l6ZSArPSB0aGlzLm1lbW8ubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmY6QnVmZmVyID0gQnVmZmVyLmNvbmNhdChiYXJyLCBic2l6ZSk7XG4gICAgcmV0dXJuIGJ1ZmY7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tCYXNlVHhdXS5cbiAgICAgKi9cbiAgdG9TdHJpbmcoKTpzdHJpbmcge1xuICAgIHJldHVybiBiaW50b29scy5idWZmZXJUb0I1OCh0aGlzLnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAgICogVGFrZXMgdGhlIGJ5dGVzIG9mIGFuIFtbVW5zaWduZWRUeF1dIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFtbQ3JlZGVudGlhbF1dc1xuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyBBIEJ1ZmZlciBmb3IgdGhlIFtbVW5zaWduZWRUeF1dXG4gICAgICogQHBhcmFtIGtjIEFuIFtbQVZNS2V5Q2hhaW5dXSB1c2VkIGluIHNpZ25pbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFtbQ3JlZGVudGlhbF1dc1xuICAgICAqL1xuICBzaWduKG1zZzpCdWZmZXIsIGtjOkFWTUtleUNoYWluKTpBcnJheTxDcmVkZW50aWFsPiB7XG4gICAgY29uc3Qgc2lnczpBcnJheTxDcmVkZW50aWFsPiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNyZWQ6Q3JlZGVudGlhbCA9IFNlbGVjdENyZWRlbnRpYWxDbGFzcyh0aGlzLmluc1tpXS5nZXRJbnB1dCgpLmdldENyZWRlbnRpYWxJRCgpKTtcbiAgICAgIGNvbnN0IHNpZ2lkeHM6QXJyYXk8U2lnSWR4PiA9IHRoaXMuaW5zW2ldLmdldElucHV0KCkuZ2V0U2lnSWR4cygpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaWdpZHhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleXBhaXI6QVZNS2V5UGFpciA9IGtjLmdldEtleShzaWdpZHhzW2pdLmdldFNvdXJjZSgpKTtcbiAgICAgICAgY29uc3Qgc2lnbnZhbDpCdWZmZXIgPSBrZXlwYWlyLnNpZ24obXNnKTtcbiAgICAgICAgY29uc3Qgc2lnOlNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoKTtcbiAgICAgICAgc2lnLmZyb21CdWZmZXIoc2lnbnZhbCk7XG4gICAgICAgIGNyZWQuYWRkU2lnbmF0dXJlKHNpZyk7XG4gICAgICB9XG4gICAgICBzaWdzLnB1c2goY3JlZCk7XG4gICAgfVxuICAgIHJldHVybiBzaWdzO1xuICB9XG5cbiAgLyoqXG4gICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgQmFzZVR4IHdoaWNoIGlzIHRoZSBmb3VuZGF0aW9uIGZvciBhbGwgdHJhbnNhY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtpZCBPcHRpb25hbCBuZXR3b3JraWQsIGRlZmF1bHQgM1xuICAgICAqIEBwYXJhbSBibG9ja2NoYWluaWQgT3B0aW9uYWwgYmxvY2tjaGFpbmlkLCBkZWZhdWx0IEJ1ZmZlci5hbGxvYygzMiwgMTYpXG4gICAgICogQHBhcmFtIG91dHMgT3B0aW9uYWwgYXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICogQHBhcmFtIGlucyBPcHRpb25hbCBhcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVJbnB1dF1dc1xuICAgICAqIEBwYXJhbSBtZW1vIE9wdGlvbmFsIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgbWVtbyBmaWVsZFxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihuZXR3b3JraWQ6bnVtYmVyID0gMywgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLCBvdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSB1bmRlZmluZWQsIGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB1bmRlZmluZWQsIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5uZXR3b3JraWQud3JpdGVVSW50MzJCRShuZXR3b3JraWQsIDApO1xuICAgIHRoaXMuYmxvY2tjaGFpbmlkID0gYmxvY2tjaGFpbmlkO1xuICAgIGlmKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgIHRoaXMubWVtbyA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgIHRoaXMubWVtby53cml0ZVVJbnQzMkJFKDAsMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZW1vbGVuID0gQnVmZmVyLmFsbG9jKDQpXG4gICAgICBtZW1vbGVuLndyaXRlVUludDMyQkUobWVtby5sZW5ndGgsIDApO1xuICAgICAgdGhpcy5tZW1vID0gbWVtbztcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiBpbnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvdXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5udW1vdXRzLndyaXRlVUludDMyQkUob3V0cy5sZW5ndGgsIDApO1xuICAgICAgdGhpcy5vdXRzID0gb3V0cy5zb3J0KFRyYW5zZmVyYWJsZU91dHB1dC5jb21wYXJhdG9yKCkpO1xuICAgICAgdGhpcy5udW1pbnMud3JpdGVVSW50MzJCRShpbnMubGVuZ3RoLCAwKTtcbiAgICAgIHRoaXMuaW5zID0gaW5zLnNvcnQoVHJhbnNmZXJhYmxlSW5wdXQuY29tcGFyYXRvcigpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENyZWF0ZUFzc2V0VHggZXh0ZW5kcyBCYXNlVHgge1xuICBwcm90ZWN0ZWQgbmFtZTpzdHJpbmcgPSAnJztcbiAgcHJvdGVjdGVkIHN5bWJvbDpzdHJpbmcgPSAnJztcbiAgcHJvdGVjdGVkIGRlbm9taW5hdGlvbjpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMSk7XG4gIHByb3RlY3RlZCBpbml0aWFsc3RhdGU6SW5pdGlhbFN0YXRlcyA9IG5ldyBJbml0aWFsU3RhdGVzKCk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIFtbQ3JlYXRlQXNzZXRUeF1dXG4gICAgICovXG4gIGdldFR4VHlwZSgpOm51bWJlciB7XG4gICAgcmV0dXJuIEFWTUNvbnN0YW50cy5DUkVBVEVBU1NFVFRYO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgYXJyYXkgb2YgW1tPdXRwdXRdXXMgZm9yIHRoZSBpbml0aWFsIHN0YXRlXG4gICAgICovXG4gIGdldEluaXRpYWxTdGF0ZXMgPSAoKTpJbml0aWFsU3RhdGVzID0+IHRoaXMuaW5pdGlhbHN0YXRlO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbmFtZVxuICAgICAqL1xuICBnZXROYW1lID0gKCk6c3RyaW5nID0+IHRoaXMubmFtZTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN5bWJvbFxuICAgICAqL1xuICBnZXRTeW1ib2wgPSAoKTpzdHJpbmcgPT4gdGhpcy5zeW1ib2w7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVub21pbmF0aW9uXG4gICAgICovXG4gIGdldERlbm9taW5hdGlvbiA9ICgpOm51bWJlciA9PiB0aGlzLmRlbm9taW5hdGlvbi5yZWFkVUludDgoMCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVub21pbmF0aW9uXG4gICAgICovXG5cbiAgICBnZXREZW5vbWluYXRpb25CdWZmZXIgPSAoKTpCdWZmZXIgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kZW5vbWluYXRpb247XG4gICAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhbiBbW0NyZWF0ZUFzc2V0VHhdXSwgcGFyc2VzIGl0LCBwb3B1bGF0ZXMgdGhlIGNsYXNzLCBhbmQgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBbW0NyZWF0ZUFzc2V0VHhdXSBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgYSByYXcgW1tDcmVhdGVBc3NldFR4XV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHJhdyBbW0NyZWF0ZUFzc2V0VHhdXVxuICAgICAqXG4gICAgICogQHJlbWFya3MgYXNzdW1lIG5vdC1jaGVja3N1bW1lZFxuICAgICAqL1xuICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgb2Zmc2V0ID0gc3VwZXIuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcblxuICAgIGNvbnN0IG5hbWVzaXplOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICBvZmZzZXQgKz0gMjtcbiAgICB0aGlzLm5hbWUgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyBuYW1lc2l6ZSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICBvZmZzZXQgKz0gbmFtZXNpemU7XG5cbiAgICBjb25zdCBzeW1zaXplOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICBvZmZzZXQgKz0gMjtcbiAgICB0aGlzLnN5bWJvbCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIHN5bXNpemUpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgb2Zmc2V0ICs9IHN5bXNpemU7XG5cbiAgICB0aGlzLmRlbm9taW5hdGlvbiA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDEpO1xuICAgIG9mZnNldCArPSAxO1xuXG4gICAgY29uc3QgaW5pdHM6SW5pdGlhbFN0YXRlcyA9IG5ldyBJbml0aWFsU3RhdGVzKCk7XG4gICAgb2Zmc2V0ID0gaW5pdHMuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgICB0aGlzLmluaXRpYWxzdGF0ZSA9IGluaXRzO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tDcmVhdGVBc3NldFR4XV0uXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICBjb25zdCBzdXBlcmJ1ZmY6QnVmZmVyID0gc3VwZXIudG9CdWZmZXIoKTtcbiAgICBjb25zdCBpbml0c3RhdGVidWZmOkJ1ZmZlciA9IHRoaXMuaW5pdGlhbHN0YXRlLnRvQnVmZmVyKCk7XG5cbiAgICBjb25zdCBuYW1lYnVmZjpCdWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5uYW1lLmxlbmd0aCk7XG4gICAgbmFtZWJ1ZmYud3JpdGUodGhpcy5uYW1lLCAwLCB0aGlzLm5hbWUubGVuZ3RoLCAndXRmOCcpO1xuICAgIGNvbnN0IG5hbWVzaXplOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgICBuYW1lc2l6ZS53cml0ZVVJbnQxNkJFKHRoaXMubmFtZS5sZW5ndGgsIDApO1xuXG4gICAgY29uc3Qgc3ltYnVmZjpCdWZmZXIgPSBCdWZmZXIuYWxsb2ModGhpcy5zeW1ib2wubGVuZ3RoKTtcbiAgICBzeW1idWZmLndyaXRlKHRoaXMuc3ltYm9sLCAwLCB0aGlzLnN5bWJvbC5sZW5ndGgsICd1dGY4Jyk7XG4gICAgY29uc3Qgc3ltc2l6ZTpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMik7XG4gICAgc3ltc2l6ZS53cml0ZVVJbnQxNkJFKHRoaXMuc3ltYm9sLmxlbmd0aCwgMCk7XG5cbiAgICBjb25zdCBic2l6ZTpudW1iZXIgPSBzdXBlcmJ1ZmYubGVuZ3RoICsgbmFtZXNpemUubGVuZ3RoICsgbmFtZWJ1ZmYubGVuZ3RoICsgc3ltc2l6ZS5sZW5ndGggKyBzeW1idWZmLmxlbmd0aCArIHRoaXMuZGVub21pbmF0aW9uLmxlbmd0aCArIGluaXRzdGF0ZWJ1ZmYubGVuZ3RoO1xuICAgIGNvbnN0IGJhcnI6QXJyYXk8QnVmZmVyPiA9IFtzdXBlcmJ1ZmYsIG5hbWVzaXplLCBuYW1lYnVmZiwgc3ltc2l6ZSwgc3ltYnVmZiwgdGhpcy5kZW5vbWluYXRpb24sIGluaXRzdGF0ZWJ1ZmZdO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJhcnIsIGJzaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBDcmVhdGUgQXNzZXQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya2lkIE9wdGlvbmFsIG5ldHdvcmtpZCwgZGVmYXVsdCAzXG4gICAgICogQHBhcmFtIGJsb2NrY2hhaW5pZCBPcHRpb25hbCBibG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbCBhcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXNcbiAgICAgKiBAcGFyYW0gaW5zIE9wdGlvbmFsIGFycmF5IG9mIHRoZSBbW1RyYW5zZmVyYWJsZUlucHV0XV1zXG4gICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIG5hbWUgU3RyaW5nIGZvciB0aGUgZGVzY3JpcHRpdmUgbmFtZSBvZiB0aGUgYXNzZXRcbiAgICAgKiBAcGFyYW0gc3ltYm9sIFN0cmluZyBmb3IgdGhlIHRpY2tlciBzeW1ib2wgb2YgdGhlIGFzc2V0XG4gICAgICogQHBhcmFtIGRlbm9taW5hdGlvbiBPcHRpb25hbCBudW1iZXIgZm9yIHRoZSBkZW5vbWluYXRpb24gd2hpY2ggaXMgMTBeRC4gRCBtdXN0IGJlID49IDAgYW5kIDw9IDMyLiBFeDogJDEgQVZBWCA9IDEwXjkgJG5BVkFYXG4gICAgICogQHBhcmFtIGluaXRpYWxzdGF0ZSBPcHRpb25hbCBbW0luaXRpYWxTdGF0ZXNdXSB0aGF0IHJlcHJlc2VudCB0aGUgaW50aWFsIHN0YXRlIG9mIGEgY3JlYXRlZCBhc3NldFxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBuZXR3b3JraWQ6bnVtYmVyID0gMywgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLFxuICAgIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCwgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgbmFtZTpzdHJpbmcgPSB1bmRlZmluZWQsIHN5bWJvbDpzdHJpbmcgPSB1bmRlZmluZWQsIGRlbm9taW5hdGlvbjpudW1iZXIgPSB1bmRlZmluZWQsXG4gICAgaW5pdGlhbHN0YXRlOkluaXRpYWxTdGF0ZXMgPSB1bmRlZmluZWRcbiAgKSB7XG4gICAgc3VwZXIobmV0d29ya2lkLCBibG9ja2NoYWluaWQsIG91dHMsIGlucywgbWVtbyk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzeW1ib2wgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBkZW5vbWluYXRpb24gPT09ICdudW1iZXInXG4gICAgICAgICAgICAmJiBkZW5vbWluYXRpb24gPj0gMCAmJiBkZW5vbWluYXRpb24gPD0gMzIgJiYgdHlwZW9mIGluaXRpYWxzdGF0ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIHRoaXMuaW5pdGlhbHN0YXRlID0gaW5pdGlhbHN0YXRlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICAgICAgdGhpcy5kZW5vbWluYXRpb24ud3JpdGVVSW50OChkZW5vbWluYXRpb24sIDApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBPcGVyYXRpb24gdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25UeCBleHRlbmRzIEJhc2VUeCB7XG4gIHByb3RlY3RlZCBudW1PcHM6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICBwcm90ZWN0ZWQgb3BzOkFycmF5PFRyYW5zZmVyYWJsZU9wZXJhdGlvbj4gPSBbXTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgW1tPcGVyYXRpb25UeF1dXG4gICAgICovXG4gIGdldFR4VHlwZSgpOm51bWJlciB7XG4gICAgcmV0dXJuIEFWTUNvbnN0YW50cy5PUEVSQVRJT05UWDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhbiBbW09wZXJhdGlvblR4XV0sIHBhcnNlcyBpdCwgcG9wdWxhdGVzIHRoZSBjbGFzcywgYW5kIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgW1tPcGVyYXRpb25UeF1dIGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhIHJhdyBbW09wZXJhdGlvblR4XV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHJhdyBbW09wZXJhdGlvblR4XV1cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIGFzc3VtZSBub3QtY2hlY2tzdW1tZWRcbiAgICAgKi9cbiAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwLCBjb2RlY2lkOm51bWJlciA9IEFWTUNvbnN0YW50cy5MQVRFU1RDT0RFQyk6bnVtYmVyIHtcbiAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgIHRoaXMubnVtT3BzID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgbnVtT3BzOm51bWJlciA9IHRoaXMubnVtT3BzLnJlYWRVSW50MzJCRSgwKTtcbiAgICBmb3IgKGxldCBpOm51bWJlciA9IDA7IGkgPCBudW1PcHM7IGkrKykge1xuICAgICAgY29uc3Qgb3A6VHJhbnNmZXJhYmxlT3BlcmF0aW9uID0gbmV3IFRyYW5zZmVyYWJsZU9wZXJhdGlvbigpO1xuICAgICAgb2Zmc2V0ID0gb3AuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgICAgIHRoaXMub3BzLnB1c2gob3ApO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBbW09wZXJhdGlvblR4XV0uXG4gICAgICovXG4gICAgdG9CdWZmZXIoKTpCdWZmZXIge1xuICAgICAgICB0aGlzLm51bU9wcy53cml0ZVVJbnQzMkJFKHRoaXMub3BzLmxlbmd0aCwgMCk7XG4gICAgICAgIGxldCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbc3VwZXIudG9CdWZmZXIoKSwgdGhpcy5udW1PcHNdO1xuICAgICAgICB0aGlzLm9wcyA9IHRoaXMub3BzLnNvcnQoVHJhbnNmZXJhYmxlT3BlcmF0aW9uLmNvbXBhcmF0b3IoKSk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYmFyci5wdXNoKHRoaXMub3BzW2ldLnRvQnVmZmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJhcnIpO1xuICAgIH1cbiAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBbW1RyYW5zZmVyYWJsZU9wZXJhdGlvbl1dcyBpbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICBnZXRPcGVyYXRpb25zKCk6QXJyYXk8VHJhbnNmZXJhYmxlT3BlcmF0aW9uPiB7XG4gICAgcmV0dXJuIHRoaXMub3BzO1xuICB9XG5cbiAgLyoqXG4gICAgICogVGFrZXMgdGhlIGJ5dGVzIG9mIGFuIFtbVW5zaWduZWRUeF1dIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFtbQ3JlZGVudGlhbF1dc1xuICAgICAqXG4gICAgICogQHBhcmFtIG1zZyBBIEJ1ZmZlciBmb3IgdGhlIFtbVW5zaWduZWRUeF1dXG4gICAgICogQHBhcmFtIGtjIEFuIFtbQVZNS2V5Q2hhaW5dXSB1c2VkIGluIHNpZ25pbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFtbQ3JlZGVudGlhbF1dc1xuICAgICAqL1xuICBzaWduKG1zZzpCdWZmZXIsIGtjOkFWTUtleUNoYWluKTpBcnJheTxDcmVkZW50aWFsPiB7XG4gICAgY29uc3Qgc2lnczpBcnJheTxDcmVkZW50aWFsPiA9IHN1cGVyLnNpZ24obXNnLCBrYyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3JlZDpDcmVkZW50aWFsID0gU2VsZWN0Q3JlZGVudGlhbENsYXNzKHRoaXMub3BzW2ldLmdldE9wZXJhdGlvbigpLmdldENyZWRlbnRpYWxJRCgpKTtcbiAgICAgIGNvbnN0IHNpZ2lkeHM6QXJyYXk8U2lnSWR4PiA9IHRoaXMub3BzW2ldLmdldE9wZXJhdGlvbigpLmdldFNpZ0lkeHMoKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2lnaWR4cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBrZXlwYWlyOkFWTUtleVBhaXIgPSBrYy5nZXRLZXkoc2lnaWR4c1tqXS5nZXRTb3VyY2UoKSk7XG4gICAgICAgIGNvbnN0IHNpZ252YWw6QnVmZmVyID0ga2V5cGFpci5zaWduKG1zZyk7XG4gICAgICAgIGNvbnN0IHNpZzpTaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKCk7XG4gICAgICAgIHNpZy5mcm9tQnVmZmVyKHNpZ252YWwpO1xuICAgICAgICBjcmVkLmFkZFNpZ25hdHVyZShzaWcpO1xuICAgICAgfVxuICAgICAgc2lncy5wdXNoKGNyZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc2lncztcbiAgfVxuXG4gIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBPcGVyYXRpb24gdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya2lkIE9wdGlvbmFsIG5ldHdvcmtpZCwgZGVmYXVsdCAzXG4gICAgICogQHBhcmFtIGJsb2NrY2hhaW5pZCBPcHRpb25hbCBibG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbCBhcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXNcbiAgICAgKiBAcGFyYW0gaW5zIE9wdGlvbmFsIGFycmF5IG9mIHRoZSBbW1RyYW5zZmVyYWJsZUlucHV0XV1zXG4gICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIG9wcyBBcnJheSBvZiBbW09wZXJhdGlvbl1dcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBuZXR3b3JraWQ6bnVtYmVyID0gMywgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLFxuICAgIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCwgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgb3BzOkFycmF5PFRyYW5zZmVyYWJsZU9wZXJhdGlvbj4gPSB1bmRlZmluZWRcbiAgKSB7XG4gICAgc3VwZXIobmV0d29ya2lkLCBibG9ja2NoYWluaWQsIG91dHMsIGlucywgbWVtbyk7XG4gICAgaWYgKHR5cGVvZiBvcHMgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkob3BzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEob3BzW2ldIGluc3RhbmNlb2YgVHJhbnNmZXJhYmxlT3BlcmF0aW9uKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIC0gT3BlcmF0aW9uVHguY29uc3RydWN0b3I6IGludmFsaWQgb3AgaW4gYXJyYXkgcGFyYW1ldGVyICdvcHMnXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9wcyA9IG9wcztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgSW1wb3J0IHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgSW1wb3J0VHggZXh0ZW5kcyBCYXNlVHgge1xuICBwcm90ZWN0ZWQgbnVtSW5zOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgcHJvdGVjdGVkIGltcG9ydEluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSBbXTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgW1tJbXBvcnRUeF1dXG4gICAgICovXG4gIGdldFR4VHlwZSgpOm51bWJlciB7XG4gICAgcmV0dXJuIEFWTUNvbnN0YW50cy5JTVBPUlRUWDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhbiBbW0ltcG9ydFR4XV0sIHBhcnNlcyBpdCwgcG9wdWxhdGVzIHRoZSBjbGFzcywgYW5kIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgW1tJbXBvcnRUeF1dIGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhIHJhdyBbW0ltcG9ydFR4XV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHJhdyBbW0ltcG9ydFR4XV1cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIGFzc3VtZSBub3QtY2hlY2tzdW1tZWRcbiAgICAgKi9cbiAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwLCBjb2RlY2lkOm51bWJlciA9IEFWTUNvbnN0YW50cy5MQVRFU1RDT0RFQyk6bnVtYmVyIHtcbiAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgIHRoaXMubnVtSW5zID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3QgbnVtSW5zOm51bWJlciA9IHRoaXMubnVtSW5zLnJlYWRVSW50MzJCRSgwKTtcbiAgICBmb3IgKGxldCBpOm51bWJlciA9IDA7IGkgPCBudW1JbnM7IGkrKykge1xuICAgICAgY29uc3QgYW5JbjpUcmFuc2ZlcmFibGVJbnB1dCA9IG5ldyBUcmFuc2ZlcmFibGVJbnB1dCgpO1xuICAgICAgb2Zmc2V0ID0gYW5Jbi5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgdGhpcy5pbXBvcnRJbnMucHVzaChhbkluKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbSW1wb3J0VHhdXS5cbiAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgIHRoaXMubnVtSW5zLndyaXRlVUludDMyQkUodGhpcy5pbXBvcnRJbnMubGVuZ3RoLCAwKTtcbiAgICAgIGxldCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbc3VwZXIudG9CdWZmZXIoKSwgdGhpcy5udW1JbnNdO1xuICAgICAgdGhpcy5pbXBvcnRJbnMgPSB0aGlzLmltcG9ydElucy5zb3J0KFRyYW5zZmVyYWJsZUlucHV0LmNvbXBhcmF0b3IoKSk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5pbXBvcnRJbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBiYXJyLnB1c2godGhpcy5pbXBvcnRJbnNbaV0udG9CdWZmZXIoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChiYXJyKTtcbiAgfVxuICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXMgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgZ2V0SW1wb3J0SW5wdXRzKCk6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+IHtcbiAgICByZXR1cm4gdGhpcy5pbXBvcnRJbnM7XG4gIH1cblxuICAvKipcbiAgICAgKiBUYWtlcyB0aGUgYnl0ZXMgb2YgYW4gW1tVbnNpZ25lZFR4XV0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgW1tDcmVkZW50aWFsXV1zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbXNnIEEgQnVmZmVyIGZvciB0aGUgW1tVbnNpZ25lZFR4XV1cbiAgICAgKiBAcGFyYW0ga2MgQW4gW1tBVk1LZXlDaGFpbl1dIHVzZWQgaW4gc2lnbmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgW1tDcmVkZW50aWFsXV1zXG4gICAgICovXG4gIHNpZ24obXNnOkJ1ZmZlciwga2M6QVZNS2V5Q2hhaW4pOkFycmF5PENyZWRlbnRpYWw+IHtcbiAgICBjb25zdCBzaWdzOkFycmF5PENyZWRlbnRpYWw+ID0gc3VwZXIuc2lnbihtc2csIGtjKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1wb3J0SW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjcmVkOkNyZWRlbnRpYWwgPSBTZWxlY3RDcmVkZW50aWFsQ2xhc3ModGhpcy5pbXBvcnRJbnNbaV0uZ2V0SW5wdXQoKS5nZXRDcmVkZW50aWFsSUQoKSk7XG4gICAgICBjb25zdCBzaWdpZHhzOkFycmF5PFNpZ0lkeD4gPSB0aGlzLmltcG9ydEluc1tpXS5nZXRJbnB1dCgpLmdldFNpZ0lkeHMoKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2lnaWR4cy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBrZXlwYWlyOkFWTUtleVBhaXIgPSBrYy5nZXRLZXkoc2lnaWR4c1tqXS5nZXRTb3VyY2UoKSk7XG4gICAgICAgIGNvbnN0IHNpZ252YWw6QnVmZmVyID0ga2V5cGFpci5zaWduKG1zZyk7XG4gICAgICAgIGNvbnN0IHNpZzpTaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKCk7XG4gICAgICAgIHNpZy5mcm9tQnVmZmVyKHNpZ252YWwpO1xuICAgICAgICBjcmVkLmFkZFNpZ25hdHVyZShzaWcpO1xuICAgICAgfVxuICAgICAgc2lncy5wdXNoKGNyZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc2lncztcbiAgfVxuXG4gIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBJbXBvcnQgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya2lkIE9wdGlvbmFsIG5ldHdvcmtpZCwgZGVmYXVsdCAzXG4gICAgICogQHBhcmFtIGJsb2NrY2hhaW5pZCBPcHRpb25hbCBibG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbCBhcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXNcbiAgICAgKiBAcGFyYW0gaW5zIE9wdGlvbmFsIGFycmF5IG9mIHRoZSBbW1RyYW5zZmVyYWJsZUlucHV0XV1zXG4gICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIGltcG9ydElucyBBcnJheSBvZiBbW1RyYW5zZmVyYWJsZUlucHV0XV1zIHVzZWQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIG5ldHdvcmtpZDpudW1iZXIgPSAzLCBibG9ja2NoYWluaWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyLCAxNiksXG4gICAgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkLCBpbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+ID0gdW5kZWZpbmVkLFxuICAgIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBpbXBvcnRJbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+ID0gdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8pO1xuICAgIGlmICh0eXBlb2YgaW1wb3J0SW5zICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheS5pc0FycmF5KGltcG9ydElucykpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1wb3J0SW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghKGltcG9ydEluc1tpXSBpbnN0YW5jZW9mIFRyYW5zZmVyYWJsZUlucHV0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIC0gSW1wb3J0VHguY29uc3RydWN0b3I6IGludmFsaWQgVHJhbnNmZXJhYmxlSW5wdXQgaW4gYXJyYXkgcGFyYW1ldGVyICdpbXBvcnRJbnMnXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmltcG9ydElucyA9IGltcG9ydElucztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgRXhwb3J0IHRyYW5zYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRXhwb3J0VHggZXh0ZW5kcyBCYXNlVHgge1xuICBwcm90ZWN0ZWQgbnVtT3V0czpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gIHByb3RlY3RlZCBleHBvcnRPdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSBbXTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgW1tFeHBvcnRUeF1dXG4gICAgICovXG4gIGdldFR4VHlwZSgpOm51bWJlciB7XG4gICAgcmV0dXJuIEFWTUNvbnN0YW50cy5FWFBPUlRUWDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhbiBbW0V4cG9ydFR4XV0sIHBhcnNlcyBpdCwgcG9wdWxhdGVzIHRoZSBjbGFzcywgYW5kIHJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgW1tFeHBvcnRUeF1dIGluIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhIHJhdyBbW0V4cG9ydFR4XV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHJhdyBbW0V4cG9ydFR4XV1cbiAgICAgKlxuICAgICAqIEByZW1hcmtzIGFzc3VtZSBub3QtY2hlY2tzdW1tZWRcbiAgICAgKi9cbiAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgIC8vIHRoaXMuY29kZWNpZC53cml0ZVVJbnQ4KG9mZnNldCwgMCk7XG4gICAgLy8gb2Zmc2V0ICs9IDY7XG4gICAgb2Zmc2V0ID0gc3VwZXIuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgICB0aGlzLm51bU91dHMgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyA0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBjb25zdCBudW1PdXRzOm51bWJlciA9IHRoaXMubnVtT3V0cy5yZWFkVUludDMyQkUoMCk7XG4gICAgZm9yIChsZXQgaTpudW1iZXIgPSAwOyBpIDwgbnVtT3V0czsgaSsrKSB7XG4gICAgICBjb25zdCBhbk91dDpUcmFuc2ZlcmFibGVPdXRwdXQgPSBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KCk7XG4gICAgICBvZmZzZXQgPSBhbk91dC5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgdGhpcy5leHBvcnRPdXRzLnB1c2goYW5PdXQpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBbW0V4cG9ydFR4XV0uXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgIHRoaXMubnVtT3V0cy53cml0ZVVJbnQzMkJFKHRoaXMuZXhwb3J0T3V0cy5sZW5ndGgsIDApO1xuICAgICAgbGV0IGJhcnI6QXJyYXk8QnVmZmVyPiA9IFtzdXBlci50b0J1ZmZlcigpLCB0aGlzLm51bU91dHNdO1xuICAgICAgdGhpcy5leHBvcnRPdXRzID0gdGhpcy5leHBvcnRPdXRzLnNvcnQoVHJhbnNmZXJhYmxlT3V0cHV0LmNvbXBhcmF0b3IoKSk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5leHBvcnRPdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYmFyci5wdXNoKHRoaXMuZXhwb3J0T3V0c1tpXS50b0J1ZmZlcigpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJhcnIpO1xuICB9XG4gIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgW1tUcmFuc2ZlcmFibGVPdXRwdXRdXXMgaW4gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgZ2V0RXhwb3J0T3V0cHV0cygpOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4ge1xuICAgIHJldHVybiB0aGlzLmV4cG9ydE91dHM7XG4gIH1cblxuICAvKipcbiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgRXhwb3J0IHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtpZCBPcHRpb25hbCBuZXR3b3JraWQsIGRlZmF1bHQgM1xuICAgICAqIEBwYXJhbSBibG9ja2NoYWluaWQgT3B0aW9uYWwgYmxvY2tjaGFpbmlkLCBkZWZhdWx0IEJ1ZmZlci5hbGxvYygzMiwgMTYpXG4gICAgICogQHBhcmFtIG91dHMgT3B0aW9uYWwgYXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICogQHBhcmFtIGlucyBPcHRpb25hbCBhcnJheSBvZiB0aGUgW1tUcmFuc2ZlcmFibGVJbnB1dF1dc1xuICAgICAqIEBwYXJhbSBleHBvcnRPdXRzIEFycmF5IG9mIFtbVHJhbnNmZXJhYmxlT3V0cHV0c11dcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBuZXR3b3JraWQ6bnVtYmVyID0gMywgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLFxuICAgIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCwgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHVuZGVmaW5lZCxcbiAgICBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgZXhwb3J0T3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8pO1xuICAgIGlmICh0eXBlb2YgZXhwb3J0T3V0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheShleHBvcnRPdXRzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBvcnRPdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghKGV4cG9ydE91dHNbaV0gaW5zdGFuY2VvZiBUcmFuc2ZlcmFibGVPdXRwdXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgLSBFeHBvcnRUeC5jb25zdHJ1Y3RvcjogaW52YWxpZCBUcmFuc2ZlcmFibGVPdXRwdXQgaW4gYXJyYXkgcGFyYW1ldGVyICdleHBvcnRPdXRzJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5leHBvcnRPdXRzID0gZXhwb3J0T3V0cztcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFVuc2lnbmVkVHgge1xuICBwcm90ZWN0ZWQgY29kZWNpZDpudW1iZXIgPSBBVk1Db25zdGFudHMuTEFURVNUQ09ERUM7XG4gIHByb3RlY3RlZCB0cmFuc2FjdGlvbjpCYXNlVHg7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ29kZWNJRCBhcyBhIG51bWJlclxuICAgICAqL1xuICAgIGdldENvZGVjSUQgPSAoKTpudW1iZXIgPT4gdGhpcy5jb2RlY2lkO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIENvZGVjSURcbiAgICAgICovXG4gICAgIGdldENvZGVjSURCdWZmZXIgPSAoKTpCdWZmZXIgPT4ge1xuICAgICAgIGxldCBjb2RlY0J1ZjpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMik7XG4gICAgICAgY29kZWNCdWYud3JpdGVVSW50MTZCRSh0aGlzLmNvZGVjaWQsIDApO1xuICAgICAgIHJldHVybiBjb2RlY0J1ZjtcbiAgICAgfSBcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dFRvdGFsIGFzIGEgQk4gXG4gICAgICovXG4gIGdldElucHV0VG90YWwgPSAoYXNzZXRJRDpCdWZmZXIpOkJOPT4ge1xuICAgIGNvbnN0IGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0SW5zKCk7XG4gICAgY29uc3QgYUlESGV4OnN0cmluZyA9IGFzc2V0SUQudG9TdHJpbmcoJ2hleCcpO1xuICAgIGxldCB0b3RhbDpCTiA9IG5ldyBCTigwKTtcblxuICAgIGZvcihsZXQgaTpudW1iZXIgPSAwOyBpIDwgaW5zLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IGlucHV0ID0gaW5zW2ldLmdldElucHV0KCkgYXMgQW1vdW50SW5wdXQ7IFxuXG4gICAgICAvLyBvbmx5IGNoZWNrIHNlY3BpbnB1dHNcbiAgICAgIGlmKGlucHV0LmdldElucHV0SUQoKSA9PT0gQVZNQ29uc3RhbnRzLlNFQ1BJTlBVVElEICYmIGFJREhleCA9PT0gaW5zW2ldLmdldEFzc2V0SUQoKS50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgdG90YWwgPSB0b3RhbC5hZGQoaW5wdXQuZ2V0QW1vdW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvdXRwdXRUb3RhbCBhcyBhIEJOXG4gICAgICovXG4gIGdldE91dHB1dFRvdGFsID0gKGFzc2V0SUQ6QnVmZmVyKTpCTiA9PiB7XG4gICAgY29uc3Qgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldE91dHMoKTtcbiAgICBjb25zdCBhSURIZXg6c3RyaW5nID0gYXNzZXRJRC50b1N0cmluZygnaGV4Jyk7XG4gICAgbGV0IHRvdGFsOkJOID0gbmV3IEJOKDApO1xuXG4gICAgZm9yKGxldCBpOm51bWJlciA9IDA7IGkgPCBvdXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHNbaV0uZ2V0T3V0cHV0KCkgYXMgQW1vdW50T3V0cHV0OyBcblxuICAgICAgLy8gb25seSBjaGVjayBzZWNwb3V0cHV0c1xuICAgICAgaWYob3V0cHV0LmdldE91dHB1dElEKCkgPT09IEFWTUNvbnN0YW50cy5TRUNQT1VUUFVUSUQgJiYgYUlESGV4ID09PSBvdXRzW2ldLmdldEFzc2V0SUQoKS50b1N0cmluZygnaGV4JykpIHtcbiAgICAgICAgdG90YWwgPSB0b3RhbC5hZGQob3V0cHV0LmdldEFtb3VudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ1cm5lZCB0b2tlbnMgYXMgYSBCTlxuICAgICAqL1xuICBnZXRCdXJuID0gKGFzc2V0SUQ6QnVmZmVyKTpCTiA9PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5wdXRUb3RhbChhc3NldElEKS5zdWIodGhpcy5nZXRPdXRwdXRUb3RhbChhc3NldElEKSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvblxuICAgICAqL1xuICBnZXRUcmFuc2FjdGlvbiA9ICgpOkJhc2VUeCA9PiB0aGlzLnRyYW5zYWN0aW9uO1xuXG4gIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0aGlzLmNvZGVjaWQgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyAyKS5yZWFkVUludDE2QkUoMCk7XG4gICAgb2Zmc2V0ICs9IDI7XG4gICAgY29uc3QgdHh0eXBlOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpLnJlYWRVSW50MzJCRSgwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gU2VsZWN0VHhDbGFzcyh0eHR5cGUpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gIH1cblxuICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgY29uc3QgY29kZWNpZDpCdWZmZXIgPSB0aGlzLmdldENvZGVjSURCdWZmZXIoKTtcbiAgICBjb25zdCB0eHR5cGU6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIHR4dHlwZS53cml0ZVVJbnQzMkJFKHRoaXMudHJhbnNhY3Rpb24uZ2V0VHhUeXBlKCksIDApO1xuICAgIGNvbnN0IGJhc2VidWZmID0gdGhpcy50cmFuc2FjdGlvbi50b0J1ZmZlcigpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtjb2RlY2lkLCB0eHR5cGUsIGJhc2VidWZmXSwgY29kZWNpZC5sZW5ndGggKyB0eHR5cGUubGVuZ3RoICsgYmFzZWJ1ZmYubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFNpZ25zIHRoaXMgW1tVbnNpZ25lZFR4XV0gYW5kIHJldHVybnMgc2lnbmVkIFtbVHhdXVxuICAgICAqXG4gICAgICogQHBhcmFtIGtjIEFuIFtbQVZNS2V5Q2hhaW5dXSB1c2VkIGluIHNpZ25pbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2lnbmVkIFtbVHhdXVxuICAgICAqL1xuICBzaWduKGtjOkFWTUtleUNoYWluKTpUeCB7XG4gICAgY29uc3QgdHhidWZmID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIGNvbnN0IG1zZzpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUodHhidWZmKS5kaWdlc3QoKSk7XG4gICAgY29uc3Qgc2lnczpBcnJheTxDcmVkZW50aWFsPiA9IHRoaXMudHJhbnNhY3Rpb24uc2lnbihtc2csIGtjKTtcbiAgICByZXR1cm4gbmV3IFR4KHRoaXMsIHNpZ3MpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodHJhbnNhY3Rpb246QmFzZVR4ID0gdW5kZWZpbmVkLCBjb2RlY2lkOm51bWJlciA9IEFWTUNvbnN0YW50cy5MQVRFU1RDT0RFQykge1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFR4IHtcbiAgcHJvdGVjdGVkIHVuc2lnbmVkVHg6VW5zaWduZWRUeCA9IG5ldyBVbnNpZ25lZFR4KCk7XG4gIHByb3RlY3RlZCBjcmVkZW50aWFsczpBcnJheTxDcmVkZW50aWFsPiA9IFtdO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFtbVW5zaWduZWRUeF1dXG4gICAgICovXG4gIGdldFVuc2lnbmVkVHggPSAoKTpVbnNpZ25lZFR4ID0+IHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZFR4O1xuICB9XG5cbiAgLyoqXG4gICAgICogVGFrZXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIGFuIFtbVHhdXSwgcGFyc2VzIGl0LCBwb3B1bGF0ZXMgdGhlIGNsYXNzLCBhbmQgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBUeCBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgYSByYXcgW1tUeF1dXG4gICAgICogQHBhcmFtIG9mZnNldCBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBieXRlcyB0byBiZWdpbiBwYXJzaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSByYXcgW1tUeF1dXG4gICAgICovXG4gIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0aGlzLnVuc2lnbmVkVHggPSBuZXcgVW5zaWduZWRUeCgpO1xuICAgIG9mZnNldCA9IHRoaXMudW5zaWduZWRUeC5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgIGNvbnN0IG51bWNyZWRzOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpLnJlYWRVSW50MzJCRSgwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1jcmVkczsgaSsrKSB7XG4gICAgICBjb25zdCBjcmVkaWQ6bnVtYmVyID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCkucmVhZFVJbnQzMkJFKDApO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBjb25zdCBjcmVkOkNyZWRlbnRpYWwgPSBTZWxlY3RDcmVkZW50aWFsQ2xhc3MoY3JlZGlkKTtcbiAgICAgIG9mZnNldCA9IGNyZWQuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMucHVzaChjcmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tUeF1dLlxuICAgICAqL1xuICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgY29uc3QgdHhidWZmOkJ1ZmZlciA9IHRoaXMudW5zaWduZWRUeC50b0J1ZmZlcigpO1xuICAgIGxldCBic2l6ZTpudW1iZXIgPSB0eGJ1ZmYubGVuZ3RoO1xuICAgIGNvbnN0IGNyZWRsZW46QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGNyZWRsZW4ud3JpdGVVSW50MzJCRSh0aGlzLmNyZWRlbnRpYWxzLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgYmFycjpBcnJheTxCdWZmZXI+ID0gW3R4YnVmZiwgY3JlZGxlbl07XG4gICAgYnNpemUgKz0gY3JlZGxlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNyZWRlbnRpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjcmVkaWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgY3JlZGlkLndyaXRlVUludDMyQkUodGhpcy5jcmVkZW50aWFsc1tpXS5nZXRDcmVkZW50aWFsSUQoKSwgMCk7XG4gICAgICBiYXJyLnB1c2goY3JlZGlkKTtcbiAgICAgIGJzaXplICs9IGNyZWRpZC5sZW5ndGg7XG4gICAgICBjb25zdCBjcmVkYnVmZjpCdWZmZXIgPSB0aGlzLmNyZWRlbnRpYWxzW2ldLnRvQnVmZmVyKCk7XG4gICAgICBic2l6ZSArPSBjcmVkYnVmZi5sZW5ndGg7XG4gICAgICBiYXJyLnB1c2goY3JlZGJ1ZmYpO1xuICAgIH1cbiAgICBjb25zdCBidWZmOkJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoYmFyciwgYnNpemUpO1xuICAgIHJldHVybiBidWZmO1xuICB9XG5cbiAgLyoqXG4gICAgICogVGFrZXMgYSBiYXNlLTU4IHN0cmluZyBjb250YWluaW5nIGFuIFtbVHhdXSwgcGFyc2VzIGl0LCBwb3B1bGF0ZXMgdGhlIGNsYXNzLCBhbmQgcmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBUeCBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJpYWxpemVkIEEgYmFzZS01OCBzdHJpbmcgY29udGFpbmluZyBhIHJhdyBbW1R4XV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsZW5ndGggb2YgdGhlIHJhdyBbW1R4XV1cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogdW5saWtlIG1vc3QgZnJvbVN0cmluZ3MsIGl0IGV4cGVjdHMgdGhlIHN0cmluZyB0byBiZSBzZXJpYWxpemVkIGluIGNiNTggZm9ybWF0XG4gICAgICovXG4gIGZyb21TdHJpbmcoc2VyaWFsaXplZDpzdHJpbmcpOm51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUJ1ZmZlcihiaW50b29scy5jYjU4RGVjb2RlKHNlcmlhbGl6ZWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSBiYXNlLTU4IEFWQVgtc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tUeF1dLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiB1bmxpa2UgbW9zdCB0b1N0cmluZ3MsIHRoaXMgcmV0dXJucyBpbiBjYjU4IHNlcmlhbGl6YXRpb24gZm9ybWF0XG4gICAgICovXG4gIHRvU3RyaW5nKCk6c3RyaW5nIHtcbiAgICByZXR1cm4gYmludG9vbHMuY2I1OEVuY29kZSh0aGlzLnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2lnbmVkIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVuc2lnbmVkVHggT3B0aW9uYWwgW1tVbnNpZ25lZFR4XV1cbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlcyBPcHRpb25hbCBhcnJheSBvZiBbW0NyZWRlbnRpYWxdXXNcbiAgICAgKi9cbiAgY29uc3RydWN0b3IodW5zaWduZWRUeDpVbnNpZ25lZFR4ID0gdW5kZWZpbmVkLCBjcmVkZW50aWFsczpBcnJheTxDcmVkZW50aWFsPiA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgdW5zaWduZWRUeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudW5zaWduZWRUeCA9IHVuc2lnbmVkVHg7XG4gICAgICBpZiAodHlwZW9mIGNyZWRlbnRpYWxzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYSBidWZmZXIgcmVwcmVzZW50aW5nIHRoZSBvdXRwdXQgYW5kIHJldHVybnMgdGhlIHByb3BlciBbW0Jhc2VUeF1dIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB0eHR5cGUgVGhlIGlkIG9mIHRoZSB0cmFuc2FjdGlvbiB0eXBlXG4gKlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYW4gW1tCYXNlVHhdXS1leHRlbmRlZCBjbGFzcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFNlbGVjdFR4Q2xhc3MgPSAodHh0eXBlOm51bWJlciwgLi4uYXJnczpBcnJheTxhbnk+KTpCYXNlVHggPT4ge1xuICBpZiAodHh0eXBlID09PSBBVk1Db25zdGFudHMuQkFTRVRYKSB7XG4gICAgY29uc3QgdHg6QmFzZVR4ID0gbmV3IEJhc2VUeCguLi5hcmdzKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gZWxzZSBpZiAodHh0eXBlID09PSBBVk1Db25zdGFudHMuQ1JFQVRFQVNTRVRUWCkge1xuICAgIGNvbnN0IHR4OkNyZWF0ZUFzc2V0VHggPSBuZXcgQ3JlYXRlQXNzZXRUeCguLi5hcmdzKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gZWxzZSBpZiAodHh0eXBlID09PSBBVk1Db25zdGFudHMuT1BFUkFUSU9OVFgpIHtcbiAgICBjb25zdCB0eDpPcGVyYXRpb25UeCA9IG5ldyBPcGVyYXRpb25UeCguLi5hcmdzKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gZWxzZSBpZiAodHh0eXBlID09PSBBVk1Db25zdGFudHMuSU1QT1JUVFgpIHtcbiAgICBjb25zdCB0eDpJbXBvcnRUeCA9IG5ldyBJbXBvcnRUeCguLi5hcmdzKTtcbiAgICByZXR1cm4gdHg7XG4gIH0gZWxzZSBpZiAodHh0eXBlID09PSBBVk1Db25zdGFudHMuRVhQT1JUVFgpIHtcbiAgICBjb25zdCB0eDpFeHBvcnRUeCA9IG5ldyBFeHBvcnRUeCguLi5hcmdzKTtcbiAgICByZXR1cm4gdHg7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciAtIFNlbGVjdFR4Q2xhc3M6IHVua25vd24gdHh0eXBlICR7dHh0eXBlfWApO1xufTtcbiJdfQ==