"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SecpInput = exports.AmountInput = exports.TransferableInput = exports.Input = exports.SelectInputClass = void 0;
/**
 * @packageDocumentation
 * @module AVMAPI-Inputs
 */
const buffer_1 = require("buffer/");
const bn_js_1 = __importDefault(require("bn.js"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const types_1 = require("./types");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Takes a buffer representing the output and returns the proper [[Input]] instance.
 *
 * @param inputid A number representing the inputID parsed prior to the bytes passed in
 *
 * @returns An instance of an [[Input]]-extended class.
 */
exports.SelectInputClass = (inputid, ...args) => {
    if (inputid === types_1.AVMConstants.SECPINPUTID) {
        const secpin = new SecpInput(...args);
        return secpin;
    }
    /* istanbul ignore next */
    throw new Error(`Error - SelectInputClass: unknown inputid ${inputid}`);
};
class Input {
    constructor() {
        this.sigCount = buffer_1.Buffer.alloc(4);
        this.sigIdxs = []; // idxs of signers from utxo
        /**
           * Returns the array of [[SigIdx]] for this [[Input]]
           */
        this.getSigIdxs = () => this.sigIdxs;
        this.getCredentialID = () => types_1.AVMConstants.SECPCREDENTIAL;
        /**
           * Creates and adds a [[SigIdx]] to the [[Input]].
           *
           * @param addressIdx The index of the address to reference in the signatures
           * @param address The address of the source of the signature
           */
        this.addSignatureIdx = (addressIdx, address) => {
            const sigidx = new types_1.SigIdx();
            const b = buffer_1.Buffer.alloc(4);
            b.writeUInt32BE(addressIdx, 0);
            sigidx.fromBuffer(b);
            sigidx.setSource(address);
            this.sigIdxs.push(sigidx);
            this.sigCount.writeUInt32BE(this.sigIdxs.length, 0);
        };
    }
    fromBuffer(bytes, offset = 0) {
        this.sigCount = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const sigCount = this.sigCount.readUInt32BE(0);
        this.sigIdxs = [];
        for (let i = 0; i < sigCount; i++) {
            const sigidx = new types_1.SigIdx();
            const sigbuff = bintools.copyFrom(bytes, offset, offset + 4);
            sigidx.fromBuffer(sigbuff);
            offset += 4;
            this.sigIdxs.push(sigidx);
        }
        return offset;
    }
    toBuffer() {
        this.sigCount.writeUInt32BE(this.sigIdxs.length, 0);
        let bsize = this.sigCount.length;
        const barr = [this.sigCount];
        for (let i = 0; i < this.sigIdxs.length; i++) {
            const b = this.sigIdxs[i].toBuffer();
            barr.push(b);
            bsize += b.length;
        }
        return buffer_1.Buffer.concat(barr, bsize);
    }
    /**
       * Returns a base-58 representation of the [[Input]].
       */
    toString() {
        return bintools.bufferToB58(this.toBuffer());
    }
}
exports.Input = Input;
Input.comparator = () => (a, b) => {
    const aoutid = buffer_1.Buffer.alloc(4);
    aoutid.writeUInt32BE(a.getInputID(), 0);
    const abuff = a.toBuffer();
    const boutid = buffer_1.Buffer.alloc(4);
    boutid.writeUInt32BE(b.getInputID(), 0);
    const bbuff = b.toBuffer();
    const asort = buffer_1.Buffer.concat([aoutid, abuff], aoutid.length + abuff.length);
    const bsort = buffer_1.Buffer.concat([boutid, bbuff], boutid.length + bbuff.length);
    return buffer_1.Buffer.compare(asort, bsort);
};
class TransferableInput {
    /**
       * Class representing an [[TransferableInput]] for a transaction.
       *
       * @param txid A {@link https://github.com/feross/buffer|Buffer} containing the transaction ID of the referenced UTXO
       * @param outputidx A {@link https://github.com/feross/buffer|Buffer} containing the index of the output in the transaction consumed in the [[TransferableInput]]
       * @param assetID A {@link https://github.com/feross/buffer|Buffer} representing the assetID of the [[Input]]
       * @param input An [[Input]] to be made transferable
       */
    constructor(txid = undefined, outputidx = undefined, assetID = undefined, input = undefined) {
        this.txid = buffer_1.Buffer.alloc(32);
        this.outputidx = buffer_1.Buffer.alloc(4);
        this.assetid = buffer_1.Buffer.alloc(32);
        /**
           * Returns a {@link https://github.com/feross/buffer|Buffer} of the TxID.
           */
        this.getTxID = () => this.txid;
        /**
           * Returns a {@link https://github.com/feross/buffer|Buffer}  of the OutputIdx.
           */
        this.getOutputIdx = () => this.outputidx;
        /**
           * Returns a base-58 string representation of the UTXOID this [[TransferableInput]] references.
           */
        this.getUTXOID = () => bintools.bufferToB58(buffer_1.Buffer.concat([this.txid, this.outputidx]));
        /**
           * Returns the input.
           */
        this.getInput = () => this.input;
        /**
           * Returns the assetID of the input.
           */
        this.getAssetID = () => this.assetid;
        if (typeof txid !== 'undefined' && typeof outputidx !== 'undefined' && typeof assetID !== 'undefined' && input instanceof Input) {
            this.input = input;
            this.txid = txid;
            this.outputidx = outputidx;
            this.assetid = assetID;
        }
    }
    /**
       * Takes a {@link https://github.com/feross/buffer|Buffer} containing an [[TransferableInput]], parses it, populates the class, and returns the length of the [[TransferableInput]] in bytes.
       *
       * @param bytes A {@link https://github.com/feross/buffer|Buffer} containing a raw [[TransferableInput]]
       *
       * @returns The length of the raw [[TransferableInput]]
       */
    fromBuffer(bytes, offset = 0) {
        this.txid = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        this.outputidx = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.assetid = bintools.copyFrom(bytes, offset, offset + types_1.AVMConstants.ASSETIDLEN);
        offset += 32;
        const inputid = bintools.copyFrom(bytes, offset, offset + 4).readUInt32BE(0);
        offset += 4;
        this.input = exports.SelectInputClass(inputid);
        return this.input.fromBuffer(bytes, offset);
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[TransferableInput]].
       */
    toBuffer() {
        const inbuff = this.input.toBuffer();
        const inputid = buffer_1.Buffer.alloc(4);
        inputid.writeInt32BE(this.input.getInputID(), 0);
        const bsize = this.txid.length + this.outputidx.length + this.assetid.length + inputid.length + inbuff.length;
        const barr = [this.txid, this.outputidx, this.assetid, inputid, inbuff];
        const buff = buffer_1.Buffer.concat(barr, bsize);
        return buff;
    }
    /**
       * Returns a base-58 representation of the [[TransferableInput]].
       */
    toString() {
        /* istanbul ignore next */
        return bintools.bufferToB58(this.toBuffer());
    }
}
exports.TransferableInput = TransferableInput;
/**
   * Returns a function used to sort an array of [[TransferableInput]]s
   */
TransferableInput.comparator = () => (a, b) => {
    const sorta = buffer_1.Buffer.concat([a.getTxID(), a.getOutputIdx()]);
    const sortb = buffer_1.Buffer.concat([b.getTxID(), b.getOutputIdx()]);
    return buffer_1.Buffer.compare(sorta, sortb);
};
/**
 * An [[Input]] class which specifies a token amount .
 */
class AmountInput extends Input {
    /**
       * An [[AmountInput]] class which issues a payment on an assetID.
       *
       * @param amount A {@link https://github.com/indutny/bn.js/|BN} representing the amount in the input
       */
    constructor(amount = undefined) {
        super();
        this.amount = buffer_1.Buffer.alloc(8);
        this.amountValue = new bn_js_1.default(0);
        /**
           * Returns the amount as a {@link https://github.com/indutny/bn.js/|BN}.
           */
        this.getAmount = () => this.amountValue.clone();
        if (amount) {
            this.amountValue = amount.clone();
            this.amount = bintools.fromBNToBuffer(amount, 8);
        }
    }
    /**
       * Popuates the instance from a {@link https://github.com/feross/buffer|Buffer} representing the [[AmountInput]] and returns the size of the output.
       */
    fromBuffer(bytes, offset = 0) {
        this.amount = bintools.copyFrom(bytes, offset, offset + 8);
        this.amountValue = bintools.fromBufferToBN(this.amount);
        offset += 8;
        return super.fromBuffer(bytes, offset);
    }
    /**
       * Returns the buffer representing the [[AmountInput]] instance.
       */
    toBuffer() {
        const superbuff = super.toBuffer();
        const bsize = this.amount.length + superbuff.length;
        const barr = [this.amount, superbuff];
        return buffer_1.Buffer.concat(barr, bsize);
    }
}
exports.AmountInput = AmountInput;
class SecpInput extends AmountInput {
    /**
       * Returns the inputID for this input
       */
    getInputID() {
        return types_1.AVMConstants.SECPINPUTID;
    }
}
exports.SecpInput = SecpInput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvYXZtL2lucHV0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0dBR0c7QUFDSCxvQ0FBaUM7QUFDakMsa0RBQXVCO0FBQ3ZCLG9FQUE0QztBQUM1QyxtQ0FBK0M7QUFFL0M7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRXhDOzs7Ozs7R0FNRztBQUNVLFFBQUEsZ0JBQWdCLEdBQUcsQ0FBQyxPQUFjLEVBQUUsR0FBRyxJQUFlLEVBQVEsRUFBRTtJQUMzRSxJQUFJLE9BQU8sS0FBSyxvQkFBWSxDQUFDLFdBQVcsRUFBRTtRQUN4QyxNQUFNLE1BQU0sR0FBYSxJQUFJLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1FBQ2hELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFDRCwwQkFBMEI7SUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsT0FBTyxFQUFFLENBQUMsQ0FBQztBQUMxRSxDQUFDLENBQUM7QUFFRixNQUFzQixLQUFLO0lBOEV6QjtRQTdFVSxhQUFRLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVsQyxZQUFPLEdBQWlCLEVBQUUsQ0FBQyxDQUFDLDRCQUE0QjtRQUlsRTs7YUFFSztRQUNMLGVBQVUsR0FBRyxHQUFpQixFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUU5QyxvQkFBZSxHQUFHLEdBQVUsRUFBRSxDQUFDLG9CQUFZLENBQUMsY0FBYyxDQUFDO1FBRTNEOzs7OzthQUtLO1FBQ0wsb0JBQWUsR0FBRyxDQUFDLFVBQWlCLEVBQUUsT0FBYyxFQUFFLEVBQUU7WUFDdEQsTUFBTSxNQUFNLEdBQVUsSUFBSSxjQUFNLEVBQUUsQ0FBQztZQUNuQyxNQUFNLENBQUMsR0FBVSxlQUFNLENBQUMsS0FBSyxDQUFDLENB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QUFFLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3hELE1BQU0sSUFBSSxDQUFDLENBQUM7UUFDWixPQUFPLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7U0FFSztJQUNMLFFBQVE7UUFDTixNQUFNLFNBQVMsR0FBVSxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDMUMsTUFBTSxLQUFLLEdBQVUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztRQUMzRCxNQUFNLElBQUksR0FBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ3BELE9BQU8sZUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQztDQWNGO0FBMUNELGtDQTBDQztBQUVELE1BQWEsU0FBVSxTQUFRLFdBQVc7SUFDeEM7O1NBRUs7SUFDTCxVQUFVO1FBQ1IsT0FBTyxvQkFBWSxDQUFDLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0NBQ0Y7QUFQRCw4QkFPQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEFWTUFQSS1JbnB1dHNcbiAqL1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyLyc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IEJpblRvb2xzIGZyb20gJy4uLy4uL3V0aWxzL2JpbnRvb2xzJztcbmltcG9ydCB7IFNpZ0lkeCwgQVZNQ29uc3RhbnRzIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29scyA9IEJpblRvb2xzLmdldEluc3RhbmNlKCk7XG5cbi8qKlxuICogVGFrZXMgYSBidWZmZXIgcmVwcmVzZW50aW5nIHRoZSBvdXRwdXQgYW5kIHJldHVybnMgdGhlIHByb3BlciBbW0lucHV0XV0gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGlucHV0aWQgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBpbnB1dElEIHBhcnNlZCBwcmlvciB0byB0aGUgYnl0ZXMgcGFzc2VkIGluXG4gKlxuICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgYW4gW1tJbnB1dF1dLWV4dGVuZGVkIGNsYXNzLlxuICovXG5leHBvcnQgY29uc3QgU2VsZWN0SW5wdXRDbGFzcyA9IChpbnB1dGlkOm51bWJlciwgLi4uYXJnczpBcnJheTxhbnk+KTpJbnB1dCA9PiB7XG4gIGlmIChpbnB1dGlkID09PSBBVk1Db25zdGFudHMuU0VDUElOUFVUSUQpIHtcbiAgICBjb25zdCBzZWNwaW46U2VjcElucHV0ID0gbmV3IFNlY3BJbnB1dCguLi5hcmdzKTtcbiAgICByZXR1cm4gc2VjcGluO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHRocm93IG5ldyBFcnJvcihgRXJyb3IgLSBTZWxlY3RJbnB1dENsYXNzOiB1bmtub3duIGlucHV0aWQgJHtpbnB1dGlkfWApO1xufTtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIElucHV0IHtcbiAgcHJvdGVjdGVkIHNpZ0NvdW50OkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuICBwcm90ZWN0ZWQgc2lnSWR4czpBcnJheTxTaWdJZHg+ID0gW107IC8vIGlkeHMgb2Ygc2lnbmVycyBmcm9tIHV0eG9cblxuICBhYnN0cmFjdCBnZXRJbnB1dElEKCk6bnVtYmVyO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIFtbU2lnSWR4XV0gZm9yIHRoaXMgW1tJbnB1dF1dXG4gICAgICovXG4gIGdldFNpZ0lkeHMgPSAoKTpBcnJheTxTaWdJZHg+ID0+IHRoaXMuc2lnSWR4cztcblxuICBnZXRDcmVkZW50aWFsSUQgPSAoKTpudW1iZXIgPT4gQVZNQ29uc3RhbnRzLlNFQ1BDUkVERU5USUFMO1xuXG4gIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgYSBbW1NpZ0lkeF1dIHRvIHRoZSBbW0lucHV0XV0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkeCBUaGUgaW5kZXggb2YgdGhlIGFkZHJlc3MgdG8gcmVmZXJlbmNlIGluIHRoZSBzaWduYXR1cmVzXG4gICAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIHNvdXJjZSBvZiB0aGUgc2lnbmF0dXJlXG4gICAgICovXG4gIGFkZFNpZ25hdHVyZUlkeCA9IChhZGRyZXNzSWR4Om51bWJlciwgYWRkcmVzczpCdWZmZXIpID0+IHtcbiAgICBjb25zdCBzaWdpZHg6U2lnSWR4ID0gbmV3IFNpZ0lkeCgpO1xuICAgIGNvbnN0IGI6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGIud3JpdGVVSW50MzJCRShhZGRyZXNzSWR4LCAwKTtcbiAgICBzaWdpZHguZnJvbUJ1ZmZlcihiKTtcbiAgICBzaWdpZHguc2V0U291cmNlKGFkZHJlc3MpO1xuICAgIHRoaXMuc2lnSWR4cy5wdXNoKHNpZ2lkeCk7XG4gICAgdGhpcy5zaWdDb3VudC53cml0ZVVJbnQzMkJFKHRoaXMuc2lnSWR4cy5sZW5ndGgsIDApO1xuICB9O1xuXG4gIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0aGlzLnNpZ0NvdW50ID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgY29uc3Qgc2lnQ291bnQ6bnVtYmVyID0gdGhpcy5zaWdDb3VudC5yZWFkVUludDMyQkUoMCk7XG4gICAgdGhpcy5zaWdJZHhzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWdpZHggPSBuZXcgU2lnSWR4KCk7XG4gICAgICBjb25zdCBzaWdidWZmOkJ1ZmZlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpO1xuICAgICAgc2lnaWR4LmZyb21CdWZmZXIoc2lnYnVmZik7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIHRoaXMuc2lnSWR4cy5wdXNoKHNpZ2lkeCk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgdGhpcy5zaWdDb3VudC53cml0ZVVJbnQzMkJFKHRoaXMuc2lnSWR4cy5sZW5ndGgsIDApO1xuICAgIGxldCBic2l6ZTpudW1iZXIgPSB0aGlzLnNpZ0NvdW50Lmxlbmd0aDtcbiAgICBjb25zdCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbdGhpcy5zaWdDb3VudF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpZ0lkeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGI6QnVmZmVyID0gdGhpcy5zaWdJZHhzW2ldLnRvQnVmZmVyKCk7XG4gICAgICBiYXJyLnB1c2goYik7XG4gICAgICBic2l6ZSArPSBiLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmFyciwgYnNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbSW5wdXRdXS5cbiAgICAgKi9cbiAgdG9TdHJpbmcoKTpzdHJpbmcge1xuICAgIHJldHVybiBiaW50b29scy5idWZmZXJUb0I1OCh0aGlzLnRvQnVmZmVyKCkpO1xuICB9XG5cbiAgc3RhdGljIGNvbXBhcmF0b3IgPSAoKTooYTpJbnB1dCwgYjpJbnB1dCkgPT4gKDF8LTF8MCkgPT4gKGE6SW5wdXQsIGI6SW5wdXQpOigxfC0xfDApID0+IHtcbiAgICBjb25zdCBhb3V0aWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGFvdXRpZC53cml0ZVVJbnQzMkJFKGEuZ2V0SW5wdXRJRCgpLCAwKTtcbiAgICBjb25zdCBhYnVmZjpCdWZmZXIgPSBhLnRvQnVmZmVyKCk7XG5cbiAgICBjb25zdCBib3V0aWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGJvdXRpZC53cml0ZVVJbnQzMkJFKGIuZ2V0SW5wdXRJRCgpLCAwKTtcbiAgICBjb25zdCBiYnVmZjpCdWZmZXIgPSBiLnRvQnVmZmVyKCk7XG5cbiAgICBjb25zdCBhc29ydDpCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFthb3V0aWQsIGFidWZmXSwgYW91dGlkLmxlbmd0aCArIGFidWZmLmxlbmd0aCk7XG4gICAgY29uc3QgYnNvcnQ6QnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYm91dGlkLCBiYnVmZl0sIGJvdXRpZC5sZW5ndGggKyBiYnVmZi5sZW5ndGgpO1xuICAgIHJldHVybiBCdWZmZXIuY29tcGFyZShhc29ydCwgYnNvcnQpIGFzICgxfC0xfDApO1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKCkge31cbn1cblxuZXhwb3J0IGNsYXNzIFRyYW5zZmVyYWJsZUlucHV0IHtcbiAgcHJvdGVjdGVkIHR4aWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyKTtcblxuICBwcm90ZWN0ZWQgb3V0cHV0aWR4OkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuICBwcm90ZWN0ZWQgYXNzZXRpZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIpO1xuXG4gIHByb3RlY3RlZCBpbnB1dDpJbnB1dDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdXNlZCB0byBzb3J0IGFuIGFycmF5IG9mIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXNcbiAgICAgKi9cbiAgc3RhdGljIGNvbXBhcmF0b3IgPSAoKTooYTpUcmFuc2ZlcmFibGVJbnB1dCwgYjpUcmFuc2ZlcmFibGVJbnB1dCkgPT4gKDF8LTF8MCkgPT4gKGE6VHJhbnNmZXJhYmxlSW5wdXQsIGI6VHJhbnNmZXJhYmxlSW5wdXQpOigxfC0xfDApID0+IHtcbiAgICBjb25zdCBzb3J0YSA9IEJ1ZmZlci5jb25jYXQoW2EuZ2V0VHhJRCgpLCBhLmdldE91dHB1dElkeCgpXSk7XG4gICAgY29uc3Qgc29ydGIgPSBCdWZmZXIuY29uY2F0KFtiLmdldFR4SUQoKSwgYi5nZXRPdXRwdXRJZHgoKV0pO1xuICAgIHJldHVybiBCdWZmZXIuY29tcGFyZShzb3J0YSwgc29ydGIpIGFzICgxfC0xfDApO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvZiB0aGUgVHhJRC5cbiAgICAgKi9cbiAgZ2V0VHhJRCA9ICgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIDpCdWZmZXIgPT4gdGhpcy50eGlkO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSAgb2YgdGhlIE91dHB1dElkeC5cbiAgICAgKi9cbiAgZ2V0T3V0cHV0SWR4ID0gKClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgOkJ1ZmZlciA9PiB0aGlzLm91dHB1dGlkeDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYmFzZS01OCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVUWE9JRCB0aGlzIFtbVHJhbnNmZXJhYmxlSW5wdXRdXSByZWZlcmVuY2VzLlxuICAgICAqL1xuICBnZXRVVFhPSUQgPSAoKTpzdHJpbmcgPT4gYmludG9vbHMuYnVmZmVyVG9CNTgoQnVmZmVyLmNvbmNhdChbdGhpcy50eGlkLCB0aGlzLm91dHB1dGlkeF0pKTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgZ2V0SW5wdXQgPSAoKTpJbnB1dCA9PiB0aGlzLmlucHV0O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFzc2V0SUQgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICBnZXRBc3NldElEID0gKCk6QnVmZmVyID0+IHRoaXMuYXNzZXRpZDtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgYW4gW1tUcmFuc2ZlcmFibGVJbnB1dF1dLCBwYXJzZXMgaXQsIHBvcHVsYXRlcyB0aGUgY2xhc3MsIGFuZCByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIFtbVHJhbnNmZXJhYmxlSW5wdXRdXSBpbiBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgYSByYXcgW1tUcmFuc2ZlcmFibGVJbnB1dF1dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSByYXcgW1tUcmFuc2ZlcmFibGVJbnB1dF1dXG4gICAgICovXG4gIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0aGlzLnR4aWQgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyAzMik7XG4gICAgb2Zmc2V0ICs9IDMyO1xuICAgIHRoaXMub3V0cHV0aWR4ID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgdGhpcy5hc3NldGlkID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgQVZNQ29uc3RhbnRzLkFTU0VUSURMRU4pO1xuICAgIG9mZnNldCArPSAzMjtcbiAgICBjb25zdCBpbnB1dGlkOm51bWJlciA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDQpLnJlYWRVSW50MzJCRSgwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICB0aGlzLmlucHV0ID0gU2VsZWN0SW5wdXRDbGFzcyhpbnB1dGlkKTtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBbW1RyYW5zZmVyYWJsZUlucHV0XV0uXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICBjb25zdCBpbmJ1ZmY6QnVmZmVyID0gdGhpcy5pbnB1dC50b0J1ZmZlcigpO1xuICAgIGNvbnN0IGlucHV0aWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGlucHV0aWQud3JpdGVJbnQzMkJFKHRoaXMuaW5wdXQuZ2V0SW5wdXRJRCgpLCAwKTtcbiAgICBjb25zdCBic2l6ZTpudW1iZXIgPSB0aGlzLnR4aWQubGVuZ3RoICsgdGhpcy5vdXRwdXRpZHgubGVuZ3RoICsgdGhpcy5hc3NldGlkLmxlbmd0aCArIGlucHV0aWQubGVuZ3RoICsgaW5idWZmLmxlbmd0aDtcbiAgICBjb25zdCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbdGhpcy50eGlkLCB0aGlzLm91dHB1dGlkeCwgdGhpcy5hc3NldGlkLCBpbnB1dGlkLCBpbmJ1ZmZdO1xuICAgIGNvbnN0IGJ1ZmY6IEJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoYmFyciwgYnNpemUpO1xuICAgIHJldHVybiBidWZmO1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbVHJhbnNmZXJhYmxlSW5wdXRdXS5cbiAgICAgKi9cbiAgdG9TdHJpbmcoKTpzdHJpbmcge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGJpbnRvb2xzLmJ1ZmZlclRvQjU4KHRoaXMudG9CdWZmZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gW1tUcmFuc2ZlcmFibGVJbnB1dF1dIGZvciBhIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR4aWQgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSB0cmFuc2FjdGlvbiBJRCBvZiB0aGUgcmVmZXJlbmNlZCBVVFhPXG4gICAgICogQHBhcmFtIG91dHB1dGlkeCBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgdGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgaW4gdGhlIHRyYW5zYWN0aW9uIGNvbnN1bWVkIGluIHRoZSBbW1RyYW5zZmVyYWJsZUlucHV0XV1cbiAgICAgKiBAcGFyYW0gYXNzZXRJRCBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgYXNzZXRJRCBvZiB0aGUgW1tJbnB1dF1dXG4gICAgICogQHBhcmFtIGlucHV0IEFuIFtbSW5wdXRdXSB0byBiZSBtYWRlIHRyYW5zZmVyYWJsZVxuICAgICAqL1xuICBjb25zdHJ1Y3Rvcih0eGlkOkJ1ZmZlciA9IHVuZGVmaW5lZCwgb3V0cHV0aWR4OkJ1ZmZlciA9IHVuZGVmaW5lZCwgYXNzZXRJRDpCdWZmZXIgPSB1bmRlZmluZWQsIGlucHV0OklucHV0ID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB0eGlkICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3V0cHV0aWR4ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYXNzZXRJRCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBJbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgdGhpcy50eGlkID0gdHhpZDtcbiAgICAgIHRoaXMub3V0cHV0aWR4ID0gb3V0cHV0aWR4O1xuICAgICAgdGhpcy5hc3NldGlkID0gYXNzZXRJRDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBbW0lucHV0XV0gY2xhc3Mgd2hpY2ggc3BlY2lmaWVzIGEgdG9rZW4gYW1vdW50IC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFtb3VudElucHV0IGV4dGVuZHMgSW5wdXQge1xuICBwcm90ZWN0ZWQgYW1vdW50OkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcblxuICBwcm90ZWN0ZWQgYW1vdW50VmFsdWU6Qk4gPSBuZXcgQk4oMCk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0uXG4gICAgICovXG4gIGdldEFtb3VudCA9ICgpOkJOID0+IHRoaXMuYW1vdW50VmFsdWUuY2xvbmUoKTtcblxuICAvKipcbiAgICAgKiBQb3B1YXRlcyB0aGUgaW5zdGFuY2UgZnJvbSBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHJlcHJlc2VudGluZyB0aGUgW1tBbW91bnRJbnB1dF1dIGFuZCByZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBvdXRwdXQuXG4gICAgICovXG4gIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0aGlzLmFtb3VudCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDgpO1xuICAgIHRoaXMuYW1vdW50VmFsdWUgPSBiaW50b29scy5mcm9tQnVmZmVyVG9CTih0aGlzLmFtb3VudCk7XG4gICAgb2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHN1cGVyLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBidWZmZXIgcmVwcmVzZW50aW5nIHRoZSBbW0Ftb3VudElucHV0XV0gaW5zdGFuY2UuXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICBjb25zdCBzdXBlcmJ1ZmY6QnVmZmVyID0gc3VwZXIudG9CdWZmZXIoKTtcbiAgICBjb25zdCBic2l6ZTpudW1iZXIgPSB0aGlzLmFtb3VudC5sZW5ndGggKyBzdXBlcmJ1ZmYubGVuZ3RoO1xuICAgIGNvbnN0IGJhcnI6QXJyYXk8QnVmZmVyPiA9IFt0aGlzLmFtb3VudCwgc3VwZXJidWZmXTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChiYXJyLCBic2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICAgKiBBbiBbW0Ftb3VudElucHV0XV0gY2xhc3Mgd2hpY2ggaXNzdWVzIGEgcGF5bWVudCBvbiBhbiBhc3NldElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcy98Qk59IHJlcHJlc2VudGluZyB0aGUgYW1vdW50IGluIHRoZSBpbnB1dFxuICAgICAqL1xuICBjb25zdHJ1Y3RvcihhbW91bnQ6Qk4gPSB1bmRlZmluZWQpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChhbW91bnQpIHtcbiAgICAgIHRoaXMuYW1vdW50VmFsdWUgPSBhbW91bnQuY2xvbmUoKTtcbiAgICAgIHRoaXMuYW1vdW50ID0gYmludG9vbHMuZnJvbUJOVG9CdWZmZXIoYW1vdW50LCA4KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNlY3BJbnB1dCBleHRlbmRzIEFtb3VudElucHV0IHtcbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5wdXRJRCBmb3IgdGhpcyBpbnB1dFxuICAgICAqL1xuICBnZXRJbnB1dElEKCk6bnVtYmVyIHtcbiAgICByZXR1cm4gQVZNQ29uc3RhbnRzLlNFQ1BJTlBVVElEO1xuICB9XG59XG4iXX0=