"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../utils/types");
/**
 * Class for interacting with a node's InfoAPI.
 *
 * @category RPCAPIs
 *
 * @remarks This extends the [[JRPCAPI]] class. This class should not be directly called. Instead, use the [[Avalanche.addAPI]] function to register this interface with Avalanche.
 */
class InfoAPI extends types_1.JRPCAPI {
    constructor(core, baseurl = '/ext/info') {
        super(core, baseurl);
        /**
           * Fetches the blockchainID from the node for a given alias.
           *
           * @param alias The blockchain alias to get the blockchainID
           *
           * @returns Returns a Promise<string> containing the base 58 string representation of the blockchainID.
           */
        this.getBlockchainID = (alias) => __awaiter(this, void 0, void 0, function* () {
            const params = {
                alias,
            };
            return this.callMethod('info.getBlockchainID', params)
                .then((response) => response.data.result.blockchainID);
        });
        /**
           * Fetches the networkID from the node.
           *
           * @returns Returns a Promise<number> of the networkID.
           */
        this.getNetworkID = () => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            return this.callMethod('info.getNetworkID', params)
                .then((response) => response.data.result.networkID);
        });
        /**
           * Fetches the network name this node is running on
           *
           * @returns Returns a Promise<string> containing the network name.
           */
        this.getNetworkName = () => __awaiter(this, void 0, void 0, function* () {
            return this.callMethod('info.getNetworkName')
                .then((response) => response.data.result.networkName);
        });
        /**
           * Fetches the nodeID from the node.
           *
           * @returns Returns a Promise<string> of the nodeID.
           */
        this.getNodeID = () => __awaiter(this, void 0, void 0, function* () {
            const params = {};
            return this.callMethod('info.getNodeID', params)
                .then((response) => response.data.result.nodeID);
        });
        /**
           * Fetches the version of Gecko this node is running
           *
           * @returns Returns a Promise<string> containing the version of Gecko.
           */
        this.getNodeVersion = () => __awaiter(this, void 0, void 0, function* () {
            return this.callMethod('info.getNodeVersion')
                .then((response) => response.data.result.version);
        });
        /**
           * Returns the peers connected to the node.
           *
           * @returns Promise for the list of connected peers in <ip>:<port> format.
           */
        this.peers = () => __awaiter(this, void 0, void 0, function* () {
            return this.callMethod('info.peers')
                .then((response) => response.data.result.peers);
        });
    }
}
exports.default = InfoAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvaW5mby9hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFLQSw2Q0FBaUU7QUFFakU7Ozs7OztHQU1HO0FBQ0gsTUFBcUIsT0FBUSxTQUFRLGVBQU87SUE4RDFDLFlBQVksSUFBa0IsRUFBRSxVQUFpQixXQUFXO1FBQUksS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztRQTdEckY7Ozs7OzthQU1LO1FBQ0wsb0JBQWUsR0FBRyxDQUFPLEtBQVksRUFBa0IsRUFBRTtZQUN2RCxNQUFNLE1BQU0sR0FBTztnQkFDakIsS0FBSzthQUNOLENBQUM7WUFDRixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLEVBQUUsTUFBTSxDQUFDO2lCQUNuRCxJQUFJLENBQUMsQ0FBQyxRQUE0QixFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUMvRSxDQUFDLENBQUEsQ0FBQztRQUVGOzs7O2FBSUs7UUFDTCxpQkFBWSxHQUFHLEdBQXlCLEVBQUU7WUFDeEMsTUFBTSxNQUFNLEdBQU8sRUFBRSxDQUFDO1lBQ3RCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRSxNQUFNLENBQUM7aUJBQ2hELElBQUksQ0FBQyxDQUFDLFFBQTRCLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzVFLENBQUMsQ0FBQSxDQUFDO1FBRUY7Ozs7YUFJSztRQUNMLG1CQUFjLEdBQUcsR0FBeUIsRUFBRTtZQUFDLE9BQUEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxxQkFBcUIsQ0FBQztpQkFDaEYsSUFBSSxDQUFDLENBQUMsUUFBNEIsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7VUFBQSxDQUFDO1FBRTVFOzs7O2FBSUs7UUFDTCxjQUFTLEdBQUcsR0FBeUIsRUFBRTtZQUNyQyxNQUFNLE1BQU0sR0FBTyxFQUFFLENBQUM7WUFDdEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixFQUFFLE1BQU0sQ0FBQztpQkFDN0MsSUFBSSxDQUFDLENBQUMsUUFBNEIsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekUsQ0FBQyxDQUFBLENBQUM7UUFFRjs7OzthQUlLO1FBQ0wsbUJBQWMsR0FBRyxHQUF5QixFQUFFO1lBQUMsT0FBQSxJQUFJLENBQUMsVUFBVSxDQUFDLHFCQUFxQixDQUFDO2lCQUNoRixJQUFJLENBQUMsQ0FBQyxRQUE0QixFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQTtVQUFBLENBQUM7UUFFeEU7Ozs7YUFJSztRQUNMLFVBQUssR0FBRyxHQUFnQyxFQUFFO1lBQUMsT0FBQSxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQztpQkFDckUsSUFBSSxDQUFDLENBQUMsUUFBNEIsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUE7VUFBQSxDQUFDO0lBRWdCLENBQUM7Q0FDeEY7QUEvREQsMEJBK0RDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgSW5mb0FQSVxuICovXG5pbXBvcnQgQXZhbGFuY2hlQ29yZSBmcm9tICcuLi8uLi9hdmFsYW5jaGUnO1xuaW1wb3J0IHsgSlJQQ0FQSSwgUmVxdWVzdFJlc3BvbnNlRGF0YSB9IGZyb20gJy4uLy4uL3V0aWxzL3R5cGVzJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhIG5vZGUncyBJbmZvQVBJLlxuICpcbiAqIEBjYXRlZ29yeSBSUENBUElzXG4gKlxuICogQHJlbWFya3MgVGhpcyBleHRlbmRzIHRoZSBbW0pSUENBUEldXSBjbGFzcy4gVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGRpcmVjdGx5IGNhbGxlZC4gSW5zdGVhZCwgdXNlIHRoZSBbW0F2YWxhbmNoZS5hZGRBUEldXSBmdW5jdGlvbiB0byByZWdpc3RlciB0aGlzIGludGVyZmFjZSB3aXRoIEF2YWxhbmNoZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mb0FQSSBleHRlbmRzIEpSUENBUEkge1xuICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBibG9ja2NoYWluSUQgZnJvbSB0aGUgbm9kZSBmb3IgYSBnaXZlbiBhbGlhcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbGlhcyBUaGUgYmxvY2tjaGFpbiBhbGlhcyB0byBnZXQgdGhlIGJsb2NrY2hhaW5JRFxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIFByb21pc2U8c3RyaW5nPiBjb250YWluaW5nIHRoZSBiYXNlIDU4IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmxvY2tjaGFpbklELlxuICAgICAqL1xuICBnZXRCbG9ja2NoYWluSUQgPSBhc3luYyAoYWxpYXM6c3RyaW5nKTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7XG4gICAgICBhbGlhcyxcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ2luZm8uZ2V0QmxvY2tjaGFpbklEJywgcGFyYW1zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LmJsb2NrY2hhaW5JRCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbmV0d29ya0lEIGZyb20gdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgUHJvbWlzZTxudW1iZXI+IG9mIHRoZSBuZXR3b3JrSUQuXG4gICAgICovXG4gIGdldE5ldHdvcmtJRCA9IGFzeW5jICgpOlByb21pc2U8bnVtYmVyPiA9PiB7XG4gICAgY29uc3QgcGFyYW1zOmFueSA9IHt9O1xuICAgIHJldHVybiB0aGlzLmNhbGxNZXRob2QoJ2luZm8uZ2V0TmV0d29ya0lEJywgcGFyYW1zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0Lm5ldHdvcmtJRCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgbmV0d29yayBuYW1lIHRoaXMgbm9kZSBpcyBydW5uaW5nIG9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgUHJvbWlzZTxzdHJpbmc+IGNvbnRhaW5pbmcgdGhlIG5ldHdvcmsgbmFtZS5cbiAgICAgKi9cbiAgZ2V0TmV0d29ya05hbWUgPSBhc3luYyAoKTpQcm9taXNlPHN0cmluZz4gPT4gdGhpcy5jYWxsTWV0aG9kKCdpbmZvLmdldE5ldHdvcmtOYW1lJylcbiAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQubmV0d29ya05hbWUpO1xuXG4gIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG5vZGVJRCBmcm9tIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIFByb21pc2U8c3RyaW5nPiBvZiB0aGUgbm9kZUlELlxuICAgICAqL1xuICBnZXROb2RlSUQgPSBhc3luYyAoKTpQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIGNvbnN0IHBhcmFtczphbnkgPSB7fTtcbiAgICByZXR1cm4gdGhpcy5jYWxsTWV0aG9kKCdpbmZvLmdldE5vZGVJRCcsIHBhcmFtcylcbiAgICAgIC50aGVuKChyZXNwb25zZTpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwb25zZS5kYXRhLnJlc3VsdC5ub2RlSUQpO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHZlcnNpb24gb2YgR2Vja28gdGhpcyBub2RlIGlzIHJ1bm5pbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgYSBQcm9taXNlPHN0cmluZz4gY29udGFpbmluZyB0aGUgdmVyc2lvbiBvZiBHZWNrby5cbiAgICAgKi9cbiAgZ2V0Tm9kZVZlcnNpb24gPSBhc3luYyAoKTpQcm9taXNlPHN0cmluZz4gPT4gdGhpcy5jYWxsTWV0aG9kKCdpbmZvLmdldE5vZGVWZXJzaW9uJylcbiAgICAudGhlbigocmVzcG9uc2U6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcG9uc2UuZGF0YS5yZXN1bHQudmVyc2lvbik7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGVlcnMgY29ubmVjdGVkIHRvIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBmb3IgdGhlIGxpc3Qgb2YgY29ubmVjdGVkIHBlZXJzIGluIDxpcD46PHBvcnQ+IGZvcm1hdC5cbiAgICAgKi9cbiAgcGVlcnMgPSBhc3luYyAoKTpQcm9taXNlPEFycmF5PHN0cmluZz4+ID0+IHRoaXMuY2FsbE1ldGhvZCgnaW5mby5wZWVycycpXG4gICAgLnRoZW4oKHJlc3BvbnNlOlJlcXVlc3RSZXNwb25zZURhdGEpID0+IHJlc3BvbnNlLmRhdGEucmVzdWx0LnBlZXJzKTtcblxuICBjb25zdHJ1Y3Rvcihjb3JlOkF2YWxhbmNoZUNvcmUsIGJhc2V1cmw6c3RyaW5nID0gJy9leHQvaW5mbycpIHsgc3VwZXIoY29yZSwgYmFzZXVybCk7IH1cbn1cbiJdfQ==