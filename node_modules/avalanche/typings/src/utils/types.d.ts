/// <reference types="node" />
/**
 * @packageDocumentation
 * @module Utils-Types
 */
import { Buffer } from 'buffer/';
import { StoreAPI } from 'store2';
import { ClientRequest } from 'http';
import AvalancheCore from '../avalanche';
/**
 * Response data for HTTP requests.
 */
export declare class RequestResponseData {
    data: any;
    headers: any;
    status: number;
    statusText: string;
    request: ClientRequest | XMLHttpRequest;
}
/**
 * Abstract class defining a generic endpoint that all endpoints must implement (extend).
 */
export declare abstract class APIBase {
    protected core: AvalancheCore;
    protected baseurl: string;
    protected db: StoreAPI;
    /**
       * Sets the path of the APIs baseurl.
       *
       * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
       */
    setBaseURL: (baseurl: string) => void;
    /**
       * Returns the baseurl's path.
       */
    getBaseURL: () => string;
    /**
       * Returns the baseurl's database.
       */
    getDB: () => StoreAPI;
    /**
       *
       * @param core Reference to the Avalanche instance using this baseurl
       * @param baseurl Path to the baseurl - ex: "/ext/bc/avm"
       */
    constructor(core: AvalancheCore, baseurl: string);
}
export declare class RESTAPI extends APIBase {
    protected contentType: string;
    protected acceptType: string;
    get: (baseurl?: string, contentType?: string, acceptType?: string) => Promise<RequestResponseData>;
    post: (method: string, params?: Array<object> | object, baseurl?: string, contentType?: string, acceptType?: string) => Promise<RequestResponseData>;
    put: (method: string, params?: Array<object> | object, baseurl?: string, contentType?: string, acceptType?: string) => Promise<RequestResponseData>;
    delete: (method: string, params?: Array<object> | object, baseurl?: string, contentType?: string, acceptType?: string) => Promise<RequestResponseData>;
    patch: (method: string, params?: Array<object> | object, baseurl?: string, contentType?: string, acceptType?: string) => Promise<RequestResponseData>;
    /**
       * Returns the type of the entity attached to the incoming request
       */
    getContentType: () => string;
    /**
       * Returns what type of representation is desired at the client side
       */
    getAcceptType: () => string;
    /**
       *
       * @param core Reference to the Avalanche instance using this endpoint
       * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
       * @param contentType Optional Determines the type of the entity attached to the
       * incoming request
       * @param acceptType Optional Determines the type of representation which is
       * desired on the client side
       */
    constructor(core: AvalancheCore, baseurl: string, contentType?: string, acceptType?: string);
}
export declare class JRPCAPI extends APIBase {
    protected jrpcVersion: string;
    protected rpcid: number;
    callMethod: (method: string, params?: Array<object> | object, baseurl?: string) => Promise<RequestResponseData>;
    /**
       * Returns the rpcid, a strictly-increasing number, starting from 1, indicating the next
       * request ID that will be sent.
       */
    getRPCID: () => number;
    /**
       *
       * @param core Reference to the Avalanche instance using this endpoint
       * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
       * @param jrpcVersion The jrpc version to use, default "2.0".
       */
    constructor(core: AvalancheCore, baseurl: string, jrpcVersion?: string);
}
/**
 * Class for representing a threshold and set of minting addresses in Avalanche.
 *
 * @typeparam MinterSet including a threshold and array of addresses
 */
export declare class MinterSet {
    protected threshold: number;
    protected minters: Array<Buffer>;
    /**
     * Returns the threshold.
     */
    getThreshold: () => number;
    /**
     * Returns the minters.
     */
    getMinters: () => Array<Buffer>;
    protected _cleanAddresses: (addresses: Array<string | Buffer>) => Array<Buffer>;
    /**
     *
     * @param threshold The number of signatures required to mint more of an asset by signing a minting transaction
     * @param minters Array of addresss which are authorized to sign a minting transaction
     */
    constructor(threshold: number, minters: Array<string | Buffer>);
}
/**
 * Class for representing a private and public keypair in Avalanche.
 * All APIs that need key pairs should extend on this class.
 */
export declare class KeyPair {
    protected pubk: Buffer;
    protected privk: Buffer;
    protected chainid: string;
    protected hrp: string;
    /**
       * Generates a new keypair.
       *
       * @param entropy Optional parameter that may be necessary to produce secure keys
       */
    generateKey: (entropy?: Buffer) => void;
    /**
       * Imports a private key and generates the appropriate public key.
       *
       * @param privk A {@link https://github.com/feross/buffer|Buffer} representing the private key
       *
       * @returns true on success, false on failure
       */
    importKey: (privk: Buffer) => boolean;
    /**
       * Takes a message, signs it, and returns the signature.
       *
       * @param msg The message to sign
       *
       * @returns A {@link https://github.com/feross/buffer|Buffer} containing the signature
       */
    sign: (msg: Buffer) => Buffer;
    /**
       * Recovers the public key of a message signer from a message and its associated signature.
       *
       * @param msg The message that's signed
       * @param sig The signature that's signed on the message
       *
       * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public
       * key of the signer
       */
    recover: (msg: Buffer, sig: Buffer) => Buffer;
    /**
       * Verifies that the private key associated with the provided public key produces the
       * signature associated with the given message.
       *
       * @param msg The message associated with the signature
       * @param sig The signature of the signed message
       * @param pubk The public key associated with the message signature
       *
       * @returns True on success, false on failure
       */
    verify: (msg: Buffer, sig: Buffer, pubk: Buffer) => boolean;
    /**
       * Returns a reference to the private key.
       *
       * @returns A {@link https://github.com/feross/buffer|Buffer} containing the private key
       */
    getPrivateKey: () => Buffer;
    /**
       * Returns a reference to the public key.
       *
       * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public key
       */
    getPublicKey: () => Buffer;
    /**
       * Returns a string representation of the private key.
       *
       * @returns A string representation of the public key
       */
    getPrivateKeyString: () => string;
    /**
       * Returns the public key.
       *
       * @returns A string representation of the public key
       */
    getPublicKeyString: () => string;
    /**
       * Returns the address.
       *
       * @returns A {@link https://github.com/feross/buffer|Buffer}  representation of the address
       */
    getAddress: () => Buffer;
    /**
       * Returns the address's string representation.
       *
       * @returns A string representation of the address
       */
    getAddressString: () => string;
    /**
       * Returns the chainID associated with this key.
       *
       * @returns The [[KeyPair]]'s chainID
       */
    getChainID: () => string;
    /**
       * Sets the the chainID associated with this key.
       *
       * @param chainid String for the chainID
       */
    setChainID: (chainid: string) => void;
    /**
     * Returns the Human-Readable-Part of the network associated with this key.
     *
     * @returns The [[KeyPair]]'s Human-Readable-Part of the network's Bech32 addressing scheme
     */
    getHRP: () => string;
    /**
     * Sets the the Human-Readable-Part of the network associated with this key.
     *
     * @param hrp String for the Human-Readable-Part of Bech32 addresses
     */
    setHRP: (hrp: string) => void;
    constructor(hrp: string, chainid: string);
}
/**
 * Class for representing a key chain in Avalanche.
 * All endpoints that need key chains should extend on this class.
 *
 * @typeparam KPClass extending [[KeyPair]] which is used as the key in [[KeyChain]]
 */
export declare class KeyChain<KPClass extends KeyPair> {
    protected keys: {
        [address: string]: KPClass;
    };
    protected chainid: string;
    protected hrp: string;
    /**
       * Makes a new [[KeyPair]], returns the address.
       *
       * @param entropy Optional parameter that may be necessary to produce secure keys
       *
       * @returns Address of the new [[KeyPair]]
       */
    makeKey: (entropy?: Buffer) => Buffer;
    /**
       * Given a private key, makes a new [[KeyPair]], returns the address.
       *
       * @param privk A {@link https://github.com/feross/buffer|Buffer} representing the private key
       *
       * @returns Address of the new [[KeyPair]]
       */
    importKey: (privk: Buffer) => Buffer;
    /**
       * Gets an array of addresses stored in the [[KeyChain]].
       *
       * @returns An array of {@link https://github.com/feross/buffer|Buffer}  representations
       * of the addresses
       */
    getAddresses: () => Array<Buffer>;
    /**
       * Gets an array of addresses stored in the [[KeyChain]].
       *
       * @returns An array of string representations of the addresses
       */
    getAddressStrings: () => Array<string>;
    /**
       * Adds the key pair to the list of the keys managed in the [[KeyChain]].
       *
       * @param newKey A key pair of the appropriate class to be added to the [[KeyChain]]
       */
    addKey: (newKey: KPClass) => void;
    /**
       * Removes the key pair from the list of they keys managed in the [[KeyChain]].
       *
       * @param key A {@link https://github.com/feross/buffer|Buffer} for the address or
       * KPClass to remove
       *
       * @returns The boolean true if a key was removed.
       */
    removeKey: (key: KPClass | Buffer) => boolean;
    /**
       * Checks if there is a key associated with the provided address.
       *
       * @param address The address to check for existence in the keys database
       *
       * @returns True on success, false if not found
       */
    hasKey: (address: Buffer) => boolean;
    /**
       * Returns the [[KeyPair]] listed under the provided address
       *
       * @param address The {@link https://github.com/feross/buffer|Buffer} of the address to
       * retrieve from the keys database
       *
       * @returns A reference to the [[KeyPair]] in the keys database
       */
    getKey: (address: Buffer) => KPClass;
    /**
       * Returns the chainID associated with this [[KeyChain]].
       *
       * @returns The [[KeyChain]]'s chainID
       */
    getChainID: () => string;
    /**
       * Sets the the chainID associated with this [[KeyChain]] and all associated keypairs.
       *
       * @param chainid String for the chainID
       */
    setChainID: (chainid: string) => void;
    /**
     * Returns the Human-Readable-Part of the network associated with this key.
     *
     * @returns The [[KeyPair]]'s Human-Readable-Part of the network's Bech32 addressing scheme
     */
    getHRP: () => string;
    /**
     * Sets the the Human-Readable-Part of the network associated with this key.
     *
     * @param hrp String for the Human-Readable-Part of Bech32 addresses
     */
    setHRP: (hrp: string) => void;
    /**
       * Returns instance of [[KeyChain]].
       *
       * @param hrp String for the Human-Readable-Part of Bech32 addresses
       * @param chainid The hostname to resolve to reach the Avalanche Client APIs
       *
       */
    constructor(hrp: string, chainid: string);
}
/**
 * Abstract class that implements basic functionality for managing a
 * {@link https://github.com/feross/buffer|Buffer} of an exact length.
 *
 * Create a class that extends this one and override bsize to make it validate for exactly
 * the correct length.
 */
export declare abstract class NBytes {
    protected bytes: Buffer;
    protected bsize: number;
    /**
       * Returns the length of the {@link https://github.com/feross/buffer|Buffer}.
       *
       * @returns The exact length requirement of this class
       */
    getSize: () => number;
    /**
       * Takes a base-58 encoded string, verifies its length, and stores it.
       *
       * @returns The size of the {@link https://github.com/feross/buffer|Buffer}
       */
    fromString(b58str: string): number;
    /**
       * Takes a [[Buffer]], verifies its length, and stores it.
       *
       * @returns The size of the {@link https://github.com/feross/buffer|Buffer}
       */
    fromBuffer(buff: Buffer, offset?: number): number;
    /**
       * @returns A reference to the stored {@link https://github.com/feross/buffer|Buffer}
       */
    toBuffer(): Buffer;
    /**
       * @returns A base-58 string of the stored {@link https://github.com/feross/buffer|Buffer}
       */
    toString(): string;
    /**
       * Returns instance of [[NBytes]].
       */
    constructor();
}
export declare const NetworkIDToHRP: object;
export declare const HRPToNetworkID: object;
export declare const FallbackHRP: string;
export declare const DefaultNetworkID: number;
export declare function getPreferredHRP(networkID?: number): any;
export declare class Defaults {
    static network: {
        1: {
            hrp: any;
            avm: object;
            X: object;
            '4ktRjsAKxgMr2aEzv9SWmrU7Xk5FniHUrVCX4P1TZSfTLZWFM': object;
            platform: object;
            P: object;
            '11111111111111111111111111111111LpoYY': object;
            contracts: object;
            C: object;
            '2mUYSXfLrDtigwbzj1LxKVsHwELghc5sisoXrzJwLqAAQHF4i': object;
        };
        2: {
            hrp: any;
            avm: object;
            X: object;
            '4ktRjsAKxgMr2aEzv9SWmrU7Xk5FniHUrVCX4P1TZSfTLZWFM': object;
            platform: object;
            P: object;
            '11111111111111111111111111111111LpoYY': object;
            contracts: object;
            C: object;
            '2mUYSXfLrDtigwbzj1LxKVsHwELghc5sisoXrzJwLqAAQHF4i': object;
        };
        3: {
            hrp: any;
            avm: object;
            X: object;
            rrEWX7gc7D9mwcdrdBxBTdqh1a7WDVsMuadhTZgyXfFcRz45L: object;
            platform: object;
            P: object;
            '11111111111111111111111111111111LpoYY': object;
            contracts: object;
            C: object;
            zJytnh96Pc8rM337bBrtMvJDbEdDNjcXG3WkTNCiLp18ergm9: object;
        };
        4: {
            hrp: any;
            avm: object;
            X: object;
            rrEWX7gc7D9mwcdrdBxBTdqh1a7WDVsMuadhTZgyXfFcRz45L: object;
            platform: object;
            P: object;
            '11111111111111111111111111111111LpoYY': object;
            contracts: object;
            C: object;
            zJytnh96Pc8rM337bBrtMvJDbEdDNjcXG3WkTNCiLp18ergm9: object;
        };
        12345: {
            hrp: any;
            avm: any;
            X: any;
            '2oALd6xoUMp3oSHMiJYVqMcbaWxGQWYosrfiT7AaFKKNG5dmKD': any;
            platform: any;
            P: any;
            '11111111111111111111111111111111LpoYY': any;
            contracts: any;
            C: any;
            tZGm6RCkeGpVETUTp11DW3UYFZmm69zfqxchpHrSF7wgy8rmw: any;
        };
    };
}
//# sourceMappingURL=types.d.ts.map