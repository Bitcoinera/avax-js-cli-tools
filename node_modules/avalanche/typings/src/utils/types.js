"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Defaults = exports.getPreferredHRP = exports.DefaultNetworkID = exports.FallbackHRP = exports.HRPToNetworkID = exports.NetworkIDToHRP = exports.NBytes = exports.KeyChain = exports.KeyPair = exports.MinterSet = exports.JRPCAPI = exports.RESTAPI = exports.APIBase = exports.RequestResponseData = void 0;
/**
 * @packageDocumentation
 * @module Utils-Types
 */
const buffer_1 = require("buffer/");
const bintools_1 = __importDefault(require("./bintools"));
const db_1 = __importDefault(require("./db"));
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
/**
 * Response data for HTTP requests.
 */
class RequestResponseData {
}
exports.RequestResponseData = RequestResponseData;
/**
 * Abstract class defining a generic endpoint that all endpoints must implement (extend).
 */
class APIBase {
    /**
       *
       * @param core Reference to the Avalanche instance using this baseurl
       * @param baseurl Path to the baseurl - ex: "/ext/bc/avm"
       */
    constructor(core, baseurl) {
        /**
           * Sets the path of the APIs baseurl.
           *
           * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
           */
        this.setBaseURL = (baseurl) => {
            if (this.db && this.baseurl !== baseurl) {
                const backup = this.db.getAll();
                this.db.clearAll();
                this.baseurl = baseurl;
                this.db = db_1.default.getNamespace(baseurl);
                this.db.setAll(backup, true);
            }
            else {
                this.baseurl = baseurl;
                this.db = db_1.default.getNamespace(baseurl);
            }
        };
        /**
           * Returns the baseurl's path.
           */
        this.getBaseURL = () => this.baseurl;
        /**
           * Returns the baseurl's database.
           */
        this.getDB = () => this.db;
        this.core = core;
        this.setBaseURL(baseurl);
    }
}
exports.APIBase = APIBase;
class RESTAPI extends APIBase {
    /**
       *
       * @param core Reference to the Avalanche instance using this endpoint
       * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
       * @param contentType Optional Determines the type of the entity attached to the
       * incoming request
       * @param acceptType Optional Determines the type of representation which is
       * desired on the client side
       */
    constructor(core, baseurl, contentType = 'application/json;charset=UTF-8', acceptType = undefined) {
        super(core, baseurl);
        this.get = (baseurl, contentType, acceptType) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const headers = {};
            if (contentType !== undefined) {
                headers['Content-Type'] = contentType;
            }
            else {
                headers['Content-Type'] = this.contentType;
            }
            const acceptTypeStr = this.acceptType;
            if (acceptType !== undefined) {
                headers.Accept = acceptType;
            }
            else if (acceptTypeStr !== undefined) {
                headers.Accept = acceptTypeStr;
            }
            const axConf = {
                baseURL: `${this.core.getProtocol()}://${this.core.getIP()}:${this.core.getPort()}`,
                responseType: 'json',
            };
            return this.core.get(ep, {}, headers, axConf).then((resp) => resp);
        });
        this.post = (method, params, baseurl, contentType, acceptType) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const rpc = {};
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            const headers = {};
            if (contentType !== undefined) {
                headers['Content-Type'] = contentType;
            }
            else {
                headers['Content-Type'] = this.contentType;
            }
            const acceptTypeStr = this.acceptType;
            if (acceptType !== undefined) {
                headers.Accept = acceptType;
            }
            else if (acceptTypeStr !== undefined) {
                headers.Accept = acceptTypeStr;
            }
            const axConf = {
                baseURL: `${this.core.getProtocol()}://${this.core.getIP()}:${this.core.getPort()}`,
                responseType: 'json',
            };
            return this.core.post(ep, {}, JSON.stringify(rpc), headers, axConf)
                .then((resp) => resp);
        });
        this.put = (method, params, baseurl, contentType, acceptType) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const rpc = {};
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            const headers = {};
            if (contentType !== undefined) {
                headers['Content-Type'] = contentType;
            }
            else {
                headers['Content-Type'] = this.contentType;
            }
            const acceptTypeStr = this.acceptType;
            if (acceptType !== undefined) {
                headers.Accept = acceptType;
            }
            else if (acceptTypeStr !== undefined) {
                headers.Accept = acceptTypeStr;
            }
            const axConf = {
                baseURL: `${this.core.getProtocol()}://${this.core.getIP()}:${this.core.getPort()}`,
                responseType: 'json',
            };
            return this.core.put(ep, {}, JSON.stringify(rpc), headers, axConf)
                .then((resp) => resp);
        });
        this.delete = (method, params, baseurl, contentType, acceptType) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const rpc = {};
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            const headers = {};
            if (contentType !== undefined) {
                headers['Content-Type'] = contentType;
            }
            else {
                headers['Content-Type'] = this.contentType;
            }
            const acceptTypeStr = this.acceptType;
            if (acceptType !== undefined) {
                headers.Accept = acceptType;
            }
            else if (acceptTypeStr !== undefined) {
                headers.Accept = acceptTypeStr;
            }
            const axConf = {
                baseURL: `${this.core.getProtocol()}://${this.core.getIP()}:${this.core.getPort()}`,
                responseType: 'json',
            };
            return this.core.delete(ep, {}, headers, axConf).then((resp) => resp);
        });
        this.patch = (method, params, baseurl, contentType, acceptType) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const rpc = {};
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            const headers = {};
            if (contentType !== undefined) {
                headers['Content-Type'] = contentType;
            }
            else {
                headers['Content-Type'] = this.contentType;
            }
            const acceptTypeStr = this.acceptType;
            if (acceptType !== undefined) {
                headers.Accept = acceptType;
            }
            else if (acceptTypeStr !== undefined) {
                headers.Accept = acceptTypeStr;
            }
            const axConf = {
                baseURL: `${this.core.getProtocol()}://${this.core.getIP()}:${this.core.getPort()}`,
                responseType: 'json',
            };
            return this.core.patch(ep, {}, JSON.stringify(rpc), headers, axConf)
                .then((resp) => resp);
        });
        /**
           * Returns the type of the entity attached to the incoming request
           */
        this.getContentType = () => this.contentType;
        /**
           * Returns what type of representation is desired at the client side
           */
        this.getAcceptType = () => this.acceptType;
        this.contentType = contentType;
        this.acceptType = acceptType;
    }
}
exports.RESTAPI = RESTAPI;
class JRPCAPI extends APIBase {
    /**
       *
       * @param core Reference to the Avalanche instance using this endpoint
       * @param baseurl Path of the APIs baseurl - ex: "/ext/bc/avm"
       * @param jrpcVersion The jrpc version to use, default "2.0".
       */
    constructor(core, baseurl, jrpcVersion = '2.0') {
        super(core, baseurl);
        this.jrpcVersion = '2.0';
        this.rpcid = 1;
        this.callMethod = (method, params, baseurl) => __awaiter(this, void 0, void 0, function* () {
            const ep = baseurl || this.baseurl;
            const rpc = {};
            rpc.id = this.rpcid;
            rpc.method = method;
            // Set parameters if exists
            if (params) {
                rpc.params = params;
            }
            else if (this.jrpcVersion === '1.0') {
                rpc.params = [];
            }
            if (this.jrpcVersion !== '1.0') {
                rpc.jsonrpc = this.jrpcVersion;
            }
            const headers = { 'Content-Type': 'application/json;charset=UTF-8' };
            const axConf = {
                baseURL: `${this.core.getProtocol()}://${this.core.getIP()}:${this.core.getPort()}`,
                responseType: 'json',
            };
            return this.core.post(ep, {}, JSON.stringify(rpc), headers, axConf)
                .then((resp) => {
                if (resp.status >= 200 && resp.status < 300) {
                    this.rpcid += 1;
                    if (typeof resp.data === 'string') {
                        resp.data = JSON.parse(resp.data);
                    }
                    if (typeof resp.data === 'object' && (resp.data === null || 'error' in resp.data)) {
                        throw new Error(`Error returned: ${JSON.stringify(resp.data)}`);
                    }
                }
                return resp;
            });
        });
        /**
           * Returns the rpcid, a strictly-increasing number, starting from 1, indicating the next
           * request ID that will be sent.
           */
        this.getRPCID = () => this.rpcid;
        this.jrpcVersion = jrpcVersion;
        this.rpcid = 1;
    }
}
exports.JRPCAPI = JRPCAPI;
/**
 * Class for representing a threshold and set of minting addresses in Avalanche.
 *
 * @typeparam MinterSet including a threshold and array of addresses
 */
class MinterSet {
    /**
     *
     * @param threshold The number of signatures required to mint more of an asset by signing a minting transaction
     * @param minters Array of addresss which are authorized to sign a minting transaction
     */
    constructor(threshold, minters) {
        this.minters = [];
        /**
         * Returns the threshold.
         */
        this.getThreshold = () => {
            return this.threshold;
        };
        /**
         * Returns the minters.
         */
        this.getMinters = () => {
            return this.minters;
        };
        this._cleanAddresses = (addresses) => {
            let addrs = [];
            for (let i = 0; i < addresses.length; i++) {
                if (!buffer_1.Buffer.isBuffer(addresses[i])) {
                    addrs.push(bintools.stringToBuffer(addresses[i]));
                }
                else {
                    addrs.push(addresses[i]);
                }
            }
            return addrs;
        };
        this.threshold = threshold;
        this.minters = this._cleanAddresses(minters);
    }
}
exports.MinterSet = MinterSet;
/**
 * Class for representing a private and public keypair in Avalanche.
 * All APIs that need key pairs should extend on this class.
 */
class KeyPair {
    constructor(hrp, chainid) {
        this.chainid = '';
        this.hrp = '';
        /**
           * Returns a reference to the private key.
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} containing the private key
           */
        this.getPrivateKey = () => this.privk;
        /**
           * Returns a reference to the public key.
           *
           * @returns A {@link https://github.com/feross/buffer|Buffer} containing the public key
           */
        this.getPublicKey = () => this.pubk;
        /**
           * Returns the chainID associated with this key.
           *
           * @returns The [[KeyPair]]'s chainID
           */
        this.getChainID = () => this.chainid;
        /**
           * Sets the the chainID associated with this key.
           *
           * @param chainid String for the chainID
           */
        this.setChainID = (chainid) => {
            this.chainid = chainid;
        };
        /**
         * Returns the Human-Readable-Part of the network associated with this key.
         *
         * @returns The [[KeyPair]]'s Human-Readable-Part of the network's Bech32 addressing scheme
         */
        this.getHRP = () => this.hrp;
        /**
         * Sets the the Human-Readable-Part of the network associated with this key.
         *
         * @param hrp String for the Human-Readable-Part of Bech32 addresses
         */
        this.setHRP = (hrp) => {
            this.hrp = hrp;
        };
        this.chainid = chainid;
        this.hrp = hrp;
    }
}
exports.KeyPair = KeyPair;
/**
 * Class for representing a key chain in Avalanche.
 * All endpoints that need key chains should extend on this class.
 *
 * @typeparam KPClass extending [[KeyPair]] which is used as the key in [[KeyChain]]
 */
class KeyChain {
    /**
       * Returns instance of [[KeyChain]].
       *
       * @param hrp String for the Human-Readable-Part of Bech32 addresses
       * @param chainid The hostname to resolve to reach the Avalanche Client APIs
       *
       */
    constructor(hrp, chainid) {
        this.keys = {};
        this.chainid = '';
        this.hrp = '';
        /**
           * Gets an array of addresses stored in the [[KeyChain]].
           *
           * @returns An array of {@link https://github.com/feross/buffer|Buffer}  representations
           * of the addresses
           */
        this.getAddresses = () => Object.values(this.keys).map((kp) => kp.getAddress());
        /**
           * Gets an array of addresses stored in the [[KeyChain]].
           *
           * @returns An array of string representations of the addresses
           */
        this.getAddressStrings = () => Object.values(this.keys)
            .map((kp) => kp.getAddressString());
        /**
           * Adds the key pair to the list of the keys managed in the [[KeyChain]].
           *
           * @param newKey A key pair of the appropriate class to be added to the [[KeyChain]]
           */
        this.addKey = (newKey) => {
            newKey.setChainID(this.chainid);
            this.keys[newKey.getAddress().toString('hex')] = newKey;
        };
        /**
           * Removes the key pair from the list of they keys managed in the [[KeyChain]].
           *
           * @param key A {@link https://github.com/feross/buffer|Buffer} for the address or
           * KPClass to remove
           *
           * @returns The boolean true if a key was removed.
           */
        this.removeKey = (key) => {
            let kaddr;
            if (key instanceof buffer_1.Buffer) {
                kaddr = key.toString('hex');
            }
            else {
                kaddr = key.getAddress().toString('hex');
            }
            if (kaddr in this.keys) {
                delete this.keys[kaddr];
                return true;
            }
            return false;
        };
        /**
           * Checks if there is a key associated with the provided address.
           *
           * @param address The address to check for existence in the keys database
           *
           * @returns True on success, false if not found
           */
        this.hasKey = (address) => (address.toString('hex') in this.keys);
        /**
           * Returns the [[KeyPair]] listed under the provided address
           *
           * @param address The {@link https://github.com/feross/buffer|Buffer} of the address to
           * retrieve from the keys database
           *
           * @returns A reference to the [[KeyPair]] in the keys database
           */
        this.getKey = (address) => this.keys[address.toString('hex')];
        /**
           * Returns the chainID associated with this [[KeyChain]].
           *
           * @returns The [[KeyChain]]'s chainID
           */
        this.getChainID = () => this.chainid;
        /**
           * Sets the the chainID associated with this [[KeyChain]] and all associated keypairs.
           *
           * @param chainid String for the chainID
           */
        this.setChainID = (chainid) => {
            this.chainid = chainid;
            for (const address in this.keys) {
                this.keys[address].setChainID(chainid);
            }
        };
        /**
         * Returns the Human-Readable-Part of the network associated with this key.
         *
         * @returns The [[KeyPair]]'s Human-Readable-Part of the network's Bech32 addressing scheme
         */
        this.getHRP = () => this.hrp;
        /**
         * Sets the the Human-Readable-Part of the network associated with this key.
         *
         * @param hrp String for the Human-Readable-Part of Bech32 addresses
         */
        this.setHRP = (hrp) => {
            this.hrp = hrp;
        };
        this.chainid = chainid;
        this.hrp = hrp;
    }
}
exports.KeyChain = KeyChain;
/**
 * Abstract class that implements basic functionality for managing a
 * {@link https://github.com/feross/buffer|Buffer} of an exact length.
 *
 * Create a class that extends this one and override bsize to make it validate for exactly
 * the correct length.
 */
class NBytes {
    /**
       * Returns instance of [[NBytes]].
       */
    constructor() {
        /**
           * Returns the length of the {@link https://github.com/feross/buffer|Buffer}.
           *
           * @returns The exact length requirement of this class
           */
        this.getSize = () => this.bsize;
    }
    /**
       * Takes a base-58 encoded string, verifies its length, and stores it.
       *
       * @returns The size of the {@link https://github.com/feross/buffer|Buffer}
       */
    fromString(b58str) {
        try {
            this.fromBuffer(bintools.b58ToBuffer(b58str));
        }
        catch (e) {
            /* istanbul ignore next */
            const emsg = `Error - NBytes.fromString: ${e}`;
            /* istanbul ignore next */
            throw new Error(emsg);
        }
        return this.bsize;
    }
    /**
       * Takes a [[Buffer]], verifies its length, and stores it.
       *
       * @returns The size of the {@link https://github.com/feross/buffer|Buffer}
       */
    fromBuffer(buff, offset = 0) {
        try {
            if (buff.length - offset < this.bsize) {
                /* istanbul ignore next */
                throw new Error(`Buffer length must be at least ${this.bsize} bytes.`);
            }
            this.bytes = bintools.copyFrom(buff, offset, offset + this.bsize);
        }
        catch (e) {
            /* istanbul ignore next */
            const emsg = `Error - NBytes.fromBuffer: ${e}`;
            /* istanbul ignore next */
            throw new Error(emsg);
        }
        return offset + this.bsize;
    }
    /**
       * @returns A reference to the stored {@link https://github.com/feross/buffer|Buffer}
       */
    toBuffer() {
        return this.bytes;
    }
    /**
       * @returns A base-58 string of the stored {@link https://github.com/feross/buffer|Buffer}
       */
    toString() {
        return bintools.bufferToB58(this.toBuffer());
    }
}
exports.NBytes = NBytes;
exports.NetworkIDToHRP = {
    1: "avax",
    2: "cascade",
    3: "denali",
    4: "everest",
    12345: "local"
};
exports.HRPToNetworkID = {
    "avax": 1,
    "cascade": 2,
    "denali": 3,
    "everest": 4,
    "local": 12345
};
exports.FallbackHRP = "custom";
exports.DefaultNetworkID = 3;
function getPreferredHRP(networkID = undefined) {
    if (networkID in exports.NetworkIDToHRP) {
        return exports.NetworkIDToHRP[networkID];
    }
    else if (typeof networkID === "undefined") {
        return exports.DefaultNetworkID;
    }
    return exports.FallbackHRP;
}
exports.getPreferredHRP = getPreferredHRP;
// TODO: UPDATE FOR MAINNET
const n1Avm = {
    blockchainID: '4ktRjsAKxgMr2aEzv9SWmrU7Xk5FniHUrVCX4P1TZSfTLZWFM',
    alias: 'X',
    vm: 'avm',
    fee: 0
};
const n1Platform = {
    blockchainID: '11111111111111111111111111111111LpoYY',
    alias: 'P',
    vm: 'platform',
    fee: 0
};
const n1Contracts = {
    blockchainID: '2mUYSXfLrDtigwbzj1LxKVsHwELghc5sisoXrzJwLqAAQHF4i',
    alias: 'C',
    vm: 'contracts',
    fee: 0
};
// END TODO
const n2Avm = {
    blockchainID: '4ktRjsAKxgMr2aEzv9SWmrU7Xk5FniHUrVCX4P1TZSfTLZWFM',
    alias: 'X',
    vm: 'avm',
    fee: 0
};
const n2Platform = {
    blockchainID: '11111111111111111111111111111111LpoYY',
    alias: 'P',
    vm: 'platform',
    fee: 0
};
const n2Contracts = {
    blockchainID: '2mUYSXfLrDtigwbzj1LxKVsHwELghc5sisoXrzJwLqAAQHF4i',
    alias: 'C',
    vm: 'contracts',
    fee: 0
};
const n3Avm = {
    blockchainID: 'rrEWX7gc7D9mwcdrdBxBTdqh1a7WDVsMuadhTZgyXfFcRz45L',
    alias: 'X',
    vm: 'avm',
    fee: 0
};
const n3Platform = {
    blockchainID: '11111111111111111111111111111111LpoYY',
    alias: 'P',
    vm: 'platform',
    fee: 0
};
const n3Contracts = {
    blockchainID: 'zJytnh96Pc8rM337bBrtMvJDbEdDNjcXG3WkTNCiLp18ergm9',
    alias: 'C',
    vm: 'contracts',
    fee: 0
};
// TODO: UPDATE FOR EVEREST
const n4Avm = {
    blockchainID: 'rrEWX7gc7D9mwcdrdBxBTdqh1a7WDVsMuadhTZgyXfFcRz45L',
    alias: 'X',
    vm: 'avm',
    fee: 0
};
const n4Platform = {
    blockchainID: '11111111111111111111111111111111LpoYY',
    alias: 'P',
    vm: 'platform',
    fee: 0
};
const n4Contracts = {
    blockchainID: 'zJytnh96Pc8rM337bBrtMvJDbEdDNjcXG3WkTNCiLp18ergm9',
    alias: 'C',
    vm: 'contracts',
    fee: 0
};
// END TODO
const n12345Avm = Object.assign({}, n2Avm);
n12345Avm.blockchainID = '2oALd6xoUMp3oSHMiJYVqMcbaWxGQWYosrfiT7AaFKKNG5dmKD';
const n12345Platform = Object.assign({}, n2Platform);
n12345Platform.blockchainID = '11111111111111111111111111111111LpoYY';
const n12345Contracts = Object.assign({}, n2Contracts);
n12345Contracts.blockchainID = 'tZGm6RCkeGpVETUTp11DW3UYFZmm69zfqxchpHrSF7wgy8rmw';
class Defaults {
}
exports.Defaults = Defaults;
Defaults.network = {
    1: {
        hrp: exports.NetworkIDToHRP[1],
        avm: n1Avm,
        X: n1Avm,
        '4ktRjsAKxgMr2aEzv9SWmrU7Xk5FniHUrVCX4P1TZSfTLZWFM': n1Avm,
        platform: n1Platform,
        P: n1Platform,
        '11111111111111111111111111111111LpoYY': n1Platform,
        contracts: n1Contracts,
        C: n1Contracts,
        '2mUYSXfLrDtigwbzj1LxKVsHwELghc5sisoXrzJwLqAAQHF4i': n1Contracts,
    },
    2: {
        hrp: exports.NetworkIDToHRP[2],
        avm: n2Avm,
        X: n2Avm,
        '4ktRjsAKxgMr2aEzv9SWmrU7Xk5FniHUrVCX4P1TZSfTLZWFM': n2Avm,
        platform: n2Platform,
        P: n2Platform,
        '11111111111111111111111111111111LpoYY': n2Platform,
        contracts: n2Contracts,
        C: n2Contracts,
        '2mUYSXfLrDtigwbzj1LxKVsHwELghc5sisoXrzJwLqAAQHF4i': n2Contracts,
    },
    3: {
        hrp: exports.NetworkIDToHRP[3],
        avm: n3Avm,
        X: n3Avm,
        rrEWX7gc7D9mwcdrdBxBTdqh1a7WDVsMuadhTZgyXfFcRz45L: n3Avm,
        platform: n3Platform,
        P: n3Platform,
        '11111111111111111111111111111111LpoYY': n3Platform,
        contracts: n3Contracts,
        C: n3Contracts,
        zJytnh96Pc8rM337bBrtMvJDbEdDNjcXG3WkTNCiLp18ergm9: n3Contracts,
    },
    4: {
        hrp: exports.NetworkIDToHRP[4],
        avm: n4Avm,
        X: n4Avm,
        rrEWX7gc7D9mwcdrdBxBTdqh1a7WDVsMuadhTZgyXfFcRz45L: n4Avm,
        platform: n4Platform,
        P: n4Platform,
        '11111111111111111111111111111111LpoYY': n4Platform,
        contracts: n4Contracts,
        C: n4Contracts,
        zJytnh96Pc8rM337bBrtMvJDbEdDNjcXG3WkTNCiLp18ergm9: n4Contracts,
    },
    12345: {
        hrp: exports.NetworkIDToHRP[12345],
        avm: n12345Avm,
        X: n12345Avm,
        '2oALd6xoUMp3oSHMiJYVqMcbaWxGQWYosrfiT7AaFKKNG5dmKD': n12345Avm,
        platform: n12345Platform,
        P: n12345Platform,
        '11111111111111111111111111111111LpoYY': n12345Platform,
        contracts: n12345Contracts,
        C: n12345Contracts,
        tZGm6RCkeGpVETUTp11DW3UYFZmm69zfqxchpHrSF7wgy8rmw: n12345Contracts,
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvdHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztHQUdHO0FBQ0gsb0NBQWlDO0FBSWpDLDBEQUFrQztBQUNsQyw4Q0FBc0I7QUFHdEI7O0dBRUc7QUFDSCxNQUFNLFFBQVEsR0FBRyxrQkFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBRXhDOztHQUVHO0FBQ0gsTUFBYSxtQkFBbUI7Q0FVL0I7QUFWRCxrREFVQztBQUVEOztHQUVHO0FBQ0gsTUFBc0IsT0FBTztJQW1DM0I7Ozs7U0FJSztJQUNMLFlBQVksSUFBa0IsRUFBRSxPQUFjO1FBakM5Qzs7OzthQUlLO1FBQ0wsZUFBVSxHQUFHLENBQUMsT0FBYyxFQUFFLEVBQUU7WUFDOUIsSUFBSSxJQUFJLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFFO2dCQUN2QyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNoQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNuQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztnQkFDdkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxZQUFFLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNuQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDOUI7aUJBQU07Z0JBQ0wsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxFQUFFLEdBQUcsWUFBRSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNwQztRQUNILENBQUMsQ0FBQztRQUVGOzthQUVLO1FBQ0wsZUFBVSxHQUFHLEdBQVksRUFBRSxDQUFDLElBQUksQ0FB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O1FBQ25ELFNBQVMsRUFBRSxXQUFXO1FBQ3RCLENBQUMsRUFBRSxXQUFXO1FBQ2QsaURBQWlELEVBQUUsV0FBVztLQUMvRDtJQUNELENBQUMsRUFBRTtRQUNELEdBQUcsRUFBRSxzQkFBYyxDQUFDLENBQUMsQ0FBQztRQUN0QixHQUFHLEVBQUUsS0FBSztRQUNWLENBQUMsRUFBRSxLQUFLO1FBQ1IsaURBQWlELEVBQUUsS0FBSztRQUN4RCxRQUFRLEVBQUUsVUFBVTtRQUNwQixDQUFDLEVBQUUsVUFBVTtRQUNiLHVDQUF1QyxFQUFFLFVBQVU7UUFDbkQsU0FBUyxFQUFFLFdBQVc7UUFDdEIsQ0FBQyxFQUFFLFdBQVc7UUFDZCxpREFBaUQsRUFBRSxXQUFXO0tBQy9EO0lBQ0QsS0FBSyxFQUFFO1FBQ0wsR0FBRyxFQUFFLHNCQUFjLENBQUMsS0FBSyxDQUFDO1FBQzFCLEdBQUcsRUFBRSxTQUFTO1FBQ2QsQ0FBQyxFQUFFLFNBQVM7UUFDWixvREFBb0QsRUFBRSxTQUFTO1FBQy9ELFFBQVEsRUFBRSxjQUFjO1FBQ3hCLENBQUMsRUFBRSxjQUFjO1FBQ2pCLHVDQUF1QyxFQUFFLGNBQWM7UUFDdkQsU0FBUyxFQUFFLGVBQWU7UUFDMUIsQ0FBQyxFQUFFLGVBQWU7UUFDbEIsaURBQWlELEVBQUUsZUFBZTtLQUNuRTtDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBVdGlscy1UeXBlc1xuICovXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXIvJztcbmltcG9ydCB7IFN0b3JlQVBJIH0gZnJvbSAnc3RvcmUyJztcbmltcG9ydCB7IENsaWVudFJlcXVlc3QgfSBmcm9tICdodHRwJztcbmltcG9ydCB7IEF4aW9zUmVxdWVzdENvbmZpZyB9IGZyb20gJ2F4aW9zJztcbmltcG9ydCBCaW5Ub29scyBmcm9tICcuL2JpbnRvb2xzJztcbmltcG9ydCBEQiBmcm9tICcuL2RiJztcbmltcG9ydCBBdmFsYW5jaGVDb3JlIGZyb20gJy4uL2F2YWxhbmNoZSc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5jb25zdCBiaW50b29scyA9IEJpblRvb2xzLmdldEluc3RhbmNlKCk7XG5cbi8qKlxuICogUmVzcG9uc2UgZGF0YSBmb3IgSFRUUCByZXF1ZXN0cy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlcXVlc3RSZXNwb25zZURhdGEge1xuICBkYXRhOiBhbnk7XG5cbiAgaGVhZGVyczphbnk7XG5cbiAgc3RhdHVzOiBudW1iZXI7XG5cbiAgc3RhdHVzVGV4dDogc3RyaW5nO1xuXG4gIHJlcXVlc3Q6Q2xpZW50UmVxdWVzdCB8IFhNTEh0dHBSZXF1ZXN0O1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGRlZmluaW5nIGEgZ2VuZXJpYyBlbmRwb2ludCB0aGF0IGFsbCBlbmRwb2ludHMgbXVzdCBpbXBsZW1lbnQgKGV4dGVuZCkuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBUElCYXNlIHtcbiAgcHJvdGVjdGVkIGNvcmU6QXZhbGFuY2hlQ29yZTtcblxuICBwcm90ZWN0ZWQgYmFzZXVybDpzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGRiOlN0b3JlQVBJO1xuXG4gIC8qKlxuICAgICAqIFNldHMgdGhlIHBhdGggb2YgdGhlIEFQSXMgYmFzZXVybC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiYXNldXJsIFBhdGggb2YgdGhlIEFQSXMgYmFzZXVybCAtIGV4OiBcIi9leHQvYmMvYXZtXCJcbiAgICAgKi9cbiAgc2V0QmFzZVVSTCA9IChiYXNldXJsOnN0cmluZykgPT4ge1xuICAgIGlmICh0aGlzLmRiICYmIHRoaXMuYmFzZXVybCAhPT0gYmFzZXVybCkge1xuICAgICAgY29uc3QgYmFja3VwID0gdGhpcy5kYi5nZXRBbGwoKTtcbiAgICAgIHRoaXMuZGIuY2xlYXJBbGwoKTtcbiAgICAgIHRoaXMuYmFzZXVybCA9IGJhc2V1cmw7XG4gICAgICB0aGlzLmRiID0gREIuZ2V0TmFtZXNwYWNlKGJhc2V1cmwpO1xuICAgICAgdGhpcy5kYi5zZXRBbGwoYmFja3VwLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iYXNldXJsID0gYmFzZXVybDtcbiAgICAgIHRoaXMuZGIgPSBEQi5nZXROYW1lc3BhY2UoYmFzZXVybCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJhc2V1cmwncyBwYXRoLlxuICAgICAqL1xuICBnZXRCYXNlVVJMID0gKCkgOiBzdHJpbmcgPT4gdGhpcy5iYXNldXJsO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJhc2V1cmwncyBkYXRhYmFzZS5cbiAgICAgKi9cbiAgZ2V0REIgPSAoKTpTdG9yZUFQSSA9PiB0aGlzLmRiO1xuXG4gIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvcmUgUmVmZXJlbmNlIHRvIHRoZSBBdmFsYW5jaGUgaW5zdGFuY2UgdXNpbmcgdGhpcyBiYXNldXJsXG4gICAgICogQHBhcmFtIGJhc2V1cmwgUGF0aCB0byB0aGUgYmFzZXVybCAtIGV4OiBcIi9leHQvYmMvYXZtXCJcbiAgICAgKi9cbiAgY29uc3RydWN0b3IoY29yZTpBdmFsYW5jaGVDb3JlLCBiYXNldXJsOnN0cmluZykge1xuICAgIHRoaXMuY29yZSA9IGNvcmU7XG4gICAgdGhpcy5zZXRCYXNlVVJMKGJhc2V1cmwpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSRVNUQVBJIGV4dGVuZHMgQVBJQmFzZSB7XG4gIHByb3RlY3RlZCBjb250ZW50VHlwZTpzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGFjY2VwdFR5cGU6c3RyaW5nO1xuXG4gIGdldCA9IGFzeW5jIChiYXNldXJsPzpzdHJpbmcsXG4gICAgY29udGVudFR5cGU/OnN0cmluZyxcbiAgICBhY2NlcHRUeXBlPzpzdHJpbmcpOlByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4ge1xuICAgIGNvbnN0IGVwOnN0cmluZyA9IGJhc2V1cmwgfHwgdGhpcy5iYXNldXJsO1xuXG4gICAgY29uc3QgaGVhZGVyczphbnkgPSB7fTtcbiAgICBpZiAoY29udGVudFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBjb250ZW50VHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLmNvbnRlbnRUeXBlO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY2VwdFR5cGVTdHI6c3RyaW5nID0gdGhpcy5hY2NlcHRUeXBlO1xuICAgIGlmIChhY2NlcHRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuQWNjZXB0ID0gYWNjZXB0VHlwZTtcbiAgICB9IGVsc2UgaWYgKGFjY2VwdFR5cGVTdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5BY2NlcHQgPSBhY2NlcHRUeXBlU3RyO1xuICAgIH1cblxuICAgIGNvbnN0IGF4Q29uZjpBeGlvc1JlcXVlc3RDb25maWcgPSB7XG4gICAgICBiYXNlVVJMOiBgJHt0aGlzLmNvcmUuZ2V0UHJvdG9jb2woKX06Ly8ke3RoaXMuY29yZS5nZXRJUCgpfToke3RoaXMuY29yZS5nZXRQb3J0KCl9YCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5jb3JlLmdldChlcCwge30sIGhlYWRlcnMsIGF4Q29uZikudGhlbigocmVzcDpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwKTtcbiAgfTtcblxuICBwb3N0ID0gYXN5bmMgKG1ldGhvZDpzdHJpbmcsXG4gICAgcGFyYW1zPzpBcnJheTxvYmplY3Q+IHwgb2JqZWN0LFxuICAgIGJhc2V1cmw/OnN0cmluZyxcbiAgICBjb250ZW50VHlwZT86c3RyaW5nLFxuICAgIGFjY2VwdFR5cGU/OnN0cmluZyk6UHJvbWlzZTxSZXF1ZXN0UmVzcG9uc2VEYXRhPiA9PiB7XG4gICAgY29uc3QgZXA6c3RyaW5nID0gYmFzZXVybCB8fCB0aGlzLmJhc2V1cmw7XG4gICAgY29uc3QgcnBjOmFueSA9IHt9O1xuICAgIHJwYy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgICAvLyBTZXQgcGFyYW1ldGVycyBpZiBleGlzdHNcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBycGMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnM6YW55ID0ge307XG4gICAgaWYgKGNvbnRlbnRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gY29udGVudFR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5jb250ZW50VHlwZTtcbiAgICB9XG5cbiAgICBjb25zdCBhY2NlcHRUeXBlU3RyOnN0cmluZyA9IHRoaXMuYWNjZXB0VHlwZTtcbiAgICBpZiAoYWNjZXB0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzLkFjY2VwdCA9IGFjY2VwdFR5cGU7XG4gICAgfSBlbHNlIGlmIChhY2NlcHRUeXBlU3RyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuQWNjZXB0ID0gYWNjZXB0VHlwZVN0cjtcbiAgICB9XG5cbiAgICBjb25zdCBheENvbmY6QXhpb3NSZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgYmFzZVVSTDogYCR7dGhpcy5jb3JlLmdldFByb3RvY29sKCl9Oi8vJHt0aGlzLmNvcmUuZ2V0SVAoKX06JHt0aGlzLmNvcmUuZ2V0UG9ydCgpfWAsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY29yZS5wb3N0KGVwLCB7fSwgSlNPTi5zdHJpbmdpZnkocnBjKSwgaGVhZGVycywgYXhDb25mKVxuICAgICAgLnRoZW4oKHJlc3A6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4gcmVzcCk7XG4gIH07XG5cbiAgcHV0ID0gYXN5bmMgKG1ldGhvZDpzdHJpbmcsXG4gICAgcGFyYW1zPzpBcnJheTxvYmplY3Q+IHwgb2JqZWN0LFxuICAgIGJhc2V1cmw/OnN0cmluZyxcbiAgICBjb250ZW50VHlwZT86c3RyaW5nLFxuICAgIGFjY2VwdFR5cGU/OnN0cmluZyk6UHJvbWlzZTxSZXF1ZXN0UmVzcG9uc2VEYXRhPiA9PiB7XG4gICAgY29uc3QgZXA6c3RyaW5nID0gYmFzZXVybCB8fCB0aGlzLmJhc2V1cmw7XG4gICAgY29uc3QgcnBjOmFueSA9IHt9O1xuICAgIHJwYy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgICAvLyBTZXQgcGFyYW1ldGVycyBpZiBleGlzdHNcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBycGMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlcnM6YW55ID0ge307XG4gICAgaWYgKGNvbnRlbnRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gY29udGVudFR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5jb250ZW50VHlwZTtcbiAgICB9XG5cbiAgICBjb25zdCBhY2NlcHRUeXBlU3RyOnN0cmluZyA9IHRoaXMuYWNjZXB0VHlwZTtcbiAgICBpZiAoYWNjZXB0VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzLkFjY2VwdCA9IGFjY2VwdFR5cGU7XG4gICAgfSBlbHNlIGlmIChhY2NlcHRUeXBlU3RyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuQWNjZXB0ID0gYWNjZXB0VHlwZVN0cjtcbiAgICB9XG5cbiAgICBjb25zdCBheENvbmY6QXhpb3NSZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgYmFzZVVSTDogYCR7dGhpcy5jb3JlLmdldFByb3RvY29sKCl9Oi8vJHt0aGlzLmNvcmUuZ2V0SVAoKX06JHt0aGlzLmNvcmUuZ2V0UG9ydCgpfWAsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY29yZS5wdXQoZXAsIHt9LCBKU09OLnN0cmluZ2lmeShycGMpLCBoZWFkZXJzLCBheENvbmYpXG4gICAgICAudGhlbigocmVzcDpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwKTtcbiAgfTtcblxuICBkZWxldGUgPSBhc3luYyAobWV0aG9kOnN0cmluZyxcbiAgICBwYXJhbXM/OkFycmF5PG9iamVjdD4gfCBvYmplY3QsXG4gICAgYmFzZXVybD86c3RyaW5nLFxuICAgIGNvbnRlbnRUeXBlPzpzdHJpbmcsXG4gICAgYWNjZXB0VHlwZT86c3RyaW5nKTpQcm9taXNlPFJlcXVlc3RSZXNwb25zZURhdGE+ID0+IHtcbiAgICBjb25zdCBlcDpzdHJpbmcgPSBiYXNldXJsIHx8IHRoaXMuYmFzZXVybDtcbiAgICBjb25zdCBycGM6YW55ID0ge307XG4gICAgcnBjLm1ldGhvZCA9IG1ldGhvZDtcblxuICAgIC8vIFNldCBwYXJhbWV0ZXJzIGlmIGV4aXN0c1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIHJwYy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVyczphbnkgPSB7fTtcbiAgICBpZiAoY29udGVudFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBjb250ZW50VHlwZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB0aGlzLmNvbnRlbnRUeXBlO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY2VwdFR5cGVTdHI6c3RyaW5nID0gdGhpcy5hY2NlcHRUeXBlO1xuICAgIGlmIChhY2NlcHRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGhlYWRlcnMuQWNjZXB0ID0gYWNjZXB0VHlwZTtcbiAgICB9IGVsc2UgaWYgKGFjY2VwdFR5cGVTdHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5BY2NlcHQgPSBhY2NlcHRUeXBlU3RyO1xuICAgIH1cblxuICAgIGNvbnN0IGF4Q29uZjpBeGlvc1JlcXVlc3RDb25maWcgPSB7XG4gICAgICBiYXNlVVJMOiBgJHt0aGlzLmNvcmUuZ2V0UHJvdG9jb2woKX06Ly8ke3RoaXMuY29yZS5nZXRJUCgpfToke3RoaXMuY29yZS5nZXRQb3J0KCl9YCxcbiAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5jb3JlLmRlbGV0ZShlcCwge30sIGhlYWRlcnMsIGF4Q29uZikudGhlbigocmVzcDpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwKTtcbiAgfTtcblxuICBwYXRjaCA9IGFzeW5jIChtZXRob2Q6c3RyaW5nLFxuICAgIHBhcmFtcz86QXJyYXk8b2JqZWN0PiB8IG9iamVjdCxcbiAgICBiYXNldXJsPzpzdHJpbmcsXG4gICAgY29udGVudFR5cGU/OnN0cmluZyxcbiAgICBhY2NlcHRUeXBlPzpzdHJpbmcpOlByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4ge1xuICAgIGNvbnN0IGVwOnN0cmluZyA9IGJhc2V1cmwgfHwgdGhpcy5iYXNldXJsO1xuICAgIGNvbnN0IHJwYzphbnkgPSB7fTtcbiAgICBycGMubWV0aG9kID0gbWV0aG9kO1xuXG4gICAgLy8gU2V0IHBhcmFtZXRlcnMgaWYgZXhpc3RzXG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgcnBjLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzOmFueSA9IHt9O1xuICAgIGlmIChjb250ZW50VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGNvbnRlbnRUeXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHRoaXMuY29udGVudFR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjZXB0VHlwZVN0cjpzdHJpbmcgPSB0aGlzLmFjY2VwdFR5cGU7XG4gICAgaWYgKGFjY2VwdFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5BY2NlcHQgPSBhY2NlcHRUeXBlO1xuICAgIH0gZWxzZSBpZiAoYWNjZXB0VHlwZVN0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzLkFjY2VwdCA9IGFjY2VwdFR5cGVTdHI7XG4gICAgfVxuXG4gICAgY29uc3QgYXhDb25mOkF4aW9zUmVxdWVzdENvbmZpZyA9IHtcbiAgICAgIGJhc2VVUkw6IGAke3RoaXMuY29yZS5nZXRQcm90b2NvbCgpfTovLyR7dGhpcy5jb3JlLmdldElQKCl9OiR7dGhpcy5jb3JlLmdldFBvcnQoKX1gLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmNvcmUucGF0Y2goZXAsIHt9LCBKU09OLnN0cmluZ2lmeShycGMpLCBoZWFkZXJzLCBheENvbmYpXG4gICAgICAudGhlbigocmVzcDpSZXF1ZXN0UmVzcG9uc2VEYXRhKSA9PiByZXNwKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBlbnRpdHkgYXR0YWNoZWQgdG8gdGhlIGluY29taW5nIHJlcXVlc3RcbiAgICAgKi9cbiAgZ2V0Q29udGVudFR5cGUgPSAoKTpzdHJpbmcgPT4gdGhpcy5jb250ZW50VHlwZTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHdoYXQgdHlwZSBvZiByZXByZXNlbnRhdGlvbiBpcyBkZXNpcmVkIGF0IHRoZSBjbGllbnQgc2lkZVxuICAgICAqL1xuICBnZXRBY2NlcHRUeXBlID0gKCk6c3RyaW5nID0+IHRoaXMuYWNjZXB0VHlwZTtcblxuICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3JlIFJlZmVyZW5jZSB0byB0aGUgQXZhbGFuY2hlIGluc3RhbmNlIHVzaW5nIHRoaXMgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIG9mIHRoZSBBUElzIGJhc2V1cmwgLSBleDogXCIvZXh0L2JjL2F2bVwiXG4gICAgICogQHBhcmFtIGNvbnRlbnRUeXBlIE9wdGlvbmFsIERldGVybWluZXMgdGhlIHR5cGUgb2YgdGhlIGVudGl0eSBhdHRhY2hlZCB0byB0aGVcbiAgICAgKiBpbmNvbWluZyByZXF1ZXN0XG4gICAgICogQHBhcmFtIGFjY2VwdFR5cGUgT3B0aW9uYWwgRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiByZXByZXNlbnRhdGlvbiB3aGljaCBpc1xuICAgICAqIGRlc2lyZWQgb24gdGhlIGNsaWVudCBzaWRlXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKGNvcmU6QXZhbGFuY2hlQ29yZSxcbiAgICBiYXNldXJsOnN0cmluZyxcbiAgICBjb250ZW50VHlwZTpzdHJpbmcgPSAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyxcbiAgICBhY2NlcHRUeXBlOnN0cmluZyA9IHVuZGVmaW5lZCkge1xuICAgIHN1cGVyKGNvcmUsIGJhc2V1cmwpO1xuICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZTtcbiAgICB0aGlzLmFjY2VwdFR5cGUgPSBhY2NlcHRUeXBlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBKUlBDQVBJIGV4dGVuZHMgQVBJQmFzZSB7XG4gIHByb3RlY3RlZCBqcnBjVmVyc2lvbjpzdHJpbmcgPSAnMi4wJztcblxuICBwcm90ZWN0ZWQgcnBjaWQgPSAxO1xuXG4gIGNhbGxNZXRob2QgPSBhc3luYyAobWV0aG9kOnN0cmluZyxcbiAgICBwYXJhbXM/OkFycmF5PG9iamVjdD4gfCBvYmplY3QsXG4gICAgYmFzZXVybD86c3RyaW5nKTpQcm9taXNlPFJlcXVlc3RSZXNwb25zZURhdGE+ID0+IHtcbiAgICBjb25zdCBlcCA9IGJhc2V1cmwgfHwgdGhpcy5iYXNldXJsO1xuICAgIGNvbnN0IHJwYzphbnkgPSB7fTtcbiAgICBycGMuaWQgPSB0aGlzLnJwY2lkO1xuICAgIHJwYy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgICAvLyBTZXQgcGFyYW1ldGVycyBpZiBleGlzdHNcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICBycGMucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAodGhpcy5qcnBjVmVyc2lvbiA9PT0gJzEuMCcpIHtcbiAgICAgIHJwYy5wYXJhbXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5qcnBjVmVyc2lvbiAhPT0gJzEuMCcpIHtcbiAgICAgIHJwYy5qc29ucnBjID0gdGhpcy5qcnBjVmVyc2lvbjtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFkZXJzOm9iamVjdCA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9VVRGLTgnIH07XG5cbiAgICBjb25zdCBheENvbmY6QXhpb3NSZXF1ZXN0Q29uZmlnID0ge1xuICAgICAgYmFzZVVSTDogYCR7dGhpcy5jb3JlLmdldFByb3RvY29sKCl9Oi8vJHt0aGlzLmNvcmUuZ2V0SVAoKX06JHt0aGlzLmNvcmUuZ2V0UG9ydCgpfWAsXG4gICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuY29yZS5wb3N0KGVwLCB7fSwgSlNPTi5zdHJpbmdpZnkocnBjKSwgaGVhZGVycywgYXhDb25mKVxuICAgICAgLnRoZW4oKHJlc3A6UmVxdWVzdFJlc3BvbnNlRGF0YSkgPT4ge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPj0gMjAwICYmIHJlc3Auc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgdGhpcy5ycGNpZCArPSAxO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzcC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzcC5kYXRhID0gSlNPTi5wYXJzZShyZXNwLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3AuZGF0YSA9PT0gJ29iamVjdCcgJiYgKHJlc3AuZGF0YSA9PT0gbnVsbCB8fCAnZXJyb3InIGluIHJlc3AuZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmV0dXJuZWQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzcC5kYXRhKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBycGNpZCwgYSBzdHJpY3RseS1pbmNyZWFzaW5nIG51bWJlciwgc3RhcnRpbmcgZnJvbSAxLCBpbmRpY2F0aW5nIHRoZSBuZXh0XG4gICAgICogcmVxdWVzdCBJRCB0aGF0IHdpbGwgYmUgc2VudC5cbiAgICAgKi9cbiAgZ2V0UlBDSUQgPSAoKTpudW1iZXIgPT4gdGhpcy5ycGNpZDtcblxuICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb3JlIFJlZmVyZW5jZSB0byB0aGUgQXZhbGFuY2hlIGluc3RhbmNlIHVzaW5nIHRoaXMgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIG9mIHRoZSBBUElzIGJhc2V1cmwgLSBleDogXCIvZXh0L2JjL2F2bVwiXG4gICAgICogQHBhcmFtIGpycGNWZXJzaW9uIFRoZSBqcnBjIHZlcnNpb24gdG8gdXNlLCBkZWZhdWx0IFwiMi4wXCIuXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKGNvcmU6QXZhbGFuY2hlQ29yZSwgYmFzZXVybDpzdHJpbmcsIGpycGNWZXJzaW9uOnN0cmluZyA9ICcyLjAnKSB7XG4gICAgc3VwZXIoY29yZSwgYmFzZXVybCk7XG4gICAgdGhpcy5qcnBjVmVyc2lvbiA9IGpycGNWZXJzaW9uO1xuICAgIHRoaXMucnBjaWQgPSAxO1xuICB9XG59XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIHRocmVzaG9sZCBhbmQgc2V0IG9mIG1pbnRpbmcgYWRkcmVzc2VzIGluIEF2YWxhbmNoZS4gXG4gKiBcbiAqIEB0eXBlcGFyYW0gTWludGVyU2V0IGluY2x1ZGluZyBhIHRocmVzaG9sZCBhbmQgYXJyYXkgb2YgYWRkcmVzc2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBNaW50ZXJTZXQge1xuICAgIHByb3RlY3RlZCB0aHJlc2hvbGQ6bnVtYmVyO1xuICAgIHByb3RlY3RlZCBtaW50ZXJzOkFycmF5PEJ1ZmZlcj4gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRocmVzaG9sZC5cbiAgICAgKi9cbiAgICBnZXRUaHJlc2hvbGQgPSAoKTpudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWludGVycy5cbiAgICAgKi9cbiAgICBnZXRNaW50ZXJzID0gKCk6QXJyYXk8QnVmZmVyPiA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbnRlcnM7XG4gICAgfVxuXG4gICBwcm90ZWN0ZWQgIF9jbGVhbkFkZHJlc3NlcyA9IChhZGRyZXNzZXM6QXJyYXk8c3RyaW5nfEJ1ZmZlcj4pOkFycmF5PEJ1ZmZlcj4gPT4ge1xuICAgICAgICBsZXQgYWRkcnM6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgICAgICBmb3IobGV0IGk6bnVtYmVyID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihhZGRyZXNzZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgYWRkcnMucHVzaChiaW50b29scy5zdHJpbmdUb0J1ZmZlcihhZGRyZXNzZXNbaV0gYXMgc3RyaW5nKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkcnMucHVzaChhZGRyZXNzZXNbaV0gYXMgQnVmZmVyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRycztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gdGhyZXNob2xkIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyByZXF1aXJlZCB0byBtaW50IG1vcmUgb2YgYW4gYXNzZXQgYnkgc2lnbmluZyBhIG1pbnRpbmcgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gbWludGVycyBBcnJheSBvZiBhZGRyZXNzcyB3aGljaCBhcmUgYXV0aG9yaXplZCB0byBzaWduIGEgbWludGluZyB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRocmVzaG9sZDpudW1iZXIsIG1pbnRlcnM6QXJyYXk8c3RyaW5nfEJ1ZmZlcj4pIHtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgICAgIHRoaXMubWludGVycyA9IHRoaXMuX2NsZWFuQWRkcmVzc2VzKG1pbnRlcnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgcHJpdmF0ZSBhbmQgcHVibGljIGtleXBhaXIgaW4gQXZhbGFuY2hlLiBcbiAqIEFsbCBBUElzIHRoYXQgbmVlZCBrZXkgcGFpcnMgc2hvdWxkIGV4dGVuZCBvbiB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgS2V5UGFpciB7XG4gIHByb3RlY3RlZCBwdWJrOkJ1ZmZlcjtcblxuICBwcm90ZWN0ZWQgcHJpdms6QnVmZmVyO1xuXG4gIHByb3RlY3RlZCBjaGFpbmlkOnN0cmluZyA9ICcnO1xuICBwcm90ZWN0ZWQgaHJwOnN0cmluZyA9ICcnO1xuXG4gIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBrZXlwYWlyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudHJvcHkgT3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBwcm9kdWNlIHNlY3VyZSBrZXlzXG4gICAgICovXG4gIGdlbmVyYXRlS2V5OihlbnRyb3B5PzpCdWZmZXIpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAgICogSW1wb3J0cyBhIHByaXZhdGUga2V5IGFuZCBnZW5lcmF0ZXMgdGhlIGFwcHJvcHJpYXRlIHB1YmxpYyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJpdmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIHByaXZhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIG9uIGZhaWx1cmVcbiAgICAgKi9cbiAgaW1wb3J0S2V5Oihwcml2azpCdWZmZXIpID0+IGJvb2xlYW47XG5cbiAgLyoqXG4gICAgICogVGFrZXMgYSBtZXNzYWdlLCBzaWducyBpdCwgYW5kIHJldHVybnMgdGhlIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdG8gc2lnblxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSBzaWduYXR1cmVcbiAgICAgKi9cbiAgc2lnbjoobXNnOkJ1ZmZlcikgPT4gQnVmZmVyO1xuXG4gIC8qKlxuICAgICAqIFJlY292ZXJzIHRoZSBwdWJsaWMga2V5IG9mIGEgbWVzc2FnZSBzaWduZXIgZnJvbSBhIG1lc3NhZ2UgYW5kIGl0cyBhc3NvY2lhdGVkIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgdGhhdCdzIHNpZ25lZFxuICAgICAqIEBwYXJhbSBzaWcgVGhlIHNpZ25hdHVyZSB0aGF0J3Mgc2lnbmVkIG9uIHRoZSBtZXNzYWdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgdGhlIHB1YmxpY1xuICAgICAqIGtleSBvZiB0aGUgc2lnbmVyXG4gICAgICovXG4gIHJlY292ZXI6KG1zZzpCdWZmZXIsIHNpZzpCdWZmZXIpID0+IEJ1ZmZlcjtcblxuICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIHB1YmxpYyBrZXkgcHJvZHVjZXMgdGhlXG4gICAgICogc2lnbmF0dXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBzaWduYXR1cmVcbiAgICAgKiBAcGFyYW0gc2lnIFRoZSBzaWduYXR1cmUgb2YgdGhlIHNpZ25lZCBtZXNzYWdlXG4gICAgICogQHBhcmFtIHB1YmsgVGhlIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXNzYWdlIHNpZ25hdHVyZVxuICAgICAqXG4gICAgICogQHJldHVybnMgVHJ1ZSBvbiBzdWNjZXNzLCBmYWxzZSBvbiBmYWlsdXJlXG4gICAgICovXG4gIHZlcmlmeToobXNnOkJ1ZmZlciwgc2lnOkJ1ZmZlciwgcHViazpCdWZmZXIpID0+IGJvb2xlYW47XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGNvbnRhaW5pbmcgdGhlIHByaXZhdGUga2V5XG4gICAgICovXG4gIGdldFByaXZhdGVLZXkgPSAoKTpCdWZmZXIgPT4gdGhpcy5wcml2aztcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBjb250YWluaW5nIHRoZSBwdWJsaWMga2V5XG4gICAgICovXG4gIGdldFB1YmxpY0tleSA9ICgpOkJ1ZmZlciA9PiB0aGlzLnB1Yms7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgICAqL1xuICBnZXRQcml2YXRlS2V5U3RyaW5nOigpID0+IHN0cmluZztcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgZ2V0UHVibGljS2V5U3RyaW5nOigpID0+IHN0cmluZztcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSAgcmVwcmVzZW50YXRpb24gb2YgdGhlIGFkZHJlc3NcbiAgICAgKi9cbiAgZ2V0QWRkcmVzczooKSA9PiBCdWZmZXI7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcydzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzXG4gICAgICovXG4gIGdldEFkZHJlc3NTdHJpbmc6KCkgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYWluSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFtbS2V5UGFpcl1dJ3MgY2hhaW5JRFxuICAgICAqL1xuICBnZXRDaGFpbklEID0gKCk6c3RyaW5nID0+IHRoaXMuY2hhaW5pZDtcblxuICAvKipcbiAgICAgKiBTZXRzIHRoZSB0aGUgY2hhaW5JRCBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5pZCBTdHJpbmcgZm9yIHRoZSBjaGFpbklEXG4gICAgICovXG4gIHNldENoYWluSUQgPSAoY2hhaW5pZDpzdHJpbmcpOnZvaWQgPT4ge1xuICAgIHRoaXMuY2hhaW5pZCA9IGNoYWluaWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEh1bWFuLVJlYWRhYmxlLVBhcnQgb2YgdGhlIG5ldHdvcmsgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgW1tLZXlQYWlyXV0ncyBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrJ3MgQmVjaDMyIGFkZHJlc3Npbmcgc2NoZW1lXG4gICAqL1xuICBnZXRIUlAgPSAoKTpzdHJpbmcgPT4gdGhpcy5ocnA7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGhycCBTdHJpbmcgZm9yIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIEJlY2gzMiBhZGRyZXNzZXNcbiAgICovXG4gIHNldEhSUCA9IChocnA6c3RyaW5nKTp2b2lkID0+IHtcbiAgICB0aGlzLmhycCA9IGhycDtcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihocnA6c3RyaW5nLCBjaGFpbmlkOnN0cmluZykge1xuICAgIHRoaXMuY2hhaW5pZCA9IGNoYWluaWQ7XG4gICAgdGhpcy5ocnAgPSBocnA7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEga2V5IGNoYWluIGluIEF2YWxhbmNoZS5cbiAqIEFsbCBlbmRwb2ludHMgdGhhdCBuZWVkIGtleSBjaGFpbnMgc2hvdWxkIGV4dGVuZCBvbiB0aGlzIGNsYXNzLlxuICpcbiAqIEB0eXBlcGFyYW0gS1BDbGFzcyBleHRlbmRpbmcgW1tLZXlQYWlyXV0gd2hpY2ggaXMgdXNlZCBhcyB0aGUga2V5IGluIFtbS2V5Q2hhaW5dXVxuICovXG5leHBvcnQgY2xhc3MgS2V5Q2hhaW48S1BDbGFzcyBleHRlbmRzIEtleVBhaXI+IHtcbiAgcHJvdGVjdGVkIGtleXM6e1thZGRyZXNzOiBzdHJpbmddOiBLUENsYXNzfSA9IHt9O1xuXG4gIHByb3RlY3RlZCBjaGFpbmlkOnN0cmluZyA9ICcnO1xuICBwcm90ZWN0ZWQgaHJwOnN0cmluZyA9ICcnO1xuXG4gIC8qKlxuICAgICAqIE1ha2VzIGEgbmV3IFtbS2V5UGFpcl1dLCByZXR1cm5zIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVudHJvcHkgT3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBwcm9kdWNlIHNlY3VyZSBrZXlzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIHRoZSBuZXcgW1tLZXlQYWlyXV1cbiAgICAgKi9cbiAgbWFrZUtleTooZW50cm9weT86QnVmZmVyKSA9PiBCdWZmZXI7XG5cbiAgLyoqXG4gICAgICogR2l2ZW4gYSBwcml2YXRlIGtleSwgbWFrZXMgYSBuZXcgW1tLZXlQYWlyXV0sIHJldHVybnMgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJpdmsgQSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIHByaXZhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIHRoZSBuZXcgW1tLZXlQYWlyXV1cbiAgICAgKi9cbiAgaW1wb3J0S2V5Oihwcml2azpCdWZmZXIpID0+IEJ1ZmZlcjtcblxuICAvKipcbiAgICAgKiBHZXRzIGFuIGFycmF5IG9mIGFkZHJlc3NlcyBzdG9yZWQgaW4gdGhlIFtbS2V5Q2hhaW5dXS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9ICByZXByZXNlbnRhdGlvbnNcbiAgICAgKiBvZiB0aGUgYWRkcmVzc2VzXG4gICAgICovXG4gIGdldEFkZHJlc3NlcyA9ICgpOkFycmF5PEJ1ZmZlcj4gPT4gT2JqZWN0LnZhbHVlcyh0aGlzLmtleXMpLm1hcCgoa3ApID0+IGtwLmdldEFkZHJlc3MoKSk7XG5cbiAgLyoqXG4gICAgICogR2V0cyBhbiBhcnJheSBvZiBhZGRyZXNzZXMgc3RvcmVkIGluIHRoZSBbW0tleUNoYWluXV0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIHRoZSBhZGRyZXNzZXNcbiAgICAgKi9cbiAgZ2V0QWRkcmVzc1N0cmluZ3MgPSAoKTpBcnJheTxzdHJpbmc+ID0+IE9iamVjdC52YWx1ZXModGhpcy5rZXlzKVxuICAgIC5tYXAoKGtwKSA9PiBrcC5nZXRBZGRyZXNzU3RyaW5nKCkpO1xuXG4gIC8qKlxuICAgICAqIEFkZHMgdGhlIGtleSBwYWlyIHRvIHRoZSBsaXN0IG9mIHRoZSBrZXlzIG1hbmFnZWQgaW4gdGhlIFtbS2V5Q2hhaW5dXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdLZXkgQSBrZXkgcGFpciBvZiB0aGUgYXBwcm9wcmlhdGUgY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIFtbS2V5Q2hhaW5dXVxuICAgICAqL1xuICBhZGRLZXkgPSAobmV3S2V5OktQQ2xhc3MpID0+IHtcbiAgICBuZXdLZXkuc2V0Q2hhaW5JRCh0aGlzLmNoYWluaWQpO1xuICAgIHRoaXMua2V5c1tuZXdLZXkuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKV0gPSBuZXdLZXk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUga2V5IHBhaXIgZnJvbSB0aGUgbGlzdCBvZiB0aGV5IGtleXMgbWFuYWdlZCBpbiB0aGUgW1tLZXlDaGFpbl1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgYWRkcmVzcyBvclxuICAgICAqIEtQQ2xhc3MgdG8gcmVtb3ZlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYm9vbGVhbiB0cnVlIGlmIGEga2V5IHdhcyByZW1vdmVkLlxuICAgICAqL1xuICByZW1vdmVLZXkgPSAoa2V5OktQQ2xhc3MgfCBCdWZmZXIpID0+IHtcbiAgICBsZXQga2FkZHI6c3RyaW5nO1xuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgIGthZGRyID0ga2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2FkZHIgPSBrZXkuZ2V0QWRkcmVzcygpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB9XG4gICAgaWYgKGthZGRyIGluIHRoaXMua2V5cykge1xuICAgICAgZGVsZXRlIHRoaXMua2V5c1trYWRkcl07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIHByb3ZpZGVkIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBjaGVjayBmb3IgZXhpc3RlbmNlIGluIHRoZSBrZXlzIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIG9uIHN1Y2Nlc3MsIGZhbHNlIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICBoYXNLZXkgPSAoYWRkcmVzczpCdWZmZXIpOmJvb2xlYW4gPT4gKGFkZHJlc3MudG9TdHJpbmcoJ2hleCcpIGluIHRoaXMua2V5cyk7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgW1tLZXlQYWlyXV0gbGlzdGVkIHVuZGVyIHRoZSBwcm92aWRlZCBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgdGhlIGFkZHJlc3MgdG9cbiAgICAgKiByZXRyaWV2ZSBmcm9tIHRoZSBrZXlzIGRhdGFiYXNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHJlZmVyZW5jZSB0byB0aGUgW1tLZXlQYWlyXV0gaW4gdGhlIGtleXMgZGF0YWJhc2VcbiAgICAgKi9cbiAgZ2V0S2V5ID0gKGFkZHJlc3M6QnVmZmVyKTogS1BDbGFzcyA9PiB0aGlzLmtleXNbYWRkcmVzcy50b1N0cmluZygnaGV4JyldO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYWluSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgW1tLZXlDaGFpbl1dLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFtbS2V5Q2hhaW5dXSdzIGNoYWluSURcbiAgICAgKi9cbiAgZ2V0Q2hhaW5JRCA9ICgpOnN0cmluZyA9PiB0aGlzLmNoYWluaWQ7XG5cbiAgLyoqXG4gICAgICogU2V0cyB0aGUgdGhlIGNoYWluSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgW1tLZXlDaGFpbl1dIGFuZCBhbGwgYXNzb2NpYXRlZCBrZXlwYWlycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFpbmlkIFN0cmluZyBmb3IgdGhlIGNoYWluSURcbiAgICAgKi9cbiAgc2V0Q2hhaW5JRCA9IChjaGFpbmlkOnN0cmluZyk6dm9pZCA9PiB7XG4gICAgdGhpcy5jaGFpbmlkID0gY2hhaW5pZDtcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gdGhpcy5rZXlzKSB7XG4gICAgICB0aGlzLmtleXNbYWRkcmVzc10uc2V0Q2hhaW5JRChjaGFpbmlkKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEh1bWFuLVJlYWRhYmxlLVBhcnQgb2YgdGhlIG5ldHdvcmsgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgW1tLZXlQYWlyXV0ncyBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrJ3MgQmVjaDMyIGFkZHJlc3Npbmcgc2NoZW1lXG4gICAqL1xuICBnZXRIUlAgPSAoKTpzdHJpbmcgPT4gdGhpcy5ocnA7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGhycCBTdHJpbmcgZm9yIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIEJlY2gzMiBhZGRyZXNzZXNcbiAgICovXG4gIHNldEhSUCA9IChocnA6c3RyaW5nKTp2b2lkID0+IHtcbiAgICB0aGlzLmhycCA9IGhycDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGluc3RhbmNlIG9mIFtbS2V5Q2hhaW5dXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBocnAgU3RyaW5nIGZvciB0aGUgSHVtYW4tUmVhZGFibGUtUGFydCBvZiBCZWNoMzIgYWRkcmVzc2VzIFxuICAgICAqIEBwYXJhbSBjaGFpbmlkIFRoZSBob3N0bmFtZSB0byByZXNvbHZlIHRvIHJlYWNoIHRoZSBBdmFsYW5jaGUgQ2xpZW50IEFQSXNcbiAgICAgKiBcbiAgICAgKi9cbiAgY29uc3RydWN0b3IoaHJwOnN0cmluZywgY2hhaW5pZDpzdHJpbmcpIHtcbiAgICB0aGlzLmNoYWluaWQgPSBjaGFpbmlkO1xuICAgIHRoaXMuaHJwID0gaHJwO1xuICB9XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmFnaW5nIGFcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIGFuIGV4YWN0IGxlbmd0aC5cbiAqXG4gKiBDcmVhdGUgYSBjbGFzcyB0aGF0IGV4dGVuZHMgdGhpcyBvbmUgYW5kIG92ZXJyaWRlIGJzaXplIHRvIG1ha2UgaXQgdmFsaWRhdGUgZm9yIGV4YWN0bHlcbiAqIHRoZSBjb3JyZWN0IGxlbmd0aC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE5CeXRlcyB7XG4gIHByb3RlY3RlZCBieXRlczpCdWZmZXI7XG5cbiAgcHJvdGVjdGVkIGJzaXplOm51bWJlcjtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV4YWN0IGxlbmd0aCByZXF1aXJlbWVudCBvZiB0aGlzIGNsYXNzXG4gICAgICovXG4gIGdldFNpemUgPSAoKSA9PiB0aGlzLmJzaXplO1xuXG4gIC8qKlxuICAgICAqIFRha2VzIGEgYmFzZS01OCBlbmNvZGVkIHN0cmluZywgdmVyaWZpZXMgaXRzIGxlbmd0aCwgYW5kIHN0b3JlcyBpdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgICAqL1xuICBmcm9tU3RyaW5nKGI1OHN0cjpzdHJpbmcpOm51bWJlciB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZnJvbUJ1ZmZlcihiaW50b29scy5iNThUb0J1ZmZlcihiNThzdHIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY29uc3QgZW1zZzpzdHJpbmcgPSBgRXJyb3IgLSBOQnl0ZXMuZnJvbVN0cmluZzogJHtlfWA7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ic2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFRha2VzIGEgW1tCdWZmZXJdXSwgdmVyaWZpZXMgaXRzIGxlbmd0aCwgYW5kIHN0b3JlcyBpdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgICAqL1xuICBmcm9tQnVmZmVyKGJ1ZmY6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGJ1ZmYubGVuZ3RoIC0gb2Zmc2V0IDwgdGhpcy5ic2l6ZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJ1ZmZlciBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAke3RoaXMuYnNpemV9IGJ5dGVzLmApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ5dGVzID0gYmludG9vbHMuY29weUZyb20oYnVmZiwgb2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmJzaXplKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY29uc3QgZW1zZzpzdHJpbmcgPSBgRXJyb3IgLSBOQnl0ZXMuZnJvbUJ1ZmZlcjogJHtlfWA7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5ic2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBzdG9yZWQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICAgKi9cbiAgdG9CdWZmZXIoKTpCdWZmZXIge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAgICogQHJldHVybnMgQSBiYXNlLTU4IHN0cmluZyBvZiB0aGUgc3RvcmVkIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAgICovXG4gIHRvU3RyaW5nKCk6c3RyaW5nIHtcbiAgICByZXR1cm4gYmludG9vbHMuYnVmZmVyVG9CNTgodGhpcy50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgW1tOQnl0ZXNdXS5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxufVxuXG5leHBvcnQgY29uc3QgTmV0d29ya0lEVG9IUlA6b2JqZWN0ID0ge1xuICAxOiBcImF2YXhcIixcbiAgMjogXCJjYXNjYWRlXCIsXG4gIDM6IFwiZGVuYWxpXCIsXG4gIDQ6IFwiZXZlcmVzdFwiLFxuICAxMjM0NTogXCJsb2NhbFwiXG59O1xuXG5leHBvcnQgY29uc3QgSFJQVG9OZXR3b3JrSUQ6b2JqZWN0ID0ge1xuICBcImF2YXhcIjogMSxcbiAgXCJjYXNjYWRlXCI6IDIsXG4gIFwiZGVuYWxpXCI6IDMsXG4gIFwiZXZlcmVzdFwiOiA0LFxuICBcImxvY2FsXCI6IDEyMzQ1XG59O1xuXG5leHBvcnQgY29uc3QgRmFsbGJhY2tIUlA6c3RyaW5nID0gXCJjdXN0b21cIjtcblxuZXhwb3J0IGNvbnN0IERlZmF1bHROZXR3b3JrSUQ6bnVtYmVyID0gMztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByZWZlcnJlZEhSUChuZXR3b3JrSUQ6bnVtYmVyID0gdW5kZWZpbmVkKSB7XG4gIGlmIChuZXR3b3JrSUQgaW4gTmV0d29ya0lEVG9IUlApIHtcbiAgICByZXR1cm4gTmV0d29ya0lEVG9IUlBbbmV0d29ya0lEXTtcbiAgfSBlbHNlIGlmKHR5cGVvZiBuZXR3b3JrSUQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gRGVmYXVsdE5ldHdvcmtJRDtcbiAgfVxuICByZXR1cm4gRmFsbGJhY2tIUlA7XG59XG5cbi8vIFRPRE86IFVQREFURSBGT1IgTUFJTk5FVFxuXG5jb25zdCBuMUF2bTpvYmplY3QgPSB7XG4gIGJsb2NrY2hhaW5JRDogJzRrdFJqc0FLeGdNcjJhRXp2OVNXbXJVN1hrNUZuaUhVclZDWDRQMVRaU2ZUTFpXRk0nLFxuICBhbGlhczogJ1gnLFxuICB2bTogJ2F2bScsXG4gIGZlZTogMFxufTtcblxuY29uc3QgbjFQbGF0Zm9ybTpvYmplY3QgPSB7XG4gIGJsb2NrY2hhaW5JRDogJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExTHBvWVknLFxuICBhbGlhczogJ1AnLFxuICB2bTogJ3BsYXRmb3JtJyxcbiAgZmVlOiAwXG59O1xuXG5jb25zdCBuMUNvbnRyYWN0czpvYmplY3QgPSB7XG4gIGJsb2NrY2hhaW5JRDogJzJtVVlTWGZMckR0aWd3YnpqMUx4S1ZzSHdFTGdoYzVzaXNvWHJ6SndMcUFBUUhGNGknLFxuICBhbGlhczogJ0MnLFxuICB2bTogJ2NvbnRyYWN0cycsXG4gIGZlZTogMFxufTtcblxuLy8gRU5EIFRPRE9cblxuY29uc3QgbjJBdm06b2JqZWN0ID0ge1xuICBibG9ja2NoYWluSUQ6ICc0a3RSanNBS3hnTXIyYUV6djlTV21yVTdYazVGbmlIVXJWQ1g0UDFUWlNmVExaV0ZNJyxcbiAgYWxpYXM6ICdYJyxcbiAgdm06ICdhdm0nLFxuICBmZWU6IDBcbn07XG5cbmNvbnN0IG4yUGxhdGZvcm06b2JqZWN0ID0ge1xuICBibG9ja2NoYWluSUQ6ICcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMUxwb1lZJyxcbiAgYWxpYXM6ICdQJyxcbiAgdm06ICdwbGF0Zm9ybScsXG4gIGZlZTogMFxufTtcblxuY29uc3QgbjJDb250cmFjdHM6b2JqZWN0ID0ge1xuICBibG9ja2NoYWluSUQ6ICcybVVZU1hmTHJEdGlnd2J6ajFMeEtWc0h3RUxnaGM1c2lzb1hyekp3THFBQVFIRjRpJyxcbiAgYWxpYXM6ICdDJyxcbiAgdm06ICdjb250cmFjdHMnLFxuICBmZWU6IDBcbn07XG5cbmNvbnN0IG4zQXZtOm9iamVjdCA9IHtcbiAgYmxvY2tjaGFpbklEOiAncnJFV1g3Z2M3RDltd2NkcmRCeEJUZHFoMWE3V0RWc011YWRoVFpneVhmRmNSejQ1TCcsXG4gIGFsaWFzOiAnWCcsXG4gIHZtOiAnYXZtJyxcbiAgZmVlOiAwXG59O1xuXG5jb25zdCBuM1BsYXRmb3JtOm9iamVjdCA9IHtcbiAgYmxvY2tjaGFpbklEOiAnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFMcG9ZWScsXG4gIGFsaWFzOiAnUCcsXG4gIHZtOiAncGxhdGZvcm0nLFxuICBmZWU6IDBcbn07XG5cbmNvbnN0IG4zQ29udHJhY3RzOm9iamVjdCA9IHtcbiAgYmxvY2tjaGFpbklEOiAnekp5dG5oOTZQYzhyTTMzN2JCcnRNdkpEYkVkRE5qY1hHM1drVE5DaUxwMThlcmdtOScsXG4gIGFsaWFzOiAnQycsXG4gIHZtOiAnY29udHJhY3RzJyxcbiAgZmVlOiAwXG59O1xuXG4vLyBUT0RPOiBVUERBVEUgRk9SIEVWRVJFU1RcbmNvbnN0IG40QXZtOm9iamVjdCA9IHtcbiAgYmxvY2tjaGFpbklEOiAncnJFV1g3Z2M3RDltd2NkcmRCeEJUZHFoMWE3V0RWc011YWRoVFpneVhmRmNSejQ1TCcsXG4gIGFsaWFzOiAnWCcsXG4gIHZtOiAnYXZtJyxcbiAgZmVlOiAwXG59O1xuXG5jb25zdCBuNFBsYXRmb3JtOm9iamVjdCA9IHtcbiAgYmxvY2tjaGFpbklEOiAnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFMcG9ZWScsXG4gIGFsaWFzOiAnUCcsXG4gIHZtOiAncGxhdGZvcm0nLFxuICBmZWU6IDBcbn07XG5cbmNvbnN0IG40Q29udHJhY3RzOm9iamVjdCA9IHtcbiAgYmxvY2tjaGFpbklEOiAnekp5dG5oOTZQYzhyTTMzN2JCcnRNdkpEYkVkRE5qY1hHM1drVE5DaUxwMThlcmdtOScsXG4gIGFsaWFzOiAnQycsXG4gIHZtOiAnY29udHJhY3RzJyxcbiAgZmVlOiAwXG59O1xuXG4vLyBFTkQgVE9ET1xuXG5jb25zdCBuMTIzNDVBdm06YW55ID0geyAuLi5uMkF2bSB9O1xubjEyMzQ1QXZtLmJsb2NrY2hhaW5JRCA9ICcyb0FMZDZ4b1VNcDNvU0hNaUpZVnFNY2JhV3hHUVdZb3NyZmlUN0FhRktLTkc1ZG1LRCc7XG5jb25zdCBuMTIzNDVQbGF0Zm9ybTphbnkgPSB7IC4uLm4yUGxhdGZvcm0gfTtcbm4xMjM0NVBsYXRmb3JtLmJsb2NrY2hhaW5JRCA9ICcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMUxwb1lZJztcbmNvbnN0IG4xMjM0NUNvbnRyYWN0czphbnkgPSB7IC4uLm4yQ29udHJhY3RzIH07XG5uMTIzNDVDb250cmFjdHMuYmxvY2tjaGFpbklEID0gJ3RaR202UkNrZUdwVkVUVVRwMTFEVzNVWUZabW02OXpmcXhjaHBIclNGN3dneThybXcnO1xuXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBzdGF0aWMgbmV0d29yayA9IHtcbiAgICAxOiB7IC8vIHVwZGF0ZSBiZWZvcmUgbWFpbm5ldFxuICAgICAgaHJwOiBOZXR3b3JrSURUb0hSUFsxXSxcbiAgICAgIGF2bTogbjFBdm0sXG4gICAgICBYOiBuMUF2bSxcbiAgICAgICc0a3RSanNBS3hnTXIyYUV6djlTV21yVTdYazVGbmlIVXJWQ1g0UDFUWlNmVExaV0ZNJzogbjFBdm0sXG4gICAgICBwbGF0Zm9ybTogbjFQbGF0Zm9ybSxcbiAgICAgIFA6IG4xUGxhdGZvcm0sXG4gICAgICAnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFMcG9ZWSc6IG4xUGxhdGZvcm0sXG4gICAgICBjb250cmFjdHM6IG4xQ29udHJhY3RzLFxuICAgICAgQzogbjFDb250cmFjdHMsXG4gICAgICAnMm1VWVNYZkxyRHRpZ3diemoxTHhLVnNId0VMZ2hjNXNpc29YcnpKd0xxQUFRSEY0aSc6IG4xQ29udHJhY3RzLFxuICAgIH0sIFxuICAgIDI6IHtcbiAgICAgIGhycDogTmV0d29ya0lEVG9IUlBbMl0sXG4gICAgICBhdm06IG4yQXZtLFxuICAgICAgWDogbjJBdm0sXG4gICAgICAnNGt0UmpzQUt4Z01yMmFFenY5U1dtclU3WGs1Rm5pSFVyVkNYNFAxVFpTZlRMWldGTSc6IG4yQXZtLFxuICAgICAgcGxhdGZvcm06IG4yUGxhdGZvcm0sXG4gICAgICBQOiBuMlBsYXRmb3JtLFxuICAgICAgJzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExTHBvWVknOiBuMlBsYXRmb3JtLFxuICAgICAgY29udHJhY3RzOiBuMkNvbnRyYWN0cyxcbiAgICAgIEM6IG4yQ29udHJhY3RzLFxuICAgICAgJzJtVVlTWGZMckR0aWd3YnpqMUx4S1ZzSHdFTGdoYzVzaXNvWHJ6SndMcUFBUUhGNGknOiBuMkNvbnRyYWN0cyxcbiAgICB9LFxuICAgIDM6IHtcbiAgICAgIGhycDogTmV0d29ya0lEVG9IUlBbM10sXG4gICAgICBhdm06IG4zQXZtLFxuICAgICAgWDogbjNBdm0sXG4gICAgICByckVXWDdnYzdEOW13Y2RyZEJ4QlRkcWgxYTdXRFZzTXVhZGhUWmd5WGZGY1J6NDVMOiBuM0F2bSxcbiAgICAgIHBsYXRmb3JtOiBuM1BsYXRmb3JtLFxuICAgICAgUDogbjNQbGF0Zm9ybSxcbiAgICAgICcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMUxwb1lZJzogbjNQbGF0Zm9ybSxcbiAgICAgIGNvbnRyYWN0czogbjNDb250cmFjdHMsXG4gICAgICBDOiBuM0NvbnRyYWN0cyxcbiAgICAgIHpKeXRuaDk2UGM4ck0zMzdiQnJ0TXZKRGJFZEROamNYRzNXa1ROQ2lMcDE4ZXJnbTk6IG4zQ29udHJhY3RzLFxuICAgIH0sXG4gICAgNDogeyAvLyB1cGRhdGUgYmVmb3JlIGV2ZXJlc3RcbiAgICAgIGhycDogTmV0d29ya0lEVG9IUlBbNF0sXG4gICAgICBhdm06IG40QXZtLFxuICAgICAgWDogbjRBdm0sXG4gICAgICByckVXWDdnYzdEOW13Y2RyZEJ4QlRkcWgxYTdXRFZzTXVhZGhUWmd5WGZGY1J6NDVMOiBuNEF2bSxcbiAgICAgIHBsYXRmb3JtOiBuNFBsYXRmb3JtLFxuICAgICAgUDogbjRQbGF0Zm9ybSxcbiAgICAgICcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMUxwb1lZJzogbjRQbGF0Zm9ybSxcbiAgICAgIGNvbnRyYWN0czogbjRDb250cmFjdHMsXG4gICAgICBDOiBuNENvbnRyYWN0cyxcbiAgICAgIHpKeXRuaDk2UGM4ck0zMzdiQnJ0TXZKRGJFZEROamNYRzNXa1ROQ2lMcDE4ZXJnbTk6IG40Q29udHJhY3RzLFxuICAgIH0sXG4gICAgMTIzNDU6IHtcbiAgICAgIGhycDogTmV0d29ya0lEVG9IUlBbMTIzNDVdLFxuICAgICAgYXZtOiBuMTIzNDVBdm0sXG4gICAgICBYOiBuMTIzNDVBdm0sXG4gICAgICAnMm9BTGQ2eG9VTXAzb1NITWlKWVZxTWNiYVd4R1FXWW9zcmZpVDdBYUZLS05HNWRtS0QnOiBuMTIzNDVBdm0sXG4gICAgICBwbGF0Zm9ybTogbjEyMzQ1UGxhdGZvcm0sXG4gICAgICBQOiBuMTIzNDVQbGF0Zm9ybSxcbiAgICAgICcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMUxwb1lZJzogbjEyMzQ1UGxhdGZvcm0sXG4gICAgICBjb250cmFjdHM6IG4xMjM0NUNvbnRyYWN0cyxcbiAgICAgIEM6IG4xMjM0NUNvbnRyYWN0cyxcbiAgICAgIHRaR202UkNrZUdwVkVUVVRwMTFEVzNVWUZabW02OXpmcXhjaHBIclNGN3dneThybXc6IG4xMjM0NUNvbnRyYWN0cyxcbiAgICB9LFxuICB9O1xufVxuIl19