"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 * @module AvalancheCore
 */
const axios_1 = __importDefault(require("axios"));
const types_1 = require("./utils/types");
/**
 * AvalancheCore is middleware for interacting with Avalanche node RPC APIs.
 *
 * Example usage:
 * ```js
 * let avalanche = new AvalancheCore("127.0.0.1", 9650, "https");
 * ```
 *
 */
class AvalancheCore {
    /**
       * Creates a new Avalanche instance. Sets the address and port of the main Avalanche Client.
       *
       * @param ip The hostname to resolve to reach the Avalanche Client APIs
       * @param port The port to resolve to reach the Avalanche Client APIs
       * @param protocol The protocol string to use before a "://" in a request, ex: "http", "https", "git", "ws", etc ...
       */
    constructor(ip, port, protocol = 'http') {
        this.networkID = 0;
        this.hrp = '';
        this.apis = {};
        /**
           * Sets the address and port of the main Avalanche Client.
           *
           * @param ip The hostname to resolve to reach the Avalanche Client RPC APIs
           * @param port The port to resolve to reach the Avalanche Client RPC APIs
           * @param protocol The protocol string to use before a "://" in a request,
           * ex: "http", "https", "git", "ws", etc ...
           */
        this.setAddress = (ip, port, protocol = 'http') => {
            this.ip = ip;
            this.port = port;
            this.protocol = protocol;
            this.url = `${protocol}://${ip}:${port}`;
        };
        /**
           * Returns the protocol such as "http", "https", "git", "ws", etc.
           */
        this.getProtocol = () => this.protocol;
        /**
           * Returns the IP for the Avalanche node.
           */
        this.getIP = () => this.ip;
        /**
           * Returns the port for the Avalanche node.
           */
        this.getPort = () => this.port;
        /**
           * Returns the URL of the Avalanche node (ip + port);
           */
        this.getURL = () => this.url;
        /**
           * Returns the networkID;
           */
        this.getNetworkID = () => this.networkID;
        /**
           * Sets the networkID
           */
        this.setNetworkID = (netid) => {
            this.networkID = netid;
            this.hrp = types_1.getPreferredHRP(this.networkID);
        };
        /**
         * Returns the Human-Readable-Part of the network associated with this key.
         *
         * @returns The [[KeyPair]]'s Human-Readable-Part of the network's Bech32 addressing scheme
         */
        this.getHRP = () => this.hrp;
        /**
         * Sets the the Human-Readable-Part of the network associated with this key.
         *
         * @param hrp String for the Human-Readable-Part of Bech32 addresses
         */
        this.setHRP = (hrp) => {
            this.hrp = hrp;
        };
        /**
           * Adds an API to the middleware. The API resolves to a registered blockchain's RPC.
           *
           * In TypeScript:
           * ```js
           * avalanche.addAPI<MyVMClass>("mychain", MyVMClass, "/ext/bc/mychain");
           * ```
           *
           * In Javascript:
           * ```js
           * avalanche.addAPI("mychain", MyVMClass, "/ext/bc/mychain");
           * ```
           *
           * @typeparam GA Class of the API being added
           * @param apiName A label for referencing the API in the future
           * @param constructorFN A reference to the class which instantiates the API
           * @param baseurl Path to resolve to reach the API
           *
           */
        this.addAPI = (apiName, ConstructorFN, baseurl = undefined, ...args) => {
            if (typeof baseurl === 'undefined') {
                this.apis[apiName] = new ConstructorFN(this, undefined, ...args);
            }
            else {
                this.apis[apiName] = new ConstructorFN(this, baseurl, ...args);
            }
        };
        /**
           * Retrieves a reference to an API by its apiName label.
           *
           * @param apiName Name of the API to return
           */
        this.api = (apiName) => this.apis[apiName];
        /**
           * @ignore
           */
        this._request = (xhrmethod, baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => __awaiter(this, void 0, void 0, function* () {
            let config;
            if (axiosConfig) {
                config = axiosConfig;
            }
            else {
                config = {
                    baseURL: `${this.protocol}://${this.ip}:${this.port}`,
                    responseType: 'text',
                };
            }
            config.url = baseurl;
            config.method = xhrmethod;
            config.headers = headers;
            config.data = postdata;
            config.params = getdata;
            return axios_1.default.request(config).then((resp) => {
                // purging all that is axios
                const xhrdata = new types_1.RequestResponseData();
                xhrdata.data = resp.data;
                xhrdata.headers = resp.headers;
                xhrdata.request = resp.request;
                xhrdata.status = resp.status;
                xhrdata.statusText = resp.statusText;
                return xhrdata;
            });
        });
        /**
           * Makes a GET call to an API.
           *
           * @param baseurl Path to the api
           * @param getdata Object containing the key value pairs sent in GET
           * @param parameters Object containing the parameters of the API call
           * @param headers An array HTTP Request Headers
           * @param axiosConfig Configuration for the axios javascript library that will be the
           * foundation for the rest of the parameters
           *
           * @returns A promise for [[RequestResponseData]]
           */
        this.get = (baseurl, getdata, headers = {}, axiosConfig = undefined) => this._request('GET', baseurl, getdata, {}, headers, axiosConfig);
        /**
           * Makes a DELETE call to an API.
           *
           * @param baseurl Path to the API
           * @param getdata Object containing the key value pairs sent in DELETE
           * @param parameters Object containing the parameters of the API call
           * @param headers An array HTTP Request Headers
           * @param axiosConfig Configuration for the axios javascript library that will be the
           * foundation for the rest of the parameters
           *
           * @returns A promise for [[RequestResponseData]]
           */
        this.delete = (baseurl, getdata, headers = {}, axiosConfig = undefined) => this._request('DELETE', baseurl, getdata, {}, headers, axiosConfig);
        /**
           * Makes a POST call to an API.
           *
           * @param baseurl Path to the API
           * @param getdata Object containing the key value pairs sent in POST
           * @param postdata Object containing the key value pairs sent in POST
           * @param parameters Object containing the parameters of the API call
           * @param headers An array HTTP Request Headers
           * @param axiosConfig Configuration for the axios javascript library that will be the
           * foundation for the rest of the parameters
           *
           * @returns A promise for [[RequestResponseData]]
           */
        this.post = (baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => this._request('POST', baseurl, getdata, postdata, headers, axiosConfig);
        /**
           * Makes a PUT call to an API.
           *
           * @param baseurl Path to the baseurl
           * @param getdata Object containing the key value pairs sent in PUT
           * @param postdata Object containing the key value pairs sent in PUT
           * @param parameters Object containing the parameters of the API call
           * @param headers An array HTTP Request Headers
           * @param axiosConfig Configuration for the axios javascript library that will be the
           * foundation for the rest of the parameters
           *
           * @returns A promise for [[RequestResponseData]]
           */
        this.put = (baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => this._request('PUT', baseurl, getdata, postdata, headers, axiosConfig);
        /**
           * Makes a PATCH call to an API.
           *
           * @param baseurl Path to the baseurl
           * @param getdata Object containing the key value pairs sent in PATCH
           * @param postdata Object containing the key value pairs sent in PATCH
           * @param parameters Object containing the parameters of the API call
           * @param headers An array HTTP Request Headers
           * @param axiosConfig Configuration for the axios javascript library that will be the
           * foundation for the rest of the parameters
           *
           * @returns A promise for [[RequestResponseData]]
           */
        this.patch = (baseurl, getdata, postdata, headers = {}, axiosConfig = undefined) => this._request('PATCH', baseurl, getdata, postdata, headers, axiosConfig);
        this.setAddress(ip, port, protocol);
    }
}
exports.default = AvalancheCore;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZhbGFuY2hlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2F2YWxhbmNoZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBOzs7R0FHRztBQUNILGtEQUF5RTtBQUN6RSx5Q0FBOEU7QUFFOUU7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFxQixhQUFhO0lBZ1JoQzs7Ozs7O1NBTUs7SUFDTCxZQUFZLEVBQVMsRUFBRSxJQUFXLEVBQUUsV0FBa0IsTUFBTTtRQXRSbEQsY0FBUyxHQUFVLENBQUMsQ0FBQztRQUVyQixRQUFHLEdBQVUsRUFBRSxDQUFDO1FBVWhCLFNBQUksR0FBNEIsRUFBRSxDQUFDO1FBRTdDOzs7Ozs7O2FBT0s7UUFDTCxlQUFVLEdBQUcsQ0FBQyxFQUFTLEVBQUUsSUFBVyxFQUFFLFdBQWtCLE1BQU0sRUFBRSxFQUFFO1lBQ2hFLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7WUFDakIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7WUFDekIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLFFBQVEsTUFBTSxFQUFFLElBQUksSUFBSSxFQUFFLENBQUM7UUFDM0MsQ0FBQyxDQUFDO1FBRUY7O2FBRUs7UUFDTCxnQkFBVyxHQUFHLEdBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFekM7O2FBRUs7UUFDTCxVQUFLLEdBQUcsR0FBVSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUU3Qjs7YUFFSztRQUNMLFlBQU8sR0FBRyxHQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBRWpDOzthQUVLO1FBQ0wsV0FBTSxHQUFHLEdBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7UUFFL0I7O2FBRUs7UUFDTCxpQkFBWSxHQUFHLEdBQVUsRUFBRSxDQUFDLElBQUksQ0FB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USxFQUNSLE9BQU8sRUFDUCxXQUFXLENBQUMsQ0FBQztRQVViLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN0QyxDQUFDO0NBQ0Y7QUExUkQsZ0NBMFJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQXZhbGFuY2hlQ29yZVxuICovXG5pbXBvcnQgYXhpb3MsIHsgQXhpb3NSZXF1ZXN0Q29uZmlnLCBBeGlvc1Jlc3BvbnNlLCBNZXRob2QgfSBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBBUElCYXNlLCBSZXF1ZXN0UmVzcG9uc2VEYXRhLCBnZXRQcmVmZXJyZWRIUlAgfSBmcm9tICcuL3V0aWxzL3R5cGVzJztcblxuLyoqXG4gKiBBdmFsYW5jaGVDb3JlIGlzIG1pZGRsZXdhcmUgZm9yIGludGVyYWN0aW5nIHdpdGggQXZhbGFuY2hlIG5vZGUgUlBDIEFQSXMuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIGBgYGpzXG4gKiBsZXQgYXZhbGFuY2hlID0gbmV3IEF2YWxhbmNoZUNvcmUoXCIxMjcuMC4wLjFcIiwgOTY1MCwgXCJodHRwc1wiKTtcbiAqIGBgYFxuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXZhbGFuY2hlQ29yZSB7XG4gIHByb3RlY3RlZCBuZXR3b3JrSUQ6bnVtYmVyID0gMDtcblxuICBwcm90ZWN0ZWQgaHJwOnN0cmluZyA9ICcnO1xuXG4gIHByb3RlY3RlZCBwcm90b2NvbDpzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGlwOnN0cmluZztcblxuICBwcm90ZWN0ZWQgcG9ydDpudW1iZXI7XG5cbiAgcHJvdGVjdGVkIHVybDpzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGFwaXM6eyBbazogc3RyaW5nXTogQVBJQmFzZSB9ID0ge307XG5cbiAgLyoqXG4gICAgICogU2V0cyB0aGUgYWRkcmVzcyBhbmQgcG9ydCBvZiB0aGUgbWFpbiBBdmFsYW5jaGUgQ2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlwIFRoZSBob3N0bmFtZSB0byByZXNvbHZlIHRvIHJlYWNoIHRoZSBBdmFsYW5jaGUgQ2xpZW50IFJQQyBBUElzXG4gICAgICogQHBhcmFtIHBvcnQgVGhlIHBvcnQgdG8gcmVzb2x2ZSB0byByZWFjaCB0aGUgQXZhbGFuY2hlIENsaWVudCBSUEMgQVBJc1xuICAgICAqIEBwYXJhbSBwcm90b2NvbCBUaGUgcHJvdG9jb2wgc3RyaW5nIHRvIHVzZSBiZWZvcmUgYSBcIjovL1wiIGluIGEgcmVxdWVzdCxcbiAgICAgKiBleDogXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJnaXRcIiwgXCJ3c1wiLCBldGMgLi4uXG4gICAgICovXG4gIHNldEFkZHJlc3MgPSAoaXA6c3RyaW5nLCBwb3J0Om51bWJlciwgcHJvdG9jb2w6c3RyaW5nID0gJ2h0dHAnKSA9PiB7XG4gICAgdGhpcy5pcCA9IGlwO1xuICAgIHRoaXMucG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIHRoaXMudXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtpcH06JHtwb3J0fWA7XG4gIH07XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvdG9jb2wgc3VjaCBhcyBcImh0dHBcIiwgXCJodHRwc1wiLCBcImdpdFwiLCBcIndzXCIsIGV0Yy5cbiAgICAgKi9cbiAgZ2V0UHJvdG9jb2wgPSAoKTpzdHJpbmcgPT4gdGhpcy5wcm90b2NvbDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJUCBmb3IgdGhlIEF2YWxhbmNoZSBub2RlLlxuICAgICAqL1xuICBnZXRJUCA9ICgpOnN0cmluZyA9PiB0aGlzLmlwO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvcnQgZm9yIHRoZSBBdmFsYW5jaGUgbm9kZS5cbiAgICAgKi9cbiAgZ2V0UG9ydCA9ICgpOm51bWJlciA9PiB0aGlzLnBvcnQ7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSBBdmFsYW5jaGUgbm9kZSAoaXAgKyBwb3J0KTtcbiAgICAgKi9cbiAgZ2V0VVJMID0gKCk6c3RyaW5nID0+IHRoaXMudXJsO1xuXG4gIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmtJRDtcbiAgICAgKi9cbiAgZ2V0TmV0d29ya0lEID0gKCk6bnVtYmVyID0+IHRoaXMubmV0d29ya0lEO1xuXG4gIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldHdvcmtJRFxuICAgICAqL1xuICBzZXROZXR3b3JrSUQgPSAobmV0aWQ6bnVtYmVyKSA9PiB7XG4gICAgdGhpcy5uZXR3b3JrSUQgPSBuZXRpZDtcbiAgICB0aGlzLmhycCA9IGdldFByZWZlcnJlZEhSUCh0aGlzLm5ldHdvcmtJRCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEh1bWFuLVJlYWRhYmxlLVBhcnQgb2YgdGhlIG5ldHdvcmsgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgW1tLZXlQYWlyXV0ncyBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrJ3MgQmVjaDMyIGFkZHJlc3Npbmcgc2NoZW1lXG4gICAqL1xuICBnZXRIUlAgPSAoKTpzdHJpbmcgPT4gdGhpcy5ocnA7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIHRoZSBuZXR3b3JrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGhycCBTdHJpbmcgZm9yIHRoZSBIdW1hbi1SZWFkYWJsZS1QYXJ0IG9mIEJlY2gzMiBhZGRyZXNzZXNcbiAgICovXG4gIHNldEhSUCA9IChocnA6c3RyaW5nKTp2b2lkID0+IHtcbiAgICB0aGlzLmhycCA9IGhycDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBBZGRzIGFuIEFQSSB0byB0aGUgbWlkZGxld2FyZS4gVGhlIEFQSSByZXNvbHZlcyB0byBhIHJlZ2lzdGVyZWQgYmxvY2tjaGFpbidzIFJQQy5cbiAgICAgKlxuICAgICAqIEluIFR5cGVTY3JpcHQ6XG4gICAgICogYGBganNcbiAgICAgKiBhdmFsYW5jaGUuYWRkQVBJPE15Vk1DbGFzcz4oXCJteWNoYWluXCIsIE15Vk1DbGFzcywgXCIvZXh0L2JjL215Y2hhaW5cIik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJbiBKYXZhc2NyaXB0OlxuICAgICAqIGBgYGpzXG4gICAgICogYXZhbGFuY2hlLmFkZEFQSShcIm15Y2hhaW5cIiwgTXlWTUNsYXNzLCBcIi9leHQvYmMvbXljaGFpblwiKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gR0EgQ2xhc3Mgb2YgdGhlIEFQSSBiZWluZyBhZGRlZFxuICAgICAqIEBwYXJhbSBhcGlOYW1lIEEgbGFiZWwgZm9yIHJlZmVyZW5jaW5nIHRoZSBBUEkgaW4gdGhlIGZ1dHVyZVxuICAgICAqIEBwYXJhbSBjb25zdHJ1Y3RvckZOIEEgcmVmZXJlbmNlIHRvIHRoZSBjbGFzcyB3aGljaCBpbnN0YW50aWF0ZXMgdGhlIEFQSVxuICAgICAqIEBwYXJhbSBiYXNldXJsIFBhdGggdG8gcmVzb2x2ZSB0byByZWFjaCB0aGUgQVBJXG4gICAgICpcbiAgICAgKi9cbiAgYWRkQVBJID0gPEdBIGV4dGVuZHMgQVBJQmFzZT4oYXBpTmFtZTpzdHJpbmcsXG4gICAgQ29uc3RydWN0b3JGTjogbmV3KGF2YXg6QXZhbGFuY2hlQ29yZSwgYmFzZXVybD86c3RyaW5nLCAuLi5hcmdzOkFycmF5PGFueT4pID0+IEdBLFxuICAgIGJhc2V1cmw6c3RyaW5nID0gdW5kZWZpbmVkLFxuICAgIC4uLmFyZ3M6QXJyYXk8YW55PikgPT4ge1xuICAgIGlmICh0eXBlb2YgYmFzZXVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuYXBpc1thcGlOYW1lXSA9IG5ldyBDb25zdHJ1Y3RvckZOKHRoaXMsIHVuZGVmaW5lZCwgLi4uYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBpc1thcGlOYW1lXSA9IG5ldyBDb25zdHJ1Y3RvckZOKHRoaXMsIGJhc2V1cmwsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSByZWZlcmVuY2UgdG8gYW4gQVBJIGJ5IGl0cyBhcGlOYW1lIGxhYmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwaU5hbWUgTmFtZSBvZiB0aGUgQVBJIHRvIHJldHVyblxuICAgICAqL1xuICBhcGkgPSA8R0EgZXh0ZW5kcyBBUElCYXNlPihhcGlOYW1lOnN0cmluZyk6IEdBID0+IHRoaXMuYXBpc1thcGlOYW1lXSBhcyBHQTtcblxuICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gIHByb3RlY3RlZCBfcmVxdWVzdCA9IGFzeW5jICh4aHJtZXRob2Q6TWV0aG9kLFxuICAgIGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIHBvc3RkYXRhOnN0cmluZyB8IG9iamVjdCB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKTogUHJvbWlzZTxSZXF1ZXN0UmVzcG9uc2VEYXRhPiA9PiB7XG4gICAgbGV0IGNvbmZpZzpBeGlvc1JlcXVlc3RDb25maWc7XG4gICAgaWYgKGF4aW9zQ29uZmlnKSB7XG4gICAgICBjb25maWcgPSBheGlvc0NvbmZpZztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0ge1xuICAgICAgICBiYXNlVVJMOiBgJHt0aGlzLnByb3RvY29sfTovLyR7dGhpcy5pcH06JHt0aGlzLnBvcnR9YCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25maWcudXJsID0gYmFzZXVybDtcbiAgICBjb25maWcubWV0aG9kID0geGhybWV0aG9kO1xuICAgIGNvbmZpZy5oZWFkZXJzID0gaGVhZGVycztcbiAgICBjb25maWcuZGF0YSA9IHBvc3RkYXRhO1xuICAgIGNvbmZpZy5wYXJhbXMgPSBnZXRkYXRhO1xuICAgIHJldHVybiBheGlvcy5yZXF1ZXN0KGNvbmZpZykudGhlbigocmVzcDpBeGlvc1Jlc3BvbnNlPGFueT4pID0+IHtcbiAgICAgIC8vIHB1cmdpbmcgYWxsIHRoYXQgaXMgYXhpb3NcbiAgICAgIGNvbnN0IHhocmRhdGE6UmVxdWVzdFJlc3BvbnNlRGF0YSA9IG5ldyBSZXF1ZXN0UmVzcG9uc2VEYXRhKCk7XG4gICAgICB4aHJkYXRhLmRhdGEgPSByZXNwLmRhdGE7XG4gICAgICB4aHJkYXRhLmhlYWRlcnMgPSByZXNwLmhlYWRlcnM7XG4gICAgICB4aHJkYXRhLnJlcXVlc3QgPSByZXNwLnJlcXVlc3Q7XG4gICAgICB4aHJkYXRhLnN0YXR1cyA9IHJlc3Auc3RhdHVzO1xuICAgICAgeGhyZGF0YS5zdGF0dXNUZXh0ID0gcmVzcC5zdGF0dXNUZXh0O1xuICAgICAgcmV0dXJuIHhocmRhdGE7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogTWFrZXMgYSBHRVQgY2FsbCB0byBhbiBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIHRvIHRoZSBhcGlcbiAgICAgKiBAcGFyYW0gZ2V0ZGF0YSBPYmplY3QgY29udGFpbmluZyB0aGUga2V5IHZhbHVlIHBhaXJzIHNlbnQgaW4gR0VUXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIEFQSSBjYWxsXG4gICAgICogQHBhcmFtIGhlYWRlcnMgQW4gYXJyYXkgSFRUUCBSZXF1ZXN0IEhlYWRlcnNcbiAgICAgKiBAcGFyYW0gYXhpb3NDb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIGF4aW9zIGphdmFzY3JpcHQgbGlicmFyeSB0aGF0IHdpbGwgYmUgdGhlXG4gICAgICogZm91bmRhdGlvbiBmb3IgdGhlIHJlc3Qgb2YgdGhlIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgW1tSZXF1ZXN0UmVzcG9uc2VEYXRhXV1cbiAgICAgKi9cbiAgZ2V0ID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnR0VUJyxcbiAgICBiYXNldXJsLFxuICAgIGdldGRhdGEsXG4gICAge30sXG4gICAgaGVhZGVycyxcbiAgICBheGlvc0NvbmZpZyk7XG5cbiAgLyoqXG4gICAgICogTWFrZXMgYSBERUxFVEUgY2FsbCB0byBhbiBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIHRvIHRoZSBBUElcbiAgICAgKiBAcGFyYW0gZ2V0ZGF0YSBPYmplY3QgY29udGFpbmluZyB0aGUga2V5IHZhbHVlIHBhaXJzIHNlbnQgaW4gREVMRVRFXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIEFQSSBjYWxsXG4gICAgICogQHBhcmFtIGhlYWRlcnMgQW4gYXJyYXkgSFRUUCBSZXF1ZXN0IEhlYWRlcnNcbiAgICAgKiBAcGFyYW0gYXhpb3NDb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIGF4aW9zIGphdmFzY3JpcHQgbGlicmFyeSB0aGF0IHdpbGwgYmUgdGhlXG4gICAgICogZm91bmRhdGlvbiBmb3IgdGhlIHJlc3Qgb2YgdGhlIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSBmb3IgW1tSZXF1ZXN0UmVzcG9uc2VEYXRhXV1cbiAgICAgKi9cbiAgZGVsZXRlID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnREVMRVRFJyxcbiAgICBiYXNldXJsLFxuICAgIGdldGRhdGEsXG4gICAge30sXG4gICAgaGVhZGVycyxcbiAgICBheGlvc0NvbmZpZyk7XG5cbiAgLyoqXG4gICAgICogTWFrZXMgYSBQT1NUIGNhbGwgdG8gYW4gQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhc2V1cmwgUGF0aCB0byB0aGUgQVBJXG4gICAgICogQHBhcmFtIGdldGRhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB2YWx1ZSBwYWlycyBzZW50IGluIFBPU1RcbiAgICAgKiBAcGFyYW0gcG9zdGRhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB2YWx1ZSBwYWlycyBzZW50IGluIFBPU1RcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyBPYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBvZiB0aGUgQVBJIGNhbGxcbiAgICAgKiBAcGFyYW0gaGVhZGVycyBBbiBhcnJheSBIVFRQIFJlcXVlc3QgSGVhZGVyc1xuICAgICAqIEBwYXJhbSBheGlvc0NvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgYXhpb3MgamF2YXNjcmlwdCBsaWJyYXJ5IHRoYXQgd2lsbCBiZSB0aGVcbiAgICAgKiBmb3VuZGF0aW9uIGZvciB0aGUgcmVzdCBvZiB0aGUgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIGZvciBbW1JlcXVlc3RSZXNwb25zZURhdGFdXVxuICAgICAqL1xuICBwb3N0ID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIHBvc3RkYXRhOnN0cmluZyB8IG9iamVjdCB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnUE9TVCcsXG4gICAgYmFzZXVybCxcbiAgICBnZXRkYXRhLFxuICAgIHBvc3RkYXRhLFxuICAgIGhlYWRlcnMsXG4gICAgYXhpb3NDb25maWcpO1xuXG4gIC8qKlxuICAgICAqIE1ha2VzIGEgUFVUIGNhbGwgdG8gYW4gQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhc2V1cmwgUGF0aCB0byB0aGUgYmFzZXVybFxuICAgICAqIEBwYXJhbSBnZXRkYXRhIE9iamVjdCBjb250YWluaW5nIHRoZSBrZXkgdmFsdWUgcGFpcnMgc2VudCBpbiBQVVRcbiAgICAgKiBAcGFyYW0gcG9zdGRhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB2YWx1ZSBwYWlycyBzZW50IGluIFBVVFxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIE9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBBUEkgY2FsbFxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIGFycmF5IEhUVFAgUmVxdWVzdCBIZWFkZXJzXG4gICAgICogQHBhcmFtIGF4aW9zQ29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBheGlvcyBqYXZhc2NyaXB0IGxpYnJhcnkgdGhhdCB3aWxsIGJlIHRoZVxuICAgICAqIGZvdW5kYXRpb24gZm9yIHRoZSByZXN0IG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgZm9yIFtbUmVxdWVzdFJlc3BvbnNlRGF0YV1dXG4gICAgICovXG4gIHB1dCA9IChiYXNldXJsOnN0cmluZyxcbiAgICBnZXRkYXRhOm9iamVjdCxcbiAgICBwb3N0ZGF0YTpzdHJpbmcgfCBvYmplY3QgfCBBcnJheUJ1ZmZlciB8IEFycmF5QnVmZmVyVmlldyxcbiAgICBoZWFkZXJzOm9iamVjdCA9IHt9LFxuICAgIGF4aW9zQ29uZmlnOkF4aW9zUmVxdWVzdENvbmZpZyA9IHVuZGVmaW5lZClcbiAgOiBQcm9taXNlPFJlcXVlc3RSZXNwb25zZURhdGE+ID0+IHRoaXMuX3JlcXVlc3QoJ1BVVCcsXG4gICAgYmFzZXVybCxcbiAgICBnZXRkYXRhLFxuICAgIHBvc3RkYXRhLFxuICAgIGhlYWRlcnMsXG4gICAgYXhpb3NDb25maWcpO1xuXG4gIC8qKlxuICAgICAqIE1ha2VzIGEgUEFUQ0ggY2FsbCB0byBhbiBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZXVybCBQYXRoIHRvIHRoZSBiYXNldXJsXG4gICAgICogQHBhcmFtIGdldGRhdGEgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleSB2YWx1ZSBwYWlycyBzZW50IGluIFBBVENIXG4gICAgICogQHBhcmFtIHBvc3RkYXRhIE9iamVjdCBjb250YWluaW5nIHRoZSBrZXkgdmFsdWUgcGFpcnMgc2VudCBpbiBQQVRDSFxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIE9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBBUEkgY2FsbFxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIGFycmF5IEhUVFAgUmVxdWVzdCBIZWFkZXJzXG4gICAgICogQHBhcmFtIGF4aW9zQ29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBheGlvcyBqYXZhc2NyaXB0IGxpYnJhcnkgdGhhdCB3aWxsIGJlIHRoZVxuICAgICAqIGZvdW5kYXRpb24gZm9yIHRoZSByZXN0IG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgZm9yIFtbUmVxdWVzdFJlc3BvbnNlRGF0YV1dXG4gICAgICovXG4gIHBhdGNoID0gKGJhc2V1cmw6c3RyaW5nLFxuICAgIGdldGRhdGE6b2JqZWN0LFxuICAgIHBvc3RkYXRhOnN0cmluZyB8IG9iamVjdCB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3LFxuICAgIGhlYWRlcnM6b2JqZWN0ID0ge30sXG4gICAgYXhpb3NDb25maWc6QXhpb3NSZXF1ZXN0Q29uZmlnID0gdW5kZWZpbmVkKVxuICA6IFByb21pc2U8UmVxdWVzdFJlc3BvbnNlRGF0YT4gPT4gdGhpcy5fcmVxdWVzdCgnUEFUQ0gnLFxuICAgIGJhc2V1cmwsXG4gICAgZ2V0ZGF0YSxcbiAgICBwb3N0ZGF0YSxcbiAgICBoZWFkZXJzLFxuICAgIGF4aW9zQ29uZmlnKTtcblxuICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEF2YWxhbmNoZSBpbnN0YW5jZS4gU2V0cyB0aGUgYWRkcmVzcyBhbmQgcG9ydCBvZiB0aGUgbWFpbiBBdmFsYW5jaGUgQ2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlwIFRoZSBob3N0bmFtZSB0byByZXNvbHZlIHRvIHJlYWNoIHRoZSBBdmFsYW5jaGUgQ2xpZW50IEFQSXNcbiAgICAgKiBAcGFyYW0gcG9ydCBUaGUgcG9ydCB0byByZXNvbHZlIHRvIHJlYWNoIHRoZSBBdmFsYW5jaGUgQ2xpZW50IEFQSXNcbiAgICAgKiBAcGFyYW0gcHJvdG9jb2wgVGhlIHByb3RvY29sIHN0cmluZyB0byB1c2UgYmVmb3JlIGEgXCI6Ly9cIiBpbiBhIHJlcXVlc3QsIGV4OiBcImh0dHBcIiwgXCJodHRwc1wiLCBcImdpdFwiLCBcIndzXCIsIGV0YyAuLi5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoaXA6c3RyaW5nLCBwb3J0Om51bWJlciwgcHJvdG9jb2w6c3RyaW5nID0gJ2h0dHAnKSB7XG4gICAgdGhpcy5zZXRBZGRyZXNzKGlwLCBwb3J0LCBwcm90b2NvbCk7XG4gIH1cbn1cbiJdfQ==